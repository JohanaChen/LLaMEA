{"id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 58, in bbb_test_suite\nTypeError: evaluate() missing 1 required positional argument: 'x'\n.", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 58, in bbb_test_suite\nTypeError: evaluate() missing 1 required positional argument: 'x'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "42be3ca2-aa7a-4d16-8c80-89082ec9b9cd", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine strategy with 30% probability\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles to refine\n                    i, j = random.sample(range(self.dim), 2)\n                    # Perturb the selected particle\n                    x[i] += random.uniform(-0.1, 0.1)\n                    x[j] += random.uniform(-0.1, 0.1)\n                    # Clip to bounds\n                    x = np.clip(x, -5.0, 5.0)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probabilistic refinement.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "692252b1-e792-4f83-b5ac-edbafea2cd68", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability 0.3\n            if random.random() < self.probability:\n                r = random.random()\n                if r < 0.5:\n                    # Perturb\n                    v = np.random.uniform(-1.0, 1.0, (self.dim,))\n                    x += v\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                else:\n                    # Mutate\n                    v = np.random.uniform(-1.0, 1.0, (self.dim,))\n                    x += v\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "7526ecac-e490-4189-86b2-03b9079d436f", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Apply mutation with 30% probability\n                if random.random() < self.mutation_prob:\n                    x += np.random.uniform(-0.1, 0.1, (self.dim,))\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with 30% probability mutation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "2eea2a51-2142-419d-a27e-0dbffd779aa8", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy\n            if random.random() < self.refine_prob:\n                # Randomly select a particle to refine\n                i = random.randint(0, self.budget - 1)\n                # Refine the particle by adding a random perturbation\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                x[i] += perturbation\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[i] = x\n                    self.f_best = f\n                    self.pbest[i] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with refinement strategy", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "c7cc6181-55cf-4119-8e49-1af708e9d382", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine strategy with 30% probability\n                if random.random() < self.refine_prob:\n                    # Randomly select a dimension to mutate\n                    dim_to_mutate = random.randint(0, self.dim - 1)\n                    # Generate a new value for the dimension\n                    new_value = np.random.uniform(-5.0, 5.0)\n                    # Apply mutation\n                    x[dim_to_mutate] = new_value\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation to handle black box optimization problems with refinement.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "24bb6e08-21da-4da1-899b-14d732b8859b", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_rate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Mutation with 30% probability\n                if random.random() < self.mutation_rate:\n                    # Select a random dimension\n                    dim = np.random.randint(0, self.dim)\n                    # Change the value of the selected dimension\n                    x[dim] = np.random.uniform(-5.0, 5.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with 30% probability of line mutation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "667de385-6a7d-4cb8-92de-f59f039dc181", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with 30% probability\n            if random.random() < self.refine_prob:\n                # Randomly select two particles to refine\n                i1, i2 = random.sample(range(self.budget), 2)\n                # Calculate new particle using PSO and DE\n                v = np.zeros(self.dim)\n                v += self.c1 * (self.gbest - self.x_best[i1])\n                v += self.c2 * (self.pbest[i2] - self.x_best[i2])\n                v = v * self.f\n                x_refine = self.x_best[i1] + v\n                f_refine = func(x_refine)\n                # Update best particle if new particle is better\n                if f_refine < self.f_best:\n                    self.x_best[i2] = x_refine\n                    self.f_best = f_refine\n                    self.pbest[i2] = x_refine\n                    if f_refine < self.f:\n                        self.f = f_refine\n                        self.gbest = x_refine\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with refinement probability.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "86ef84ae-6489-488b-a6fa-d8575927e387", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability 0.3\n            if random.random() < self.refine_prob:\n                # Randomly select a particle\n                idx = random.randint(0, self.budget - 1)\n                # Refine the particle's position\n                r = random.random()\n                if r < 0.5:\n                    # Add a random perturbation\n                    x += np.random.uniform(-0.1, 0.1, self.dim)\n                else:\n                    # Replace the particle's position with the best one\n                    x = self.x_best[idx]\n                # Evaluate the new position\n                f = func(x)\n                # Update the particle's best position and fitness\n                if f < self.f_best:\n                    self.x_best[idx] = x\n                    self.f_best = f\n                    self.pbest[idx] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probability-based refinement.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "f3650fa1-8af6-44c0-9bc5-d34d57ebbb66", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODECrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.crossover_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Crossover\n            if random.random() < self.crossover_prob:\n                # Select two random particles\n                i = random.randint(0, self.budget - 1)\n                j = random.randint(0, self.budget - 1)\n                # Swap parts of the two particles\n                x[i] = (x[i] + x[j]) / 2\n                x[j] = (x[i] + x[j]) / 2\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODECrossover", "description": "Novel \"Swarm-PSO-DE-Crossover\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and crossover to handle black box optimization problems.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "09d7a9ec-3bfb-4625-9775-ad14bb456f91", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODEProb:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply probability-based mutation\n                if random.random() < self.probability:\n                    mutation_factor = random.uniform(0.1, 1.0)\n                    x += mutation_factor * (np.random.uniform(-1.0, 1.0, (self.dim,)) - x)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODEProb", "description": "Novel \"Swarm-PSO-DE-Prob\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and probability-based mutation to handle black box optimization problems.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "bcc441a3-4334-467d-833b-3dfe0556dd15", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_change_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Change individual lines with probability 0.3\n                if random.random() < self.p_change_prob:\n                    x = np.random.uniform(-5.0, 5.0, (self.dim,))\n                    if random.random() < 0.5:\n                        x += np.random.uniform(-0.1, 0.1, (self.dim,))\n                    if random.random() < 0.5:\n                        x *= np.random.uniform(0.9, 1.1, (self.dim,))\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "1db53e75-1ad9-4031-b144-6f749c3920e4", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random_search_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles with PSO and DE\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Random search with 20% probability\n            if random.random() < self.random_search_prob:\n                # Randomly select 10 points in the search space\n                points = np.random.uniform(-5.0, 5.0, (10, self.dim))\n                # Evaluate the function at these points\n                f_values = func(points)\n                # Return the best point and its value\n                best_point = points[np.argmin(f_values)]\n                self.x_best[_] = best_point\n                self.f_best = f_values[np.argmin(f_values)]\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Random Search to handle black box optimization problems with a probability of 0.3 for refining the strategy.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "1f540ac0-5777-4b23-97fa-f4064836775b", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Line search to find the optimal step size\n                    alpha = 0.1\n                    x_refined = x + alpha * (self.gbest - self.x_best[_])\n                    f_refined = func(x_refined)\n                    if f_refined < f:\n                        self.x_best[_] = x_refined\n                        self.f_best = f_refined\n                        self.pbest[_] = x_refined\n                        if f_refined < self.f:\n                            self.f = f_refined\n                            self.gbest = x_refined\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and line search to handle black box optimization problems with probability-based refinement.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "144f3505-b746-4a23-ad89-934e4ee47520", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine particles with mutation\n                if random.random() < self.mutation_prob:\n                    mutation_index = random.randint(0, self.dim - 1)\n                    x[mutation_index] += np.random.uniform(-1.0, 1.0)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "e2fbb6ef-ddb7-4408-8215-0f488f5f99f0", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Apply mutation with probability 0.3\n                if random.random() < self.mutation_prob:\n                    idx = np.random.randint(0, self.dim)\n                    x[idx] += np.random.uniform(-0.5, 0.5)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "a06e4349-2a28-4b83-a957-5df5da958d2c", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine strategy\n                if random.random() < self.refine_prob:\n                    # Randomly select a dimension to refine\n                    dim_to_refine = random.randint(0, self.dim - 1)\n                    # Refine the selected dimension\n                    x[dim_to_refine] += 0.1 * (self.f_best - self.f)\n                    # Update the best and personal best values\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with line-by-line refinement strategy.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "c46ec258-c183-4927-bbb6-cf699a6defd8", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n        self.mutation_rate = 0.1\n        self.mutation_step = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine particles with mutation\n                if random.random() < self.mutation_prob:\n                    mutation = np.random.uniform(-self.mutation_rate, self.mutation_rate, self.dim)\n                    x += mutation * self.mutation_step\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems with adaptive probability.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "afe9dfad-a838-40e7-ac78-9c52a1b5c551", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Random mutation\n                if random.random() < self.random_prob:\n                    # Randomly choose a dimension\n                    idx = np.random.randint(0, self.dim)\n                    # Randomly change the value of the chosen dimension\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Random mutation to handle black box optimization problems.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "481550bd-7d7b-4972-b105-a13ea42bb0bf", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with 30% probability\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i, j = np.random.choice(self.budget, 2, replace=False)\n                    # Calculate new particle by taking the average of the two particles\n                    new_x = (self.x_best[i] + self.x_best[j]) / 2\n                    # Update particle\n                    self.x_best[i] = new_x\n                    self.f_best = func(new_x)\n                    self.pbest[i] = new_x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "4d549325-1295-43d2-aae0-8dd7c3b6a1c3", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine strategy with 30% probability\n                if random.random() < self.mutation_prob:\n                    x = np.random.uniform(-5.0, 5.0, (self.dim,))\n                    x = x * np.clip((x - self.x_best[_]) / np.linalg.norm(x - self.x_best[_]), -1, 1) + self.x_best[_]\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "81af812d-a6a7-4d93-9232-8f10e0d475b7", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply mutation with probability 0.3\n                if random.random() < self.mutation_prob:\n                    # Randomly select two individuals\n                    i1, i2 = np.random.choice(self.budget, 2, replace=False)\n                    # Swap components\n                    x[i1] = x[i2]\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "7f295454-1057-4706-8cf3-8e154cf6cd57", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODECrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.crossover_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Crossover\n                if random.random() < self.crossover_prob:\n                    # Randomly choose two particles\n                    i, j = random.sample(range(self.budget), 2)\n                    # Select the f-best particle\n                    if self.f_best < self.f_best[i]:\n                        x[i] = self.x_best[i]\n                    else:\n                        x[i] = self.x_best[j]\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODECrossover", "description": "Novel \"Swarm-PSO-DE-Crossover\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Crossover to handle black box optimization problems.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "48148b69-e82f-4967-84fe-97d8ab13fb77", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_change = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine the strategy with probability 0.3\n                if random.random() < self.p_change:\n                    # Randomly select two particles\n                    i, j = np.random.choice(self.dim, 2, replace=False)\n                    # Swap their positions\n                    x[i], x[j] = x[j], x[i]\n                    # Update their fitness\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "30aee369-25d5-4734-943c-9c46d0a157c1", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Adaptive mutation strategy\n                if random.random() < self.p:\n                    # Randomly select a particle\n                    i = np.random.randint(0, self.budget)\n                    # Swap the particle's position with a random position in the population\n                    x[i] = x[i] + np.random.uniform(-5.0, 5.0, self.dim)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[i] = x\n                        self.f_best = f\n                        self.pbest[i] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation strategy.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "1dc2449c-636d-4024-9b26-45aea3ae8aba", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODEProb:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability 0.3\n            if random.random() < self.refine_prob:\n                for i in range(self.dim):\n                    # Randomly select a particle\n                    p_idx = random.randint(0, self.budget - 1)\n                    # Generate a new value for the selected particle\n                    new_x = np.random.uniform(-5.0, 5.0)\n                    # Update the particle's value\n                    self.x_best[p_idx, i] = new_x\n                    # Update the particle's fitness\n                    self.f_best = func(self.x_best[p_idx])\n                    # Update the particle's best value\n                    if self.f_best < self.f:\n                        self.f = self.f_best\n                        self.gbest = self.x_best[p_idx]\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODEProb", "description": "Novel \"Swarm-PSO-DE-Prob\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and probability-based strategy refinement.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "ce80b311-2434-48d0-b32b-399250964a27", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Random mutation\n                if random.random() < self.p:\n                    x += np.random.uniform(-1.0, 1.0, (self.dim))\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and random mutation to handle black box optimization problems.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "81752002-1b15-4c2b-a9da-5701e2468fc8", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_change_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Change individual lines with probability 0.3\n                if random.random() < self.p_change_prob:\n                    # Randomly select two particles\n                    i1, i2 = random.sample(range(self.budget), 2)\n                    # Swap their values\n                    x[i1], x[i2] = x[i2], x[i1]\n                    # Update the best values\n                    self.f_best = min(self.f_best, f)\n                    self.x_best[i1] = x\n                    self.pbest[i1] = x\n                    self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "0301d9d3-210c-4544-a67d-3e1b9475c419", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability 0.3\n            if random.random() < self.probability:\n                # Randomly select a particle\n                index = np.random.randint(0, self.budget)\n                # Change the individual lines of the selected particle\n                x[index] = np.random.uniform(-5.0, 5.0, (self.dim,))\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[index] = x\n                    self.f_best = f\n                    self.pbest[index] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "bbfa3935-2514-4ce2-b868-a5252caa7a82", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random_search_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Random Search with 20% probability\n            if random.random() < self.random_search_prob:\n                x_random = np.random.uniform(-5.0, 5.0, (self.dim,))\n                f_random = func(x_random)\n                if f_random < self.f_best:\n                    self.x_best[_] = x_random\n                    self.f_best = f_random\n                    self.pbest[_] = x_random\n                    if f_random < self.f:\n                        self.f = f_random\n                        self.gbest = x_random\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Random Search to handle black box optimization problems.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "03d51279-9037-4933-9630-4a9432cf975e", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i1, i2 = random.sample(range(self.budget), 2)\n                    # Swap their values\n                    x[i1], x[i2] = x[i2], x[i1]\n                    # Update particles\n                    self.x_best[i1] = x\n                    self.pbest[i1] = x\n                    self.f_best = func(x)\n                    if self.f_best < self.f:\n                        self.f = self.f_best\n                        self.gbest = self.x_best[i1]\n\n                # Evaluate function\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with refinement probability 0.3.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "854fc470-148c-4932-b30f-cebc91996451", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mut_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Adaptive mutation probability\n                if random.random() < self.mut_prob:\n                    idx = np.random.randint(0, self.dim)\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation probability.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "9e1a8faf-bde6-4140-bd5f-a7e3b0326252", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_change = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Change individual lines with probability 0.3\n                if random.random() < self.p_change:\n                    # Change one dimension randomly\n                    idx = random.randint(0, self.dim - 1)\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "77f0b6af-a72a-4f6a-9c4b-e47f0f5e008a", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with 30% probability\n                if random.random() < self.probability:\n                    # Perform local search around the current particle\n                    x = np.array([self.x_best[_]])\n                    for i in range(self.dim):\n                        lower_bound = np.maximum(x - 0.1, -5.0)\n                        upper_bound = np.minimum(x + 0.1, 5.0)\n                        x[i] = np.random.uniform(lower_bound, upper_bound)\n                        f = func(x)\n                        if f < self.f_best:\n                            self.x_best[_] = x\n                            self.f_best = f\n                            self.pbest[_] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "484ad13a-3e46-4618-b265-fb44c1388f04", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Randomly decide which particles to update\n            if random.random() < self.random_prob:\n                for _ in range(100):\n                    r1 = random.random()\n                    r2 = random.random()\n                    v = np.zeros(self.dim)\n                    v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                    v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                    v = v * self.f\n                    x += v\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n            else:\n                # Perform DE\n                for _ in range(100):\n                    r1 = random.random()\n                    r2 = random.random()\n                    v = np.zeros(self.dim)\n                    v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                    v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                    v = v * self.f\n                    x += v\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Random Search to handle black box optimization problems.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "e7ba7c37-78df-4ff5-9bcb-75fe1fae3668", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability\n            if random.random() < self.probability:\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        x[i] += np.random.uniform(-1.0, 1.0)\n                    else:\n                        x[i] -= np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "8e7f2dce-70ee-4a92-8642-4abb600209c0", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Line search with probability refinement\n                if random.random() < self.p:\n                    # Refine the search direction\n                    f_refined = func(x + self.p * v)\n                    if f_refined < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f_refined\n                        self.pbest[_] = x\n                        if f_refined < self.f:\n                            self.f = f_refined\n                            self.gbest = x\n                else:\n                    # Original search direction\n                    f_original = func(x)\n                    if f_original < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f_original\n                        self.pbest[_] = x\n                        if f_original < self.f:\n                            self.f = f_original\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and line search to handle black box optimization problems with probability refinement.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "acdb8497-41a0-44c5-a9c0-375bdde6facf", "solution": "import numpy as np\nimport random\nimport scipy.optimize as optimize\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.line_search = True\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Line search\n                if self.line_search:\n                    res = optimize.minimize(func, x, method='SLSQP')\n                    x = res.x\n\n                # Adaptive mutation\n                if random.random() < 0.3:\n                    x += np.random.uniform(-0.5, 0.5, self.dim)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and line search to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "78971f9d-b961-4c29-a1fa-026cf0e0f7ee", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODEProb:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles with probability\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if random.random() < self.prob and f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n# Example usage:\nfuncs = [lambda x: x**2, lambda x: x**4, lambda x: x**6, lambda x: x**8, lambda x: x**10, lambda x: x**12, lambda x: x**14, lambda x: x**16, lambda x: x**18, lambda x: x**20, lambda x: x**22, lambda x: x**24, lambda x: x**26, lambda x: x**28, lambda x: x**30, lambda x: x**32, lambda x: x**34, lambda x: x**36, lambda x: x**38, lambda x: x**40, lambda x: x**42, lambda x: x**44, lambda x: x**46, lambda x: x**48]\nswarmPSODEProb = SwarmPSODEProb(100, 5)\nfor func in funcs:\n    swarmPSODEProb(func)\n    print(f\"Function: {func.__name__}\")\n    print(f\"Best fitness: {swarmPSODEProb.f_best}\")\n    print(f\"Best x: {swarmPSODEProb.x_best[np.argmax(swarmPSODEProb.f_best)]}\")\n    print(f\"\")", "name": "SwarmPSODEProb", "description": "Novel \"Swarm-PSO-DE-Prob\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and probability to handle black box optimization problems.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "305538dc-246b-4787-a746-a829cc271581", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_change_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    if random.random() < self.p_change_prob:\n                        # Change the individual line of the selected solution\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n                    else:\n                        # Keep the same individual\n                        self.x_best[_] = self.x_best[_]\n                        self.f_best = self.f_best\n                        self.pbest[_] = self.pbest[_]\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "059e9688-db9c-466c-947c-223566c97a68", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy\n            if random.random() < self.refine_prob:\n                # Choose a random particle\n                idx = random.randint(0, self.budget - 1)\n                # Perturb the particle\n                x = self.x_best[idx] + 0.1 * np.random.normal(0, 1, self.dim)\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[idx] = x\n                    self.f_best = f\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and refinement strategy to handle black box optimization problems.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "4c2b1687-f2c4-4c2f-9750-d72ba2a7d5b4", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.perturb_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Perturb with probability 0.3\n                if random.random() < self.perturb_prob:\n                    x = x + np.random.normal(0, 0.1, self.dim)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "6febf75c-2a91-49ac-98ea-05e554d5c20e", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random_refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Random refinement with 30% probability\n                if random.random() < self.random_refine_prob:\n                    x += np.random.uniform(-0.5, 0.5, (self.dim)) * 0.1\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()\n\n# Test the SwarmPSODERandom algorithm\nbudget = 100\ndim = 5\nswarm = SwarmPSODERandom(budget, dim)\nfor func in funcs:\n    x = np.random.uniform(-5.0, 5.0, (budget, dim))\n    f = func(x)\n    print(f\"Function: {func.__name__}\")\n    print(f\"Mean: {np.mean(f)}\")\n    print(f\"Median: {np.median(f)}\")\n    print(f\"Standard Deviation: {np.std(f)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Random Search to handle black box optimization problems with a probability of 0.3 for refining the strategy.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "50bfb038-b45c-464a-8474-30c9d44b27e2", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability 0.3\n            if random.random() < self.probability:\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        x[_] += random.uniform(-1.0, 1.0)\n                    else:\n                        x[_] -= random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "100c1e69-383e-468b-9609-cf18377e7b9f", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Apply mutation with 30% probability\n                if random.random() < self.mutation_prob:\n                    idx = np.random.randint(0, self.dim)\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with 30% probability mutation.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "a8c63733-70be-49ba-b66c-4d8793df6241", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability 0.3\n            if random.random() < self.refine_prob:\n                # Select two particles to refine\n                idx1 = random.randint(0, self.budget - 1)\n                idx2 = random.randint(0, self.budget - 1)\n                # Refine the first particle\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[idx1])\n                v += self.c2 * r2 * (self.pbest[idx1] - self.x_best[idx1])\n                v = v * self.f\n                x = self.x_best[idx1] + v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[idx1] = x\n                    self.f_best = f\n                    self.pbest[idx1] = x\n                # Refine the second particle\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[idx2])\n                v += self.c2 * r2 * (self.pbest[idx2] - self.x_best[idx2])\n                v = v * self.f\n                x = self.x_best[idx2] + v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[idx2] = x\n                    self.f_best = f\n                    self.pbest[idx2] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probability-based refinement.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "ced3010c-b7f9-4a7c-93dd-d6d63da873d7", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random_search_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Random search\n            if random.random() < self.random_search_prob:\n                # Generate a random point in the search space\n                x_random = np.random.uniform(-5.0, 5.0, (self.dim,))\n                f_random = func(x_random)\n                if f_random < self.f_best:\n                    self.x_best[_] = x_random\n                    self.f_best = f_random\n                    self.pbest[_] = x_random\n                    if f_random < self.f:\n                        self.f = f_random\n                        self.gbest = x_random\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Random Search to handle black box optimization problems.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "4f0fd676-a771-490d-b906-66a9ecbd4938", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine particles with probability 0.3\n            if random.random() < self.refine_prob:\n                for _ in range(10):\n                    # Select a random particle\n                    idx = random.randint(0, self.budget - 1)\n                    # Generate a new individual\n                    new_x = np.random.uniform(-5.0, 5.0, (self.dim,))\n                    # Evaluate the new individual\n                    new_f = func(new_x)\n                    # If the new individual is better, update the particle\n                    if new_f < self.f_best[idx]:\n                        self.x_best[idx] = new_x\n                        self.f_best[idx] = new_f\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems with adaptive probability.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "4153d6ee-e215-45d4-affc-8d7f6970dee3", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i1, i2 = random.sample(range(self.budget), 2)\n                    # Select the better particle\n                    if self.f_best[i1] < self.f_best[i2]:\n                        x = self.x_best[i1]\n                        self.x_best[i2] = x\n                        self.f_best[i2] = self.f_best[i1]\n                        self.pbest[i2] = self.pbest[i1]\n                        self.gbest = self.x_best[i2]\n                    else:\n                        x = self.x_best[i2]\n                        self.x_best[i1] = x\n                        self.f_best[i1] = self.f_best[i2]\n                        self.pbest[i1] = self.pbest[i2]\n                        self.gbest = self.x_best[i1]\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and refinement strategy to handle black box optimization problems with a probability of 0.3.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "4f1ba009-8c68-4845-b845-fe2cc6a5bd5a", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Random mutation\n                if random.random() < self.random_prob:\n                    mutation_index = np.random.randint(0, self.dim)\n                    x[mutation_index] += np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and random mutation to handle black box optimization problems.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "34573acb-c01e-4207-b174-78831fbbde3f", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply mutation with probability 0.3\n                if random.random() < self.mutation_prob:\n                    x += np.random.uniform(-0.1, 0.1, (self.dim)) * np.random.uniform(-1, 1, (self.dim))\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "e95be9d1-6a9e-43f5-92cf-9e987aee45d4", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODECrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.crossover_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Crossover\n                if random.random() < self.crossover_prob:\n                    # Select two random particles\n                    i = random.randint(0, self.budget - 1)\n                    j = random.randint(0, self.budget - 1)\n                    # Swap the two particles\n                    x[i], x[j] = x[j], x[i]\n                    # Update the best particles\n                    self.f_best = min(self.f_best, func(x))\n                    self.gbest = min(self.gbest, x)\n                    self.pbest[i] = x\n                    self.pbest[j] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODECrossover", "description": "Novel \"Swarm-PSO-DE-Crossover\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and crossover to handle black box optimization problems.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "42cc5374-b511-4943-82b9-df92866f367e", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODEProb:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles with probability-based strategy\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if random.random() < self.probability:\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n                else:\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODEProb", "description": "Novel \"Swarm-PSO-DE-Prob\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and probability-based strategy to handle black box optimization problems.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "c0766fc8-3b0c-4d71-bf70-71ccc37474cf", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.perturb_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Random perturbation\n                if random.random() < self.perturb_prob:\n                    x += np.random.uniform(-0.1, 0.1, (self.dim))\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and random perturbation to handle black box optimization problems.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "f812c026-da76-4345-aec8-aa82508b065e", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.random = np.random.rand()\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Random mutation\n                if self.random < 0.3:\n                    mutation = np.random.uniform(-1.0, 1.0, (self.dim,))\n                    x += mutation\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with random mutation to handle black box optimization problems.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "b9ca62d9-0011-41ca-a68a-cb92ce2c2f76", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.perturbation_probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Perturb x with probability 0.3\n                if random.random() < self.perturbation_probability:\n                    x += np.random.uniform(-0.5, 0.5, self.dim)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "69c47c02-d8a0-4d4a-9f17-6b82704ea298", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODER:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.rws_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Roulette Wheel Selection (RWS)\n                if random.random() < self.rws_prob:\n                    r = random.random()\n                    r = r / (self.f_best - self.f)\n                    x = self.x_best[np.argsort([func(xi) for xi in self.x_best])[::-1]][int(r * (self.dim - 1))]  # Select the best individual with probability r\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()\n", "name": "SwarmPSODER", "description": "Novel \"Swarm-PSO-DE-R\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Roulette Wheel Selection (RWS) to handle black box optimization problems.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "0ff7129a-768e-4110-a121-6ed2485e2621", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with 30% probability\n                if random.random() < self.refine_prob:\n                    # Randomly replace 30% of particles\n                    replace_idx = np.random.choice(self.dim, size=int(self.dim * self.refine_prob), replace=True)\n                    x[replace_idx] = np.random.uniform(-5.0, 5.0, size=len(replace_idx))\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()\n", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probabilistic refinement.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "50b8f1b4-8c0d-4efa-ad5e-0ad73c4b316d", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine particles with probability 0.3\n                if random.random() < self.refine_prob:\n                    r = np.random.uniform(-1.0, 1.0, self.dim)\n                    x += r\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probability refinement.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "8644f908-7d7f-49a1-be51-055ffbf820b3", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with probability 0.3\n            if random.random() < self.refine_prob:\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        x[i] += np.random.uniform(-0.1, 0.1)\n                    if random.random() < 0.5:\n                        x[i] -= np.random.uniform(-0.1, 0.1)\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probability-based refinement.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "ea6189ae-38be-4618-895c-5c041629ee7f", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_rate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply mutation with 30% probability\n                if random.random() < self.mutation_rate:\n                    x = self.mutate(x)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n    def mutate(self, x):\n        # Apply line mutation with 30% probability\n        if random.random() < self.mutation_rate:\n            i = random.randint(0, self.dim - 1)\n            x[i] = x[i] + random.uniform(-1.0, 1.0)\n            x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n        return x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with 30% probability of line mutation.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "442abad4-e3bd-4ce8-9133-e053fb39aaaf", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODECrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.crossover_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply crossover with probability 0.3\n                if random.random() < self.crossover_prob:\n                    x = self.crossover(x, self.pbest[_])\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n    def crossover(self, x, y):\n        # Simple crossover using the average of two points\n        return (x + y) / 2\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODECrossover", "description": "Novel \"Swarm-PSO-DE-Crossover\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Crossover to handle black box optimization problems.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "4b61b62a-aaa5-44f9-819c-6c60b817e8e1", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Adaptive mutation\n                if random.random() < self.mutation_prob:\n                    # Randomly select a dimension to mutate\n                    idx = random.randint(0, self.dim - 1)\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "4c1575d8-8b7b-40c8-b4f7-66974abea3ba", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply mutation with probability 0.3\n                if random.random() < self.mutation_prob:\n                    # Randomly select two particles\n                    i, j = np.random.choice(self.dim, size=2, replace=False)\n                    # Swap the values of the two particles\n                    x[i], x[j] = x[j], x[i]\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "57cbb33a-135e-4f37-96e7-f2d334da2658", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy\n                if random.random() < self.refine_prob:\n                    # Randomly select a particle to refine\n                    i = random.randint(0, self.budget - 1)\n                    # Refine the selected particle\n                    x = np.array([self.x_best[j] for j in range(self.budget) if j!= i])\n                    v = np.zeros(self.dim)\n                    v += self.c1 * random.random() * (self.gbest - self.x_best[i])\n                    v += self.c2 * random.random() * (self.pbest[i] - self.x_best[i])\n                    v = v * self.f\n                    x += v\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[i] = x\n                        self.f_best = f\n                        self.pbest[i] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with refinement strategy.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "d39506cb-d841-4ee9-8bd7-6dc08bac4e19", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i, j = np.random.choice(self.dim, size=2, replace=False)\n                    # Calculate new velocity and position\n                    v = np.zeros(self.dim)\n                    v[i] = self.c1 * (self.gbest[i] - self.x_best[_]) + random.random() * 2 * (self.gbest[i] - self.x_best[_])\n                    v[j] = self.c2 * (self.pbest[j] - self.x_best[_]) + random.random() * 2 * (self.pbest[j] - self.x_best[_])\n                    v = v * self.f\n                    x[i] = self.x_best[_] + v[i]\n                    x[j] = self.x_best[_] + v[j]\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with a probability of 0.3 to refine the strategy.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "d53f6e9f-819d-46d8-a1ed-ec23dcdc7d20", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i1, i2 = random.sample(range(self.budget), 2)\n                    # Swap their positions\n                    x[i1], x[i2] = x[i2], x[i1]\n                    # Update the best and gbest values\n                    self.f_best = min(self.f_best, func(x))\n                    self.gbest = min(self.gbest, x)\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with refinement strategy.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "ffb54b33-74d6-4b7d-a0cf-9dc9b066ff9c", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i, j = random.sample(range(self.dim), 2)\n                    # Swap their values\n                    x[i], x[j] = x[j], x[i]\n                    # Update particles\n                    for _ in range(100):\n                        r1 = random.random()\n                        r2 = random.random()\n                        v = np.zeros(self.dim)\n                        v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                        v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                        v = v * self.f\n                        x += v\n                        x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                        f = func(x)\n                        if f < self.f_best:\n                            self.x_best[_] = x\n                            self.f_best = f\n                            self.pbest[_] = x\n                            if f < self.f:\n                                self.f = f\n                                self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with line-by-line refinement strategy.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "3a20e038-935f-4479-9768-70c976f311c0", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n        self.mutation_factor = 0.1\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Mutation refinement\n                if random.random() < self.mutation_prob:\n                    mutated_x = x + self.mutation_factor * np.random.uniform(-1, 1, (self.dim,))\n                    mutated_x = np.clip(mutated_x, -5.0, 5.0)  # Clip to bounds\n                    mutated_f = func(mutated_x)\n                    if mutated_f < f:\n                        x = mutated_x\n                        f = mutated_f\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "a7f9d1fc-15be-4729-a656-125bc86f8784", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODECross:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_cross_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Crossover\n                if random.random() < self.p_cross_prob:\n                    idx1, idx2 = np.random.choice(self.dim, 2, replace=False)\n                    x1, x2 = self.x_best[_], self.x_best[_]\n                    x1[idx1], x2[idx2] = x2[idx1], x1[idx2]\n                    self.x_best[_] = x1\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODECross", "description": "Novel \"Swarm-PSO-DE-Cross\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and crossover to handle black box optimization problems.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "860c708b-e75f-48c8-993a-dabfb0a9636b", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_rate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine particles with mutation\n                if random.random() < self.mutation_rate:\n                    for i in range(self.dim):\n                        if random.random() < 0.5:\n                            x[i] += random.uniform(-0.1, 0.1)\n                            x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "57385cc7-d977-4fdb-8333-b9deba1a1bb9", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.adaptation_rate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Adaptive mutation strategy\n                if random.random() < self.adaptation_rate:\n                    mutation = np.random.uniform(-0.5, 0.5, self.dim)\n                    x += mutation\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation strategy.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "315ffb39-f84b-40ef-a565-25076b9674e7", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODECrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.crossover_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Crossover with probability 0.3\n                if random.random() < self.crossover_prob:\n                    # Select two random particles\n                    i, j = random.sample(range(self.budget), 2)\n                    # Create a new particle by crossover\n                    x_new = (self.x_best[i] + self.x_best[j]) / 2\n                    # Evaluate the new particle\n                    f_new = func(x_new)\n                    # Update the best particle\n                    if f_new < self.f_best:\n                        self.x_best[_] = x_new\n                        self.f_best = f_new\n                        self.pbest[_] = x_new\n                        if f_new < self.f:\n                            self.f = f_new\n                            self.gbest = x_new\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODECrossover", "description": "Novel \"Swarm-PSO-DE-Crossover\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and crossover to handle black box optimization problems with probability 0.3.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "03f57f4e-afb3-42b4-99a4-ec21314ff2c6", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODEProb:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_mutate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Probabilistic mutation\n                if random.random() < self.p_mutate:\n                    for i in range(self.dim):\n                        if random.random() < 0.5:\n                            x[i] += np.random.uniform(-1.0, 1.0)\n                        else:\n                            x[i] -= np.random.uniform(-1.0, 1.0)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODEProb", "description": "Novel \"Swarm-PSO-DE-Prob\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with probabilistic mutation to handle black box optimization problems.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "662ca6b8-a9e7-44fe-99e3-4c024d780b50", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply mutation with probability\n                if random.random() < self.mutation_prob:\n                    x += np.random.uniform(-0.1, 0.1, (self.dim,))\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "c85b1a52-d9da-4e0d-8c2e-740208dacc41", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine particles with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i, j = random.sample(range(self.budget), 2)\n                    # Compute the average of the two particles\n                    x_avg = (self.x_best[i] + self.x_best[j]) / 2\n                    # Update the selected particle\n                    self.x_best[i] = x_avg\n                    self.f_best[i] = func(x_avg)\n                    self.pbest[i] = x_avg\n                    # Update the best particle\n                    if self.f_best[i] < self.f_best[j]:\n                        self.f_best[j] = self.f_best[i]\n                        self.x_best[j] = self.x_best[i]\n                        self.pbest[j] = self.pbest[i]\n                        self.gbest[j] = self.gbest[i]\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probability-based refinement.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "e4d94d1d-95a2-4173-9acf-a09e22762e31", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.probability:\n                    # Randomly change individual lines\n                    i = np.random.randint(0, self.dim)\n                    x[i] += random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "a6daa207-c6e7-4a47-a598-316a7732844d", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.randomness = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Random mutation\n                if random.random() < self.randomness:\n                    x += np.random.uniform(-1.0, 1.0, self.dim)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and random mutation to handle black box optimization problems.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "fbc1533c-7e8d-482d-ab0e-fde029e4a687", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Randomly select one dimension to refine\n                    dim_to_refine = random.randint(0, self.dim - 1)\n                    # Refine the selected dimension\n                    x[dim_to_refine] += np.random.uniform(-0.1, 0.1)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probability 0.3 to refine its strategy.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "46a576d4-e5fa-44bd-b12f-d651f9f96c1d", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability\n                if random.random() < self.probability:\n                    # Randomly choose a dimension to modify\n                    dim_to_modify = random.randint(0, self.dim - 1)\n                    # Generate a random value for the dimension\n                    new_value = np.random.uniform(-5.0, 5.0)\n                    # Modify the dimension\n                    x[dim_to_modify] += new_value\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "08beef81-ff18-49e5-baa8-9a97ff612ecd", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.changing_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # 30% probability of changing individual lines\n                if random.random() < self.changing_prob:\n                    # Randomly change one dimension\n                    idx = np.random.randint(self.dim)\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with 30% probability of changing individual lines.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "7a64f878-70fc-40b0-80e3-46077587083f", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine strategy with mutation\n                if random.random() < self.mutation_prob:\n                    mutation_factor = random.uniform(0.5, 1.5)\n                    x *= mutation_factor\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems with adaptive probability.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "c5286190-073d-45d7-a324-6d36aaa9c25d", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_rate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Adaptive mutation\n                if random.random() < self.mutation_rate:\n                    x = x + np.random.uniform(-1, 1, self.dim)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()\n", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "d58fef2a-8246-46df-9fde-327251196447", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy\n            if random.random() < self.refine_prob:\n                # Randomly select two particles\n                i, j = np.random.choice(self.budget, 2, replace=False)\n                # Swap their positions\n                x[i], x[j] = x[j], x[i]\n                # Update the best particle\n                if self.f_best < func(x[i]):\n                    self.x_best[i] = x[i]\n                    self.f_best = func(x[i])\n                    self.pbest[i] = x[i]\n                if self.f_best < func(x[j]):\n                    self.x_best[j] = x[j]\n                    self.f_best = func(x[j])\n                    self.pbest[j] = x[j]\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and refinement strategy to handle black box optimization problems.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "86f0baa9-6c28-4538-bb5b-d49f39b573be", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODECrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.crossover_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply crossover\n                if random.random() < self.crossover_prob:\n                    # Select a random individual\n                    other_individual = np.random.choice(self.x_best)\n                    # Perform crossover\n                    child = (other_individual + x) / 2\n                    # Evaluate the child\n                    f_child = func(child)\n                    if f_child < self.f_best:\n                        self.x_best[_] = child\n                        self.f_best = f_child\n                        self.pbest[_] = child\n                        if f_child < self.f:\n                            self.f = f_child\n                            self.gbest = child\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODECrossover", "description": "Novel \"Swarm-PSO-DE-Crossover\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and crossover to handle black box optimization problems.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "1f2d1cbd-4801-46cc-8c82-112c76322289", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODER:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.rws_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Roulette Wheel Selection\n            if random.random() < self.rws_prob:\n                # Select a random individual from the best individuals\n                idx = np.random.choice(self.dim, p=self.f_best / self.f_best.sum())\n                x = self.x_best[idx]\n\n    def evaluate_fitness(self, new_individual):\n        # Evaluate the fitness of the new individual\n        f = self(new_individual)\n        return f\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODER", "description": "Novel \"Swarm-PSO-DE-R\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and Roulette Wheel Selection (RWS) to handle black box optimization problems.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "f1af0a4a-6c7e-44c2-842b-3ffa54ddf02c", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Apply mutation with probability 0.3\n                if random.random() < self.mutation_prob:\n                    idx = np.random.randint(0, self.dim)\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "e8188e6b-f26c-4bac-bc0e-a86afb0bb080", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_mutate = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Line mutation with probability 0.3\n                if random.random() < self.p_mutate:\n                    idx = random.randint(0, self.dim - 1)\n                    x[idx] += random.uniform(-1.0, 1.0)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with line mutation and probability 0.3 to handle black box optimization problems.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "6deca79e-135f-4ef8-8e97-e7cf51318cba", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.probability:\n                    # Randomly select two particles\n                    i = np.random.randint(0, self.budget)\n                    j = np.random.randint(0, self.budget)\n                    # Swap their positions\n                    x[i], x[j] = x[j], x[i]\n                    # Update their best values\n                    self.f_best = min(self.f_best, func(x))\n                    self.pbest[i] = x\n                    self.pbest[j] = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "24f25f18-4a4c-4d34-a78d-42ba0be28d08", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_change_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Random mutation with probability 0.3\n                if random.random() < self.p_change_prob:\n                    idx = np.random.randint(0, self.dim)\n                    x[idx] += np.random.uniform(-1.0, 1.0)\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and random mutation to handle black box optimization problems.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "bb77e32b-91f9-450e-a706-716c7e525158", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.probability:\n                    # Randomly replace particle with a new one\n                    new_x = np.random.uniform(-5.0, 5.0, (self.dim,))\n                    new_x = np.clip(new_x, -5.0, 5.0)  # Clip to bounds\n                    self.x_best[_] = new_x\n                    self.f_best = func(new_x)\n                    self.pbest[_] = new_x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive probability.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "56f4a5ab-3f5d-468e-abc4-87b2f33ea2fb", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERandom:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_random = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Random mutation with probability 0.3\n                if random.random() < self.p_random:\n                    x += np.random.uniform(-0.1, 0.1, (self.dim))\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERandom", "description": "Novel \"Swarm-PSO-DE-Random\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with random mutation to handle black box optimization problems.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "734d6f93-e6d1-4267-a610-f04fd139ed91", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Refine particles with mutation\n                if random.random() < self.mutation_prob:\n                    mutation_factor = random.uniform(0.1, 0.3)\n                    x = x + mutation_factor * np.random.normal(0, 1, self.dim)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "e88d4b17-faee-423e-80e7-53b99dc44d79", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODEProb:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i, j = np.random.choice(self.budget, 2, replace=False)\n                    # Swap their values\n                    x[i], x[j] = x[j], x[i]\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[i] = x\n                        self.f_best = f\n                        self.pbest[i] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODEProb", "description": "Novel \"Swarm-PSO-DE-Prob\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and probability-based refinement for black box optimization problems.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "c9803ed1-e51e-4bfb-99a0-b15f3db240c4", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.p_mut = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Adaptive mutation\n                if random.random() < self.p_mut:\n                    i = np.random.randint(0, self.dim)\n                    x[i] += np.random.uniform(-1.0, 1.0)\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive mutation.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "a500275f-0b1a-4649-9656-54d0ffb0cbfc", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODERefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine particles using mutation\n                if random.random() < self.mutation_prob:\n                    for i in range(self.dim):\n                        if random.random() < 0.5:\n                            x[i] += np.random.uniform(-0.1, 0.1)\n                            x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                            f = func(x)\n                            if f < self.f_best:\n                                self.x_best[_] = x\n                                self.f_best = f\n                                self.pbest[_] = x\n                                if f < self.f:\n                                    self.f = f\n                                    self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODERefine", "description": "Novel \"Swarm-PSO-DE-Refine\" algorithm combining Particle Swarm Optimization (PSO), Differential Evolution (DE), and mutation refinement to handle black box optimization problems.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "38424762-3aed-4032-a389-c712c896a6fe", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.probability = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n            # Refine strategy with adaptive probability\n            if random.random() < self.probability:\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        x[i] += np.random.uniform(-1.0, 1.0)\n                    else:\n                        x[i] -= np.random.uniform(-1.0, 1.0)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with adaptive probability.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "7db25e63-d856-4993-8e2c-af65ed1f46f6", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.prob_refine = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine particles with probability 0.3\n                if random.random() < self.prob_refine:\n                    idx = np.random.randint(0, self.dim)\n                    x[idx] += np.random.uniform(-0.1, 0.1)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems with probability refinement.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "0f48a4f0-9621-4a4b-811b-3e65f7588598", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\n                # Refine strategy with probability 0.3\n                if random.random() < self.refine_prob:\n                    # Randomly select two particles\n                    i, j = random.sample(range(self.dim), 2)\n                    # Swap their positions\n                    x[i], x[j] = x[j], x[i]\n                    # Update their fitness\n                    f = func(x)\n                    if f < self.f_best:\n                        self.x_best[_] = x\n                        self.f_best = f\n                        self.pbest[_] = x\n                        if f < self.f:\n                            self.f = f\n                            self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
{"id": "60a01ab3-014c-4c7f-b278-87b4c98a85e4", "solution": "import numpy as np\nimport random\n\nclass SwarmPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.x_best = np.zeros((budget, dim))\n        self.f_best = np.inf\n        self.pbest = np.zeros((budget, dim))\n        self.gbest = np.zeros(dim)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.f = 0.5\n        self.perturb_prob = 0.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Initialize particles\n            x = np.random.uniform(-5.0, 5.0, (self.dim,))\n            self.x_best[_] = x\n            self.f_best = func(x)\n            self.pbest[_] = x\n            self.gbest = x\n\n            # Update gbest\n            if self.f_best < self.f:\n                self.f = self.f_best\n                self.gbest = self.x_best[_]\n\n            # Update particles\n            for _ in range(100):\n                r1 = random.random()\n                r2 = random.random()\n                v = np.zeros(self.dim)\n                v += self.c1 * r1 * (self.gbest - self.x_best[_])\n                v += self.c2 * r2 * (self.pbest[_] - self.x_best[_])\n                v = v * self.f\n                x += v\n                x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                # Perturb with probability 0.3\n                if random.random() < self.perturb_prob:\n                    x += np.random.uniform(-0.1, 0.1, self.dim)\n                    x = np.clip(x, -5.0, 5.0)  # Clip to bounds\n\n                f = func(x)\n                if f < self.f_best:\n                    self.x_best[_] = x\n                    self.f_best = f\n                    self.pbest[_] = x\n                    if f < self.f:\n                        self.f = f\n                        self.gbest = x\n\ndef evaluate(func, x):\n    return func(x)\n\ndef bbb_test_suite(funcs):\n    results = {}\n    for func in funcs:\n        results[func.__name__] = []\n        for _ in range(10):\n            x = np.random.uniform(-5.0, 5.0, (100,))\n            f = func(x)\n            results[func.__name__].append(f)\n    return results\n\n# Example usage:\nfuncs = [evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate, evaluate]\nresults = bbb_test_suite(funcs)\nfor func_name, results in results.items():\n    print(f\"Function: {func_name}\")\n    print(f\"Mean: {np.mean(results)}\")\n    print(f\"Median: {np.median(results)}\")\n    print(f\"Standard Deviation: {np.std(results)}\")\n    print()\n\n# Note: The above code uses the same Swarm-PSO-DE algorithm as the original code.\n# However, the perturbation step has been added with a probability of 0.3 to refine the strategy.", "name": "SwarmPSODE", "description": "Novel \"Swarm-PSO-DE\" algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to handle black box optimization problems.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"evaluate() missing 1 required positional argument: 'x'\").", "error": "TypeError(\"evaluate() missing 1 required positional argument: 'x'\")", "parent_id": "8e2e1db3-2396-49e1-af51-600b7b0ae39d", "metadata": {}, "mutation_prompt": null}
