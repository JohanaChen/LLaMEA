{"id": "631094d8-404b-46bd-a139-fae59f8acab0", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 56, in <module>\n  File \"<string>\", line 38, in __call__\nValueError: too many values to unpack (expected 2)\n.", "error": "ValueError('too many values to unpack (expected 2)')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 56, in <module>\n  File \"<string>\", line 38, in __call__\nValueError: too many values to unpack (expected 2)\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "48a87c36-5aae-4d48-ac2a-1f029109b2e3", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_prob:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "2cf01db1-131c-4fdd-aef8-1fa29c273f53", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "2a9740b6-2f95-4a37-a428-4c8a8b91405a", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    # Apply probabilistic mutation\n                    if np.random.rand() < self.mutation_probability:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach and probabilistic mutation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "fc4fac95-cd87-4eca-8023-fae7b43f5ae7", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryDrift:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.refinement_prob = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply evolutionary drift\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Introduce mutation with adaptive rate\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_rate:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        child = offspring[i] + mutation\n                        child = np.clip(child, -5.0, 5.0)\n                        offspring[i] = child\n\n                # Refine selected individuals with probabilistic mutation\n                refined_offspring = []\n                for i in range(self.population_size):\n                    if random.random() < self.refinement_prob:\n                        mutation = np.random.uniform(-1.0, 1.0, self.dim)\n                        child = offspring[i] + mutation\n                        child = np.clip(child, -5.0, 5.0)\n                        refined_offspring.append(child)\n                    else:\n                        refined_offspring.append(offspring[i])\n\n                # Update population\n                offspring = np.array(refined_offspring)\n\n            # Update mutation rate\n            self.mutation_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nevolutionary_drift = EvolutionaryDrift(budget=100, dim=10)\nbest_solution = evolutionary_drift(func)\nprint(best_solution)", "name": "EvolutionaryDrift", "description": "Novel \"Evolutionary Drift\" algorithm with adaptive mutation rate and probabilistic refinement.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "6813fc63-cac2-4de6-83c2-3068f0bb9c65", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation and crossover.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "e5b401a0-003e-4830-9c3a-6633ae0e48af", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Probabilistic mutation\n                    if random.random() < self.mutation_prob:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach and probabilistic mutation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "2d99b6f0-fcc5-425b-84c9-887c8bc0cb69", "solution": "import numpy as np\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    # Apply probability-based mutation\n                    if np.random.rand() < 0.3:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probability-based mutation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "eee5db22-4c1b-4494-bdf9-28acd67f9563", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "d76667c5-de18-40e0-bdb8-030f39cf4be4", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    if random.random() < self.mutation_prob:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation refinement.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "f676dab6-caf5-4fdc-9785-c4bc5a48a4ea", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine individual lines with probability 0.3\n                refine_indices = np.random.choice(range(self.population_size), size=self.population_size, p=0.3)\n                refined_population = np.copy(population)\n                for i in refine_indices:\n                    refined_population[i] = self.refine_individual(refined_population[i])\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n    def refine_individual(self, individual):\n        # Select 30% of individual lines to refine\n        refine_indices = np.random.choice(range(self.dim), size=int(0.3 * self.dim), replace=False)\n        refined_individual = individual.copy()\n        for i in refine_indices:\n            # Randomly replace a line with a new value between -5.0 and 5.0\n            refined_individual[i] = np.random.uniform(-5.0, 5.0)\n        return refined_individual\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "1b4576f2-4bce-4c0d-959a-9990ddef0f9d", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "ec93152d-4621-446b-8332-a38f1980e25a", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability\n            if np.random.rand() < self.refinement_probability:\n                parent = population[np.random.choice(range(self.population_size))]\n                child = (parent + self.best_solution) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                child = np.clip(child, -5.0, 5.0)\n                if func(child) < func(self.best_solution):\n                    self.best_solution = child\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "6e9e9018-fe19-40ba-97b0-4dc0440e7108", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine the best solution with probability 0.3\n                if np.random.rand() < self.refine_probability:\n                    best_solution = population[np.argmin(fitness)]\n                    best_solution = best_solution + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    best_solution = np.clip(best_solution, -5.0, 5.0)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "8f24cd15-f3cd-4f1d-8865-177768a5e8aa", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Apply probability-based mutation\n                    if random.random() < self.mutation_probability:\n                        mutation = np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = child + mutation\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "7de06e28-37cf-46c4-a4cb-25dbdb99c4af", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine individual lines with 30% probability\n                refine_indices = np.random.choice(range(self.population_size), size=int(self.population_size * self.refine_probability), replace=False)\n                for i in refine_indices:\n                    individual = population[i]\n                    # Select random lines to change\n                    lines_to_change = np.random.choice(self.dim, size=int(self.dim * self.refine_probability), replace=False)\n                    for line in lines_to_change:\n                        # Change the value of the selected line\n                        individual[line] += np.random.uniform(-1, 1)\n                        individual[line] = np.clip(individual[line], -5.0, 5.0)\n\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "95f5b9ec-bb6a-422e-8904-68ac20fada18", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation with probability\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    if random.random() < 0.3:\n                        child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    else:\n                        child = parent1 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "daf0ca00-88fa-4368-b16b-75d17aa52ec6", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    # Apply probability-based mutation\n                    if np.random.rand() < 0.3:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "dd05797f-509a-4528-8496-a4db48f955e3", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.change_probability = 0.03\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Change 3% of individual lines with a new random solution\n                if random.random() < self.change_probability:\n                    index = np.random.randint(0, self.population_size)\n                    population[index] = np.random.uniform(-5.0, 5.0, self.dim)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach and 3% probability to change individual lines.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "095cb563-4fd3-4989-8416-41cf6df12c43", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.prob_refine = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Refine solutions with probability\n                refine_indices = np.random.choice(range(self.population_size), size=int(self.population_size * self.prob_refine), replace=False)\n                refined_offspring = []\n                for i in range(self.population_size):\n                    if i in refine_indices:\n                        parent1, parent2 = parents[np.random.choice(range(2))]\n                        child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n                        refined_offspring.append(child)\n                    else:\n                        refined_offspring.append(offspring[i])\n\n                # Update population\n                population = np.array(refined_offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "1e9bf57c-7150-414a-a30d-fb8fa2e93b88", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine solutions with probability 0.3\n                if np.random.rand() < self.refine_probability:\n                    for i in range(self.population_size):\n                        if np.random.rand() < 0.5:\n                            population[i] = population[i] * (1 + np.random.uniform(-0.1, 0.1, self.dim))\n                        if np.random.rand() < 0.5:\n                            population[i] = population[i] * (1 - np.random.uniform(-0.1, 0.1, self.dim))\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "40edf8d2-30b6-49b6-a02c-8c22cc0d10f0", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for i in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5\n                    if np.random.rand() < self.mutation_prob:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, refined with probabilistic mutation.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "2155e640-67b2-452e-9440-8516c7a603f0", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Apply mutation with probability\n                    if random.random() < self.mutation_probability:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "741ce5c1-503e-402a-92f4-59c02af6741d", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    if random.random() < 0.3:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation and refinement.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "67cac23b-2361-4e41-bac7-4d685a32e48b", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Probability-based mutation\n                    if random.random() < 0.3:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "dcf24dc4-84ec-41fc-ab71-e25d1fc872c7", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability 0.3\n            if random.random() < self.refine_prob:\n                self.best_solution = self.refine(self.best_solution, func)\n\n        return self.best_solution\n\n    def refine(self, individual, func):\n        # Refine the individual by perturbing it with probability 0.3\n        if random.random() < self.refine_prob:\n            # Perturb the individual by adding a random value between -1 and 1\n            perturbation = np.random.uniform(-1, 1, self.dim)\n            individual = individual + perturbation\n            individual = np.clip(individual, -5.0, 5.0)\n        return individual\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach and probabilistic refinement.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "a3f8e6a6-f4f4-46ca-acf4-6dcea2f8cb4b", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability 0.3\n            if random.random() < 0.3:\n                new_individual = self.best_solution\n                for _ in range(int(self.budget * 0.3)):\n                    # Randomly change one dimension of the individual\n                    idx = np.random.randint(0, self.dim)\n                    new_individual[idx] += np.random.uniform(-0.1, 0.1)\n                    new_individual = np.clip(new_individual, -5.0, 5.0)\n                self.best_solution = new_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "7d95951f-9ae0-4885-9cf4-b2770d5dc113", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine solution with probability 0.3\n            if np.random.rand() < self.refinement_probability:\n                # Randomly select an individual from the population\n                individual = population[np.random.choice(range(self.population_size))]\n                # Refine its parameters by adding a small random perturbation\n                refined_individual = individual + np.random.uniform(-0.1, 0.1, self.dim)\n                refined_individual = np.clip(refined_individual, -5.0, 5.0)\n                # Replace the individual with the refined one\n                population[np.random.choice(range(self.population_size))] = refined_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "0a052ee4-4b66-42ff-a2d8-63291c5f3189", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    # Refine strategy with 30% probability\n                    if random.random() < 0.3:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with mutation strategy refinement.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "9b26131f-cd3d-4f05-beae-abad11af7dbd", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best individual with a probability of 0.3\n            if random.random() < self.refinement_probability:\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        self.best_solution[i] += np.random.uniform(-0.1, 0.1)\n                    self.best_solution[i] = np.clip(self.best_solution[i], -5.0, 5.0)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probabilistic refinement of the best individual.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "29dbe65e-5a16-45a8-af4e-1553460b3811", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability 0.3\n            if random.random() < self.refine_prob:\n                new_individual = self.best_solution.copy()\n                new_individual += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                new_individual = np.clip(new_individual, -5.0, 5.0)\n                if func(new_individual) < func(self.best_solution):\n                    self.best_solution = new_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probabilistic refinement.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "da1a8948-b209-4bfb-89b6-463e6b9cec15", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_probability = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply evolutionary annealing evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.temperature, self.temperature, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child = child + np.random.uniform(-1.0, 1.0, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Update temperature\n                self.temperature *= self.cooling_rate\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nevolutionary_annealing = EvolutionaryAnnealing(budget=100, dim=10)\nbest_solution = evolutionary_annealing(func)\nprint(best_solution)", "name": "EvolutionaryAnnealing", "description": "Novel \"Evolutionary Annealing\" algorithm with adaptive temperature schedule and probability-based mutation.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "8607b7b6-c4e1-4791-99b8-813ca05ef087", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if random.random() < self.mutation_prob:\n                        child += np.random.uniform(-0.5, 0.5, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "0a9e1976-9a06-4150-91dd-11a974c701a9", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Apply probability-based mutation\n                    if random.random() < self.mutation_probability:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "21837fa0-385c-43d0-b3a8-626a63a1b223", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine best solution with probability\n            if random.random() < self.refinement_probability:\n                # Refine best solution by perturbing its coordinates\n                best_solution = self.best_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                best_solution = np.clip(best_solution, -5.0, 5.0)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "5afbea7c-1cd6-46bc-8da0-97c573c9a23e", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Probabilistic refinement\n            refinement_rate = 0.3\n            for _ in range(int(self.budget * refinement_rate)):\n                # Randomly select an individual\n                individual = population[np.random.choice(range(self.population_size))]\n\n                # Refine the individual by changing 30% of its lines\n                refined_individual = individual.copy()\n                for i in range(self.dim):\n                    if np.random.rand() < refinement_rate:\n                        refined_individual[i] = individual[i] + np.random.uniform(-0.1, 0.1)\n\n                # Ensure the refined individual is within the bounds\n                refined_individual = np.clip(refined_individual, -5.0, 5.0)\n\n                # Evaluate the refined individual\n                refined_fitness = func(refined_individual)\n\n                # Replace the original individual with the refined one if it has better fitness\n                if refined_fitness < fitness[np.argmin(fitness)]:\n                    population[np.argmin(fitness)] = refined_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probabilistic refinement.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "23e95400-bd11-49cc-87e6-dc4fc58af45a", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probabilistic mutation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "947eeb7c-b359-4dac-a5b5-62773557c6d8", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine strategy with probability\n            if random.random() < self.refine_probability:\n                # Randomly select an individual from the population\n                individual = population[np.random.choice(range(self.population_size))]\n\n                # Refine its strategy by changing one line of its code\n                # This is done by replacing a random element in the individual's code with a random value\n                individual_code = str(individual).replace('[', '').replace(']', '').replace(',', '').replace('(', '').replace(')', '')\n                individual_code = individual_code[:random.randint(0, len(individual_code)-1)] + str(random.randint(-5.0, 5.0)) + individual_code[random.randint(len(individual_code)-1, len(individual_code)-1)]\n                individual = eval(individual_code)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "16c90691-930a-4a54-b816-d001b9f490a5", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    # Apply probability-based mutation\n                    if np.random.rand() < 0.3:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach and probability-based mutation.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "cb9ee1a9-fe23-4ad0-9f1b-5e5664042910", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for i in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5\n                    mutation = np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child += mutation\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "c86d786e-61c8-4694-bf0a-77e37bdb0180", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if random.random() < self.probability:\n                        child += np.random.uniform(-self.sphere_radius * 2, self.sphere_radius * 2, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probabilistic mutation.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "5654534a-2d67-4722-a589-d62da4108350", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine best solution with probability\n            if np.random.rand() < self.refine_probability:\n                new_solution = self.best_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                new_solution = np.clip(new_solution, -5.0, 5.0)\n                if func(new_solution) < self.best_fitness:\n                    self.best_solution = new_solution\n                    self.best_fitness = func(new_solution)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "22f489a2-0586-4e8e-93dc-1935162e62b4", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    # Refine the solution with a probability of 0.3\n                    if random.random() < self.probability:\n                        child = child + random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "20655d33-3de7-41f1-ac8f-1b00c953abcd", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability 0.3\n            if random.random() < self.refine_probability:\n                # Generate new solutions by perturbing the best solution\n                new_solutions = []\n                for _ in range(10):\n                    new_solution = self.best_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                    new_solution = np.clip(new_solution, -5.0, 5.0)\n                    new_solutions.append(new_solution)\n\n                # Evaluate the new solutions\n                new_fitness = [func(x) for x in new_solutions]\n\n                # Update the best solution if necessary\n                if min(new_fitness) < self.best_fitness:\n                    self.best_solution = new_solutions[np.argmin(new_fitness)]\n                    self.best_fitness = min(new_fitness)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probabilistic refinement.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "440fa1fe-309a-4042-bc88-15f3aa42e891", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        # Refine the best solution using probability-based refinement\n        if self.best_solution is not None:\n            refined_solution = self.best_solution.copy()\n            for _ in range(int(self.budget * 0.3)):\n                axis = np.random.randint(self.dim)\n                step = np.random.uniform(-1.0, 1.0)\n                refined_solution[axis] += step\n                refined_solution = np.clip(refined_solution, -5.0, 5.0)\n            self.best_solution = refined_solution\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "8e5809d7-2cc3-4ebf-be45-e98fc636404b", "solution": "import numpy as np\nimport random\nimport time\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Update learning rate\n                self.learning_rate *= 0.9\n\n                # Line search to refine solution\n                for _ in range(int(self.population_size * 0.3)):\n                    # Generate new individual\n                    new_individual = population[np.random.choice(range(self.population_size))]\n\n                    # Evaluate fitness\n                    new_fitness = func(new_individual)\n\n                    # If fitness is better, update solution\n                    if new_fitness < self.best_fitness:\n                        self.best_solution = new_individual\n                        self.best_fitness = new_fitness\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and line search to optimize black box functions.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "4af8b206-d64b-42f9-80fe-80f70215602d", "solution": "import numpy as np\n\nclass AdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.refinement_probability = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply adaptive swarm evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine the solution with probabilistic refinement\n                if np.random.rand() < self.refinement_probability:\n                    new_individual = population[np.random.choice(range(self.population_size))]\n                    new_individual = new_individual + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    new_individual = np.clip(new_individual, -5.0, 5.0)\n                    population[np.random.choice(range(self.population_size))] = new_individual\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nadaptive_swarm = AdaptiveSwarm(budget=100, dim=10)\nbest_solution = adaptive_swarm(func)\nprint(best_solution)", "name": "AdaptiveSwarm", "description": "Novel \"Adaptive Swarm\" algorithm with adaptive learning rate and probabilistic refinement.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "2a184599-948d-4205-93e7-b49bec6f8af7", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability 0.3\n            if random.random() < self.refine_probability:\n                parent = population[np.random.choice(range(self.population_size))]\n                child = parent + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                child = np.clip(child, -5.0, 5.0)\n                if func(child) < func(parent):\n                    population[np.argmin(fitness)] = child\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probability-based refinement.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "c13f5eaa-a71c-4b97-a663-c4262bae6907", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability\n            if np.random.rand() < self.refine_probability:\n                best_solution = self.best_solution\n                for i in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        best_solution[i] += np.random.uniform(-0.1, 0.1)\n                        best_solution = np.clip(best_solution, -5.0, 5.0)\n\n                self.best_solution = best_solution\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "ee53f6d9-1334-4132-8703-9f53b2824307", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine individual solutions with probability 0.3\n            refine_prob = 0.3\n            refined_population = population.copy()\n            for i in range(self.population_size):\n                if random.random() < refine_prob:\n                    # Refine solution by changing one dimension randomly\n                    refined_solution = refined_population[i].copy()\n                    dimension = np.random.choice(self.dim)\n                    refined_solution[dimension] += np.random.uniform(-1.0, 1.0)\n                    refined_solution = np.clip(refined_solution, -5.0, 5.0)\n                    refined_population[i] = refined_solution\n\n            # Update population with refined solutions\n            population = refined_population\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "8ccd07a4-5305-41f0-be43-31f7a7decad6", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    if random.random() < 0.3:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation refinement.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "31738633-e82c-44d1-94a9-0cae3657db84", "solution": "import numpy as np\n\nclass EvolutionaryTreeOfLife:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.tree_depth = 5\n        self.mutation_probability = 0.1\n        self.crossover_probability = 0.7\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply evolutionary tree of life evolution\n            for _ in range(self.tree_depth):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    if np.random.rand() < self.crossover_probability:\n                        child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.tree_depth, self.tree_depth, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n                    else:\n                        child = parent1 + np.random.uniform(-self.tree_depth, self.tree_depth, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n                    if np.random.rand() < self.mutation_probability:\n                        child = child + np.random.uniform(-self.tree_depth, self.tree_depth, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nevolution_tree = EvolutionaryTreeOfLife(budget=100, dim=10)\nbest_solution = evolution_tree(func)\nprint(best_solution)", "name": "EvolutionaryTreeOfLife", "description": "Novel \"Evolutionary Tree of Life\" algorithm with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "f31c1e59-7d21-4199-b905-e26df421ec7c", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_refine_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for i in range(self.population_size):\n                    if random.random() < self.mutation_refine_prob:\n                        # Refine individual using probability-based mutation\n                        parent1, parent2 = parents[np.random.choice(range(2))]\n                        child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n                        offspring.append(child)\n                    else:\n                        # Regular mutation\n                        child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n                        offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation refinement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"cannot access local variable 'parent1' where it is not associated with a value\").", "error": "UnboundLocalError(\"cannot access local variable 'parent1' where it is not associated with a value\")", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "edcdb03c-aee4-4eb1-b037-7533628404f7", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if random.random() < self.mutation_prob:\n                        child = child + np.random.uniform(-self.sphere_radius * 0.1, self.sphere_radius * 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "045727f4-4bb7-4817-bce2-f421662f1b2e", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for i in range(self.population_size):\n                    # Refine solution with 30% probability\n                    if random.random() < self.refine_probability:\n                        parent1, parent2 = parents[np.random.choice(range(2))]\n                        child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n                    else:\n                        child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "fc40c233-c27a-4be0-9751-14cc32c6d4a9", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the strategy by changing individual lines with probability 0.3\n            if random.random() < 0.3:\n                for i in range(self.population_size):\n                    for j in range(self.dim):\n                        if random.random() < 0.3:\n                            population[i, j] += random.uniform(-0.1, 0.1)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "59cdfbc5-70f5-49fe-b9e3-de138f5d0334", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    # Apply probability-based mutation\n                    if random.random() < 0.3:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "613ccf77-d2df-4a94-9363-979ad2e39085", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryLandscape:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.exploration_rate = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.current_solution = np.random.uniform(-5.0, 5.0, self.dim)\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply evolutionary landscape evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5\n                    # Introduce exploration-exploitation trade-off\n                    if np.random.rand() < self.exploration_rate:\n                        child += np.random.uniform(-self.mutation_rate, self.mutation_rate, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Update current solution\n                self.current_solution = (self.current_solution + population[np.random.choice(range(self.population_size))]) / 2\n                self.current_solution = np.clip(self.current_solution, -5.0, 5.0)\n\n            # Update learning rate\n            self.mutation_rate *= 0.9\n\n        # Refine current solution\n        if np.random.rand() < self.exploration_rate:\n            self.current_solution += np.random.uniform(-self.mutation_rate, self.mutation_rate, self.dim)\n            self.current_solution = np.clip(self.current_solution, -5.0, 5.0)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nevolution = EvolutionaryLandscape(budget=100, dim=10)\nbest_solution = evolution(func)\nprint(best_solution)", "name": "EvolutionaryLandscape", "description": "Novel \"Evolutionary Landscape\" algorithm with adaptive mutation and exploration-exploitation trade-off.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "b47fd26f-1b8b-49bd-a87b-fa5706484750", "solution": "import numpy as np\nimport random\n\nclass EvolutionaryTree:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.tree_depth = 5\n        self.refine_probability = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply evolutionary tree evolution\n            for _ in range(self.tree_depth):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-0.5, 0.5, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Refine the best solution with probabilistic refinement\n            if np.random.rand() < self.refine_probability:\n                new_individual = population[np.random.choice(range(self.population_size))]\n                new_fitness = func(new_individual)\n                if new_fitness < self.best_fitness:\n                    self.best_solution = new_individual\n                    self.best_fitness = new_fitness\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nevolutionary_tree = EvolutionaryTree(budget=100, dim=10)\nbest_solution = evolutionary_tree(func)\nprint(best_solution)", "name": "EvolutionaryTree", "description": "Novel \"Evolutionary Tree\" algorithm with adaptive branching and probabilistic refinement.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "d6e66cb3-a3e7-41fc-9687-6222593f0027", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach and probabilistic mutation.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "03596ace-d3af-4441-83b2-ab906374b95a", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability\n            if random.random() < self.refine_prob:\n                # Refine the best solution by perturbing its coordinates\n                best_solution = self.best_solution\n                for i in range(self.dim):\n                    if random.random() < 0.5:\n                        best_solution[i] += np.random.uniform(-0.1, 0.1)\n                        best_solution[i] = np.clip(best_solution[i], -5.0, 5.0)\n\n                # Update the best solution\n                if func(best_solution) < self.best_fitness:\n                    self.best_solution = best_solution\n                    self.best_fitness = func(best_solution)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, incorporating probability-based refinement.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "742dc726-a3e4-43f9-a950-679dbc154160", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability\n            if random.random() < self.refine_probability:\n                new_solution = self.best_solution + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                new_solution = np.clip(new_solution, -5.0, 5.0)\n                if func(new_solution) < self.best_fitness:\n                    self.best_solution = new_solution\n                    self.best_fitness = func(new_solution)\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "3bc830f0-02c7-4f65-8857-c8d2fe4c935f", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine solutions with probability 0.3\n            if random.random() < self.refine_probability:\n                for i in range(self.population_size):\n                    # Refine the individual lines\n                    individual = population[i]\n                    refined_individual = individual + np.random.uniform(-0.1, 0.1, self.dim)\n                    refined_individual = np.clip(refined_individual, -5.0, 5.0)\n                    population[i] = refined_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probabilistic refinement.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "2f082b11-4262-472c-9605-3ab5b9b83323", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    # Apply mutation with probability\n                    if random.random() < self.mutation_probability:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "f4f446bf-f93a-4474-bfb4-cf62a52c5362", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "a0b319bd-def0-4caa-af69-1923ff26a4c8", "solution": "import numpy as np\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Apply probability-based mutation\n                    if np.random.rand() < self.mutation_prob:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child = np.clip(child, -5.0, 5.0)\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probability-based mutation.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "f9939d3b-b9bd-4aef-b897-03126df28496", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for i in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    if random.random() < self.line_mutation_probability:\n                        # Line mutation\n                        line_indices = np.random.choice(self.dim, size=2, replace=False)\n                        child[line_indices[0]] += np.random.uniform(-0.1, 0.1)\n                        child[line_indices[1]] += np.random.uniform(-0.1, 0.1)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with 30% probability of line mutation.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "cc697ef2-766e-4333-adca-d441cc9b6661", "solution": "import numpy as np\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Apply probability-based mutation\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child += mutation\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "690ed4c9-054b-4d7b-b45f-ca001f606a2a", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability\n            if np.random.rand() < self.refine_probability:\n                # Randomly select 30% of the best solution's lines to change\n                change_indices = np.random.choice(self.dim, int(self.dim * self.refine_probability), replace=False)\n                new_solution = self.best_solution.copy()\n                for index in change_indices:\n                    new_solution[index] = np.random.uniform(-5.0, 5.0)\n                new_fitness = func(new_solution)\n                if new_fitness < self.best_fitness:\n                    self.best_solution = new_solution\n                    self.best_fitness = new_fitness\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "f246b150-6727-4efe-861c-f296e78ba464", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "7989a8e2-09c8-444d-b55d-600b248ad2ee", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    if random.random() < 0.3:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation.", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "de52a430-82ed-4186-bfe9-da0c034f70d1", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for i in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "48f28faf-8573-4e03-abf6-2036f59907ab", "solution": "import numpy as np\nimport random\n\nclass AdaptiveSwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with a probability of 0.3\n            if random.random() < self.refine_probability:\n                for i in range(self.population_size):\n                    # Change the individual lines of the best solution with a probability of 0.3\n                    if random.random() < self.refine_probability:\n                        child = (self.best_solution[i] + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim))\n                        child = np.clip(child, -5.0, 5.0)\n                        self.best_solution[i] = child\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nadaptive_swarm = AdaptiveSwarmOfSpheres(budget=100, dim=10)\nbest_solution = adaptive_swarm(func)\nprint(best_solution)", "name": "AdaptiveSwarmOfSpheres", "description": "Novel \"Adaptive Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "dca4a338-691f-4df8-a1df-50b0216dbf2f", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    # Apply mutation with probability\n                    if np.random.rand() < self.mutation_probability:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "36be7439-2aa6-4426-bed7-e706a3b8ee1a", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine solutions with probability\n                if np.random.rand() < self.refinement_probability:\n                    refined_population = []\n                    for individual in population:\n                        if np.random.rand() < 0.5:\n                            refined_individual = individual + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                            refined_population.append(np.clip(refined_individual, -5.0, 5.0))\n                        else:\n                            refined_population.append(individual)\n                    population = np.array(refined_population)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "0e1ebfcf-9ff6-4ccb-92f1-298a2d766ec7", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine solution with probability\n            if random.random() < self.refine_probability:\n                # Select best solution to refine\n                best_solution = self.best_solution\n                # Refine solution by perturbing its coordinates\n                refined_solution = best_solution + np.random.uniform(-0.1, 0.1, self.dim)\n                refined_solution = np.clip(refined_solution, -5.0, 5.0)\n                # Evaluate refined solution\n                refined_fitness = func(refined_solution)\n                # Update best solution if refined solution is better\n                if refined_fitness < self.best_fitness:\n                    self.best_solution = refined_solution\n                    self.best_fitness = refined_fitness\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "8cce3501-c575-4022-ba71-d9e2af36dbfa", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine individual lines with probability 0.3\n                if random.random() < self.refine_probability:\n                    for i in range(self.population_size):\n                        # Randomly select two lines to change\n                        line1, line2 = np.random.choice(range(self.population_size)), np.random.choice(range(self.population_size))\n                        # Change the line with the higher fitness\n                        if fitness[line1] > fitness[line2]:\n                            population[i] = (population[line1] + population[line2]) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                            population[line1] = np.clip(population[i], -5.0, 5.0)\n                            population[line2] = np.clip(population[i], -5.0, 5.0)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, refined with probability 0.3 to change individual lines.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "686806f3-a3c2-4e2d-a901-0b6fb9f844e0", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if np.random.rand() < self.mutation_probability:\n                        child = child + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based mutation refinement.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "9ce85611-cf92-416a-9e5d-ae9c35d96bf1", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine solutions with probability 0.3\n                refine_probability = 0.3\n                refine_indices = np.random.choice(range(self.population_size), size=int(self.population_size * refine_probability), replace=False)\n                refined_population = np.copy(population)\n                for i in refine_indices:\n                    refined_population[i] = self.refine_solution(refined_population[i])\n                population = refined_population\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n    def refine_solution(self, solution):\n        # Refine solution by changing one dimension with probability 0.3\n        if np.random.rand() < 0.3:\n            dimension = np.random.choice(range(self.dim))\n            new_value = solution[dimension] + np.random.uniform(-1.0, 1.0)\n            return np.copy(solution)\n        else:\n            return solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "42b6aa64-4a51-4959-879f-86cc1b90d1e4", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.03\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine strategy with 3% probability\n                if random.random() < self.refine_probability:\n                    for i in range(self.population_size):\n                        # Randomly select two parents\n                        parent1, parent2 = parents[np.random.choice(range(2))]\n\n                        # Calculate the weighted average of the two parents\n                        child = (parent1 + parent2) * 0.5\n\n                        # Randomly adjust the child by a small amount\n                        adjustment = np.random.uniform(-0.1, 0.1, self.dim)\n                        child += adjustment\n\n                        # Clip the child to the search space\n                        child = np.clip(child, -5.0, 5.0)\n\n                        # Replace the original child with the refined child\n                        population[i] = child\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach and 3% probability to refine the strategy.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "a4fcdf2b-eb6a-4dd7-bf63-6c2644d439eb", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n\n                    # Apply probability-based mutation\n                    if np.random.rand() < self.mutation_prob:\n                        mutation = np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                        child += mutation\n\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach and probability-based mutation.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "d94d6df4-eb89-4364-9be5-fbf8fdbcbbf5", "solution": "import numpy as np\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    if np.random.rand() < 0.3:\n                        child += np.random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probabilistic mutation.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "204415ec-02d5-491b-97e1-8b809a09e8f3", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    # Probabilistic mutation refinement\n                    if random.random() < 0.3:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probabilistic mutation refinement.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "09a8b921-12b7-4699-8211-886627f240d5", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)\n\n# Description: Novel \"Evolutionary HyperNetwork\" algorithm with adaptive mutation and hyperparameter tuning.\n# Code: \n# ```python\nimport numpy as np\nimport random\n\nclass EvolutionaryHyperNetwork:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.hyperparameter_size = 5\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply evolutionary hypernetwork evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.mutation_rate, self.mutation_rate, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Hyperparameter tuning\n                hyperparameters = np.random.uniform(-1.0, 1.0, (self.hyperparameter_size,))\n                population = population * (1 + hyperparameters)\n\n            # Update mutation rate\n            self.mutation_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nevolutionary_hypernetwork = EvolutionaryHyperNetwork(budget=100, dim=10)\nbest_solution = evolutionary_hypernetwork(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "ab2318ee-2300-4a54-854c-2187d0e7bddd", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine individual lines with 0.3 probability\n                refine_indices = np.random.choice(range(self.population_size), size=int(self.population_size * self.refine_probability), replace=False)\n                for i in refine_indices:\n                    line_indices = np.random.choice(range(self.dim), size=2, replace=False)\n                    parent1, parent2 = offspring[i, line_indices]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim[line_indices])\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring[i, line_indices] = child\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with 0.3 probability to refine individual lines.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "9ea4b6fc-4745-4dd6-a5f3-ed3f5b4cb04a", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine solution with probability\n            if random.random() < 0.3:\n                # Select a random solution from the population\n                new_individual = population[np.random.choice(range(self.population_size))]\n                # Refine the solution by adding a small mutation\n                new_individual = new_individual + np.random.uniform(-0.1, 0.1, self.dim)\n                new_individual = np.clip(new_individual, -5.0, 5.0)\n                # Replace the original solution with the refined one\n                self.best_solution = new_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, combined with probability-based refinement.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "4e9e2455-9344-46a8-82f2-43873de19ffc", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.prob_refine = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine the best individual with probability\n                if np.random.rand() < self.prob_refine:\n                    # Select the best individual\n                    best_individual = population[np.argmin(fitness)]\n\n                    # Refine the best individual by adding a small mutation\n                    refined_individual = best_individual + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    refined_individual = np.clip(refined_individual, -5.0, 5.0)\n\n                    # Replace the best individual with the refined individual\n                    population[np.argmin(fitness)] = refined_individual\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "d62f6549-5966-4266-8dd6-8d14d98a2483", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    # Refine individual lines with probability 0.3\n                    if random.random() < self.mutation_prob:\n                        child = child + np.random.uniform(-0.5, 0.5, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "6e749148-9520-4393-8b3d-c8e72b913793", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n                # Refine individual lines with 0.3 probability\n                refine_indices = np.random.choice(range(self.population_size), size=int(self.population_size * self.refine_probability), replace=False)\n                for index in refine_indices:\n                    new_individual = population[index]\n                    new_individual = (new_individual + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    new_individual = np.clip(new_individual, -5.0, 5.0)\n                    population[index] = new_individual\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach, refined with 0.3 probability to change individual lines.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "f40a1954-2716-41b3-97c9-7c3c68f928d0", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    # Refine individual lines with probability 0.3\n                    if random.random() < self.probability:\n                        child = child * (1 + random.uniform(-1, 1))\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "b80a7e13-669c-4910-be42-8ee80befec94", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine solution with probability\n            if random.random() < self.refinement_probability:\n                # Select a random solution from the population\n                new_individual = population[np.random.choice(range(self.population_size))]\n\n                # Refine the solution by changing one dimension randomly\n                index = np.random.randint(0, self.dim)\n                new_individual[index] += np.random.uniform(-0.1, 0.1)\n\n                # Ensure the new solution is within the bounds\n                new_individual = np.clip(new_individual, -5.0, 5.0)\n\n                # Evaluate the fitness of the new solution\n                new_fitness = func(new_individual)\n\n                # If the new solution is better, update the best solution\n                if new_fitness < self.best_fitness:\n                    self.best_solution = new_individual\n                    self.best_fitness = new_fitness\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "d24aac7e-ba17-4108-b5eb-300c601688c4", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if random.random() < self.mutation_probability:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "4bb01ed8-a750-49b6-9f0d-de17330a8623", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Probabilistic refinement\n            refinement = np.random.rand(self.population_size, self.dim) < 0.3\n            population[refinement] = population[refinement] * 1.1 + np.random.uniform(-self.sphere_radius, self.sphere_radius, (self.population_size, self.dim))\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probabilistic refinement.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "fa466621-5f46-4a85-b2fd-fdcc15c396d2", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    if random.random() < self.mutation_prob:\n                        child = child + np.random.uniform(-0.1, 0.1, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based mutation.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "6b5d9574-4469-418f-bd21-9e0f905ea56e", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "bce69e58-7dd1-4fb5-9a02-ade7653ffe87", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine strategy with probability\n            refine = np.random.rand(self.population_size) < 0.3\n            if refine.any():\n                # Select random individuals to refine\n                to_refine = np.random.choice(self.population_size, size=np.sum(refine), replace=False)\n\n                # Refine selected individuals\n                for i in to_refine:\n                    # Select parent using tournament selection\n                    parent = population[np.random.choice(range(self.population_size)), :]\n\n                    # Apply mutation\n                    mutation = np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    new_individual = parent + mutation\n                    new_individual = np.clip(new_individual, -5.0, 5.0)\n\n                    # Replace original individual with new one\n                    population[i] = new_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probability-based refinement.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "1390298e-3375-4789-b876-d7e1d2589136", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine individual lines with 30% probability\n            refine = np.random.rand(self.population_size) < self.refine_probability\n            for i in range(self.population_size) if refine[i] else continue:\n                # Select parent using tournament selection\n                parent = population[np.random.choice(range(self.population_size))]\n\n                # Apply crossover\n                child = parent + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                child = np.clip(child, -5.0, 5.0)\n\n                # Update individual\n                population[i] = child\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach and 30% probability to refine individual lines.", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 52, 68, '            for i in range(self.population_size) if refine[i] else continue:\\n', 52, 76)).", "error": "SyntaxError('invalid syntax', ('<string>', 52, 68, '            for i in range(self.population_size) if refine[i] else continue:\\n', 52, 76))", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "6e1e0c1f-2e7f-404e-b82c-1005e37b778e", "solution": "import numpy as np\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.refinement_probability = 0.3\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n            # Refine the best solution with probability 0.3\n            if np.random.rand() < self.refinement_probability:\n                refinement_candidates = [population[np.random.choice(range(self.population_size)), :] for _ in range(10)]\n                refinement_candidates = np.array(refinement_candidates)\n                refinement_candidates = refinement_candidates[np.argsort([func(x) for x in refinement_candidates])]\n                self.best_solution = refinement_candidates[0]\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and probability-based refinement.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "843c7a24-f4f5-4e84-bc10-66e3f6b157dd", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        # Refine the solution with probability 0.3\n        if random.random() < 0.3:\n            new_individual = np.random.uniform(-5.0, 5.0, self.dim)\n            while np.any(np.abs(new_individual - self.best_solution) < self.sphere_radius):\n                new_individual = np.random.uniform(-5.0, 5.0, self.dim)\n            self.best_solution = new_individual\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate and population-based approach.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
{"id": "dc3b91dd-5d5c-4128-96a5-fd52d3975b26", "solution": "import numpy as np\nimport random\n\nclass SwarmOfSpheres:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.sphere_radius = 1.0\n        self.learning_rate = 0.1\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.3\n\n    def __call__(self, func):\n        if self.budget == 0:\n            return self.best_solution\n\n        for _ in range(self.budget):\n            # Initialize population with random solutions\n            population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n            # Evaluate population fitness\n            fitness = [func(x) for x in population]\n\n            # Update best solution if necessary\n            if min(fitness) < self.best_fitness:\n                self.best_solution = population[np.argmin(fitness)]\n                self.best_fitness = min(fitness)\n\n            # Apply swarm of spheres evolution\n            for _ in range(10):\n                # Select parents using tournament selection\n                parents = np.array([population[np.random.choice(range(self.population_size)), :] for _ in range(2)])\n\n                # Apply crossover and mutation\n                offspring = []\n                for _ in range(self.population_size):\n                    parent1, parent2 = parents[np.random.choice(range(2))]\n                    child = (parent1 + parent2) * 0.5 + np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    child = np.clip(child, -5.0, 5.0)\n                    if random.random() < self.probability:\n                        child += np.random.uniform(-self.sphere_radius, self.sphere_radius, self.dim)\n                    offspring.append(child)\n\n                # Update population\n                population = np.array(offspring)\n\n            # Update learning rate\n            self.learning_rate *= 0.9\n\n        return self.best_solution\n\n# Example usage:\ndef func(x):\n    return sum(x**2)\n\nswarm = SwarmOfSpheres(budget=100, dim=10)\nbest_solution = swarm(func)\nprint(best_solution)", "name": "SwarmOfSpheres", "description": "Novel \"Swarm of Spheres\" algorithm with adaptive learning rate, population-based approach, and probabilistic mutation.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('too many values to unpack (expected 2)').", "error": "ValueError('too many values to unpack (expected 2)')", "parent_id": "631094d8-404b-46bd-a139-fae59f8acab0", "metadata": {}, "mutation_prompt": null}
