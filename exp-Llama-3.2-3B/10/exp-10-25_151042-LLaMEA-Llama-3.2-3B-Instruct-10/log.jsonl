{"id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 83, in evaluateBBOB\n    np.save(f\"currentexp/aucs-{algorithm_name}-{i}.npy\", aucs)\n  File \"/root/LLaMEA/venv/lib/python3.11/site-packages/numpy/lib/npyio.py\", line 542, in save\n    file_ctx = open(file, \"wb\")\n               ^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'currentexp/aucs-MultiSwarmHarmonySearch-0.npy'\n.", "error": "FileNotFoundError(2, 'No such file or directory')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 83, in evaluateBBOB\n    np.save(f\"currentexp/aucs-{algorithm_name}-{i}.npy\", aucs)\n  File \"/root/LLaMEA/venv/lib/python3.11/site-packages/numpy/lib/npyio.py\", line 542, in save\n    file_ctx = open(file, \"wb\")\n               ^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'currentexp/aucs-MultiSwarmHarmonySearch-0.npy'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "6072e908-f257-4276-b68a-7fdddbd7f8f7", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.1:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Mutation phase\n            if random.random() < 0.1:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm with probability-based adaptation and mutation", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "0ec28eb3-737b-4374-9694-f49fcad7da7a", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_rate:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Perturbation\" algorithm", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "a692471d-4a12-4cc2-a0ef-bc1232d247f3", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Dynamic adaptation\n        for i in range(len(self.swarm)):\n            if np.random.rand() < 0.1:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "765bec10-48dc-48a9-8cd3-db6c02efbecc", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive mutation\n            if np.random.rand() < self.mutation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "018ea34c-d20d-4eb1-8729-cd7f49c0036c", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability_refinement = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Probability refinement\n            if np.random.rand() < self.probability_refinement:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "6e71f0db-d066-498a-9738-8b8c8bfb4e2d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Probability refinement\n            if np.random.rand() < 0.1:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "e55bb681-b92a-4712-8f3b-3cbb1470303d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_search = False\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Line search phase\n            if self.line_search:\n                direction = self.swarm[i] - self.best_solution\n                step_size = 0.1\n                while True:\n                    new_solution = self.swarm[i] + step_size * direction\n                    new_fitness = func(new_solution)\n                    if new_fitness < self.best_fitness:\n                        self.swarm[i] = new_solution\n                        self.best_solution = new_solution\n                        self.best_fitness = new_fitness\n                    else:\n                        step_size *= 0.9\n                        if step_size < 1e-6:\n                            break\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "71b53ba2-7fd0-4e24-8411-9357956364e4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Refine the best solution with probability\n        if np.random.rand() < self.probability:\n            r1, r2 = random.random(), random.random()\n            if r1 < 0.5:\n                self.best_solution = self.best_solution + 0.1 * np.random.uniform(-1, 1, self.dim)\n            else:\n                self.best_solution = self.best_solution - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "c41794c9-50d2-46cc-b1b8-7bf4bea3108d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine the best solution\n            if self.best_solution is not None and np.random.rand() < self.adaptation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.best_solution = self.best_solution + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.best_solution = self.best_solution - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "95eaf6e0-2b66-47ad-891f-8c98b660c770", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Dynamic adaptation\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.1:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "bd64c1dd-5c5a-4e87-b585-dd46d54b5b15", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")\n\n# Modified code to refine the strategy by changing individual lines with a probability of 0.1\nclass MultiSwarmHarmonySearchRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    new_solution = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    if np.random.rand() < 0.1:\n                        new_solution += np.random.uniform(-1, 1, self.dim)\n                    self.swarm[i] = new_solution\n                elif r2 < 0.4:\n                    new_solution = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    if np.random.rand() < 0.1:\n                        new_solution += np.random.uniform(-1, 1, self.dim)\n                    self.swarm[i] = new_solution\n                elif r1 < 0.6:\n                    new_solution = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    if np.random.rand() < 0.1:\n                        new_solution -= np.random.uniform(-1, 1, self.dim)\n                    self.swarm[i] = new_solution\n                elif r2 < 0.8:\n                    new_solution = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n                    if np.random.rand() < 0.1:\n                        new_solution -= np.random.uniform(-1, 1, self.dim)\n                    self.swarm[i] = new_solution\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        new_solution = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        new_solution = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n                    self.swarm[i] = new_solution\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearchRefined(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "610a13e2-df9f-4e45-99cc-6fb14faebe87", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n                # Refine individual solutions with probability 0.1\n                if random.random() < self.adaptation_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability to refine individual solutions.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "c1b110d3-2b01-4605-9dc5-3e9f3ccc399c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy with probability 0.1\n            if np.random.rand() < self.probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "4b673a63-a36d-40be-a33b-26782c6e85a2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_search = True\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Line search phase\n        if self.line_search:\n            for i in range(len(self.swarm)):\n                solution = self.swarm[i]\n                direction = np.random.uniform(-1, 1, self.dim)\n                step_size = 0.1\n                while True:\n                    new_solution = solution + step_size * direction\n                    new_fitness = func(new_solution)\n                    if new_fitness < self.best_fitness:\n                        self.swarm[i] = new_solution\n                        self.best_fitness = new_fitness\n                    else:\n                        step_size *= 0.9\n                        if step_size < 0.01:\n                            break\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "ad4c56a0-211d-4b4b-b257-c0edc4cf6957", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n                if np.random.rand() < self.adaptation_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "c9c93635-96bd-4235-9de6-ac6a8b3c599a", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptive_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptive_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "13a23956-a938-49ba-8552-bc4e6c656b51", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy with probability 0.1\n            if random.random() < self.adaptation_rate:\n                for _ in range(int(self.budget * 0.1)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "e452b35b-9155-4d69-b548-211fa20406d2", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability_refine = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy with probability\n            if np.random.rand() < self.probability_refine:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "16ae25c5-4980-4462-9439-d3b828afdc5b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "5d59232f-6498-4fc6-ac19-549e5bca5fb1", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_search = True\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Line search\n            if self.line_search:\n                solution = self.swarm[i]\n                gradient = np.zeros(self.dim)\n                for j in range(self.dim):\n                    gradient[j] = 2 * solution[j] * (1 - solution[j])\n                direction = -gradient\n                step_size = 0.1\n                while True:\n                    new_solution = solution + step_size * direction\n                    new_fitness = func(new_solution)\n                    if new_fitness < self.best_fitness:\n                        solution = new_solution\n                        self.best_fitness = new_fitness\n                    else:\n                        step_size *= 0.9\n                        if step_size < 1e-6:\n                            break\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "cf782d95-32d2-48cf-8ccf-f5915c2e4dee", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n        self.adaptive_probability = 0.01\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive probability update\n            if np.random.rand() < self.adaptive_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.adaptation_probability = min(0.2, self.adaptation_probability + 0.01)\n                else:\n                    self.adaptation_probability = max(0.01, self.adaptation_probability - 0.01)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Adaptive Probability\" algorithm", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "350ce9db-e8e9-4d33-9a74-839ff518893d", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_search = True\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Line search phase\n            if self.line_search:\n                direction = -np.gradient(func(self.swarm[0]))\n                step_size = 0.1\n                while np.linalg.norm(direction) > 1e-6:\n                    new_solution = self.swarm[0] + step_size * direction\n                    if func(new_solution) < func(self.swarm[0]):\n                        self.swarm[0] = new_solution\n                        direction = -np.gradient(func(self.swarm[0]))\n                    step_size *= 0.9\n                self.line_search = False\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"bad operand type for unary -: 'list'\").", "error": "TypeError(\"bad operand type for unary -: 'list'\")", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "675b9459-5f68-4433-b4c7-51e46d37c515", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Dynamic adaptation\n            if np.random.rand() < self.adaptation_prob:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + self.adaptation_rate * (self.swarm[i] - self.best_solution)\n                else:\n                    self.swarm[i] = self.swarm[i] - self.adaptation_rate * (self.swarm[i] - self.best_solution)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm that combines the strengths of multi-swarm harmony search and dynamic adaptation to optimize black box functions.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "2e442d9f-4b60-462a-8fff-c0a8afe19199", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine the solution with probability 0.1\n            if np.random.rand() < self.refinement_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "c4433cd6-c064-4f62-8ab8-6ff776025955", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptive_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptive_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Adaptive Probability\" algorithm", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "c5bc924c-36eb-46a1-a32a-8b32f8332afa", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy with adaptation\n            if np.random.rand() < self.adaptation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "dc9994ed-1837-4a27-b103-9f098b04bb8d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Probability refinement\n        for i in range(len(self.swarm)):\n            if np.random.rand() < 0.1:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\"", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "8994fded-f230-4879-b17d-20bb514df185", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n        self.mutation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < self.adaptation_prob + self.mutation_prob:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < self.adaptation_prob + 2 * self.mutation_prob:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < self.adaptation_prob + 3 * self.mutation_prob:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Adaptive Mutation\" algorithm", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "db556c72-0028-463e-aae7-faa9f61249fe", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.adaptation_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "d8d977aa-4946-4a4f-bdfd-6ebb63018c9a", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_search = False\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Line search\n            if self.line_search:\n                direction = self.swarm[i] - self.best_solution\n                step_size = 0.1\n                while self.f(self.swarm[i] + step_size * direction) < self.f(self.swarm[i]):\n                    self.swarm[i] += step_size * direction\n                    step_size *= 0.9\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "0baab3a1-cc46-4dac-90c4-6b4bc654e61c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = np.random.rand(), np.random.rand()\n                if r1 < self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.4:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.6:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r1 < 0.8:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-0.5, 0.5, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-0.5, 0.5, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-0.5, 0.5, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-0.5, 0.5, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "6d363fde-ba80-4643-8be2-8e9828063517", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy using probability 0.1\n            if random.random() < 0.1:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability 0.1 to refine its strategy", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "ac853bf2-5f44-4162-9b41-1d289bac333c", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine solution with adaptation probability\n            if np.random.rand() < self.adaptation_prob:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "a96148c7-bbe9-42a3-a31a-95251547a085", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive mutation\n            if np.random.rand() < self.adaptation_probability:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "ebfbbf58-46fb-4f65-98e5-c83ad79ed939", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine the solution with 10% probability\n            if np.random.rand() < self.adaptation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "231fcd7a-02e7-4215-9f3f-ec2e196f716a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy with probability 0.1\n            if np.random.rand() < self.adaptation_rate:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.05 * (self.swarm[i] - self.best_solution)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.05 * (self.swarm[i] - self.best_solution)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "10601c38-bebb-4972-9069-820c5ee0e51f", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Probability-based mutation\n        mutation_rate = 0.1\n        for i in range(len(self.swarm)):\n            if np.random.rand() < mutation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability-based mutation.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "bf110111-52a0-4b00-b5bc-235f94f4c9d9", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.adaptation_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "cb978cea-d4a5-4117-9fce-406cbf2e218e", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n        self.mutation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_rate:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Mutation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.mutation_rate:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "c1fe164f-72fd-4502-8ce2-cee6bf1a5f33", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n        self.adaptive_probability = 0.01\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive probability update\n            if np.random.rand() < self.adaptive_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.adaptation_probability = min(self.adaptation_probability + 0.01, 0.3)\n                else:\n                    self.adaptation_probability = max(self.adaptation_probability - 0.01, 0.1)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Adaptive Probability\" algorithm", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "f2ea0cc2-79e2-4134-a4cd-dd419026cf2d", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "2a61cd90-e678-4fef-9d73-126b17472db5", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Refine strategy by changing individual lines\n        for i in range(len(self.swarm)):\n            if np.random.rand() < self.adaptation_rate:\n                self.swarm[i] = self.swarm[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "351ab524-deff-4ccb-9a18-ac5a8535aaba", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.1:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "f21bbfe3-9196-4d2a-9095-47dc8372296f", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Probability refinement\n            if np.random.rand() < self.probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\"", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "bfc27a8c-3874-4723-b37b-0e412098625e", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive mutation\n            if np.random.rand() < self.adaptation_probability:\n                mutation_indices = np.random.choice(len(self.swarm), size=5, replace=False)\n                for index in mutation_indices:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[index] = self.swarm[index] + 0.1 * (self.swarm[index] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[index] = self.swarm[index] - 0.1 * (self.swarm[index] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[index] = self.swarm[index] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[index] = self.swarm[index] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "85111930-e2e8-4b4a-b34e-a66cd29924e3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refinement phase\n            if np.random.rand() < self.refine_probability:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Refinement\" algorithm", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "a6b6dd3d-d90b-4ccc-aacc-3167d8bdcf76", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy\n            if np.random.rand() < self.probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "136e1870-7002-456d-976d-0e84aac79c59", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "ccbf6883-973d-4435-9ca0-cdf9d5ad6798", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy\n            if np.random.rand() < self.refine_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "aad2ab36-0573-4cae-8f25-a56f38ae2073", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.1:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability 0.1 to refine individual lines.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "cc6e8f9e-4921-483f-8af0-0219f87cd15b", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine individual lines with probability 0.1\n            if np.random.rand() < self.probability:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability 0.1 to refine individual lines", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "7ba9a619-d665-4698-9e87-ab367f157030", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Refine strategy with probability 0.1\n        for i in range(len(self.swarm)):\n            if np.random.rand() < self.adaptation_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "40690bab-48e6-4605-bb87-db7ad039da7d", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability_refinement = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.probability_refinement:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\"", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "9769f62c-8bca-4f75-bce3-dcae3415ae49", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 2 * self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 2 * self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "38055530-f700-41bb-81f1-047260bae2c4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "2ae35a0e-d224-4116-86f8-aa7a47be07c2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r1 < 0.9:\n                    if np.random.rand() < self.adaptation_prob:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    if np.random.rand() < self.adaptation_prob:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "1cc24178-735e-46a1-9980-33c233fea0f4", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            if random.random() < 0.01:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "50f28453-0bf9-4c2b-89cf-d88cb1b40c72", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "784f8cbb-bd07-4570-9d0a-41447bf1855b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability_refinement = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.probability_refinement:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\"", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "406ede16-0287-4ad2-be7e-cf2c260b2f3e", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.adaptation_rate:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "d602ce6a-6a82-436c-af07-02d9393681cc", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = np.random.rand(), np.random.rand()\n                if r1 < self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < self.adaptation_prob:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.5:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "1910d6b2-e4ef-4caa-a342-5cba054e3f5b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < self.adaptation_probability:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < self.adaptation_probability:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.4:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.6:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "b2678467-f122-4d26-9dfa-6890cfe12149", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < self.adaptation_probability:\n                    # Random mutation\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < self.adaptation_probability * 2:\n                    # Random improvement\n                    r3, r4 = random.random(), random.random()\n                    if r3 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    # Random exploration\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability-based adaptation", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "621d6503-af70-4db1-a918-de6cd4a9c5b5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "54459a6e-00a5-4514-b051-c17949d2d861", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Refine the strategy using probability-based mutation\n        for i in range(len(self.swarm)):\n            if np.random.rand() < 0.1:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm that incorporates a probability-based mutation to refine the strategy.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "aba8f0a8-feb5-4054-8558-8e584e9fe4c5", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Refine the solution using probability-based refinement\n        if self.budget > 1:\n            refine_probability = 0.1\n            for i in range(len(self.swarm)):\n                if np.random.rand() < refine_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm with probability-based refinement.", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "ea74e619-f36e-4473-a234-e40ce2f07bc5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        step_size = 0.1 * np.random.uniform(-1, 1, self.dim)\n                        new_solution = self.swarm[i] + step_size\n                        new_fitness = func(new_solution)\n                        if new_fitness < self.best_fitness:\n                            self.swarm[i] = new_solution\n                            self.best_fitness = new_fitness\n                    else:\n                        step_size = 0.1 * np.random.uniform(-1, 1, self.dim)\n                        new_solution = self.swarm[i] - step_size\n                        new_fitness = func(new_solution)\n                        if new_fitness < self.best_fitness:\n                            self.swarm[i] = new_solution\n                            self.best_fitness = new_fitness\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "b1c79a55-7238-435f-8d5d-0835756df31e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "95f502cf-93e8-4598-950e-6965a6e0d600", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.mutation_prob:\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability-based mutation.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "9786b2ec-e96e-4829-a1ee-9f79d4c02fa2", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine the strategy\n            if random.random() < self.adaptation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "7d71a2c8-ac88-4a91-8e16-8077c80b9a2f", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Mutation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.1:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability-based adaptation and mutation.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "e5092163-6dbd-4771-9737-80892b8c46a6", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "9e94092a-7256-4afc-a22f-ff27ac4d67cc", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.1:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if random.random() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "b8580c75-6a97-47ed-9ebe-bb1317ac255e", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Adaptive Probability\" algorithm", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "b667914d-c2a6-451b-8439-6b97d37a6816", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_search = False\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Line search phase\n            if self.line_search:\n                direction = self.swarm[i] - self.best_solution\n                step_size = 0.1\n                while True:\n                    new_solution = self.swarm[i] + step_size * direction\n                    new_fitness = func(new_solution)\n                    if new_fitness < self.best_fitness:\n                        self.swarm[i] = new_solution\n                        self.best_fitness = new_fitness\n                    else:\n                        step_size *= 0.9\n                        if step_size < 1e-6:\n                            break\n\n            # Harmony search phase\n            if np.random.rand() < 0.01:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "4541601e-c39d-40a3-b3e1-c986065ef6da", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm with probability-based mutation.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "b27dcb55-d4ce-4c8c-9d0e-3420f8af4822", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Mutation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.mutation_probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using probability-based mutation.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "e85424a8-0c1c-4679-8f5e-fe365600ae4f", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_rate:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "069e268b-0401-4400-9497-db672b7fe9a7", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.mutation_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Mutation phase\n            if random.random() < self.mutation_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    mutation = np.random.uniform(-1, 1, self.dim)\n                    self.swarm[i] = self.swarm[i] + mutation\n                else:\n                    mutation = np.random.uniform(-1, 1, self.dim)\n                    self.swarm[i] = self.swarm[i] - mutation\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "026eb027-8f2d-4ee5-bd3f-8cfc96814d40", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy with probability\n            if np.random.rand() < self.probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "09899c49-bda1-4c8f-8544-a917f9809cae", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.probability:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "b2614a38-d5ca-4147-abd1-53b588f09277", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine solutions with probability 0.1\n            if np.random.rand() < self.refinement_probability:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm using a probability-based refinement strategy", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "3eb5fed3-37a9-40f0-abf8-a8b900074c24", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.line_search = True\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n                if self.line_search:\n                    # Perform line search to find the optimal solution\n                    direction = self.swarm[i] - self.best_solution\n                    step_size = 0.1\n                    while True:\n                        new_solution = self.swarm[i] + step_size * direction\n                        new_fitness = func(new_solution)\n                        if new_fitness < self.best_fitness:\n                            self.swarm[i] = new_solution\n                            self.best_solution = new_solution\n                            self.best_fitness = new_fitness\n                        else:\n                            step_size *= 0.9\n                            if step_size < 0.001:\n                                break\n                    self.line_search = False\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Line Search\" algorithm", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "bab01169-9b6e-4ce7-a66f-ba7ce974e0c4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refinement_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Probabilistic refinement\n            if np.random.rand() < self.refinement_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probabilistic Refinement\"", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "729391e5-6625-4a22-a676-6cf052b03c83", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.adaptation_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "3763e4fa-5750-4493-a170-34ff491f3122", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptive_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n                # Adaptive probability adjustment\n                if np.random.rand() < self.adaptive_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Probability\" algorithm", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "8466b9cd-bd57-4562-9aad-824dbfab22e4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability_refinement = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Probability refinement\n            if np.random.rand() < self.probability_refinement:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\" algorithm", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "21f3f798-41d3-47e4-b4f3-6e0b4d0177e4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Probabilistic refinement\n            if np.random.rand() < self.probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probabilistic Refinement\"", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "f3a2f511-2191-429f-ba66-4edcb79ed7f6", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Dynamic adaptation\n            if np.random.rand() < 0.1:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "ca005a5c-9663-4004-9b11-f2032f85450b", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Dynamic adaptation\n            if self.budget > 10:\n                if self.best_fitness < func(self.swarm[0]):\n                    self.budget -= 1\n                else:\n                    self.budget += 1\n\n        return self.best_solution, self.best_fitness\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm that combines multi-swarm harmony search with dynamic adaptation.", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "bbc2a8ec-f88c-4110-9147-3807d2810b3d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n        self.adaptation_step = 10\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive mutation\n            if (self.adaptation_step - self.adaptation_rate) < _ % self.adaptation_step:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation and Dynamic Adaptation\"", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "cf1dddee-f5d2-4474-8094-fb2df2c84ca9", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n        self.mutation_rate = 0.01\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Mutation phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < self.mutation_rate:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - np.random.uniform(-1, 1, self.dim)\n\n        # Adaptive mutation\n        for i in range(len(self.swarm)):\n            if np.random.rand() < self.adaptation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "906499c3-3a69-4030-ba51-7b68bfd9a522", "solution": "import numpy as np\nfrom scipy.optimize import minimize\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine the solution with probability 0.1\n            if np.random.rand() < self.adaptation_rate:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.01 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.01 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "7b529ae6-638f-4287-a790-a576e7817211", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.adaptation_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "af8c9c21-6078-4e37-a711-b6c4022b8c3c", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine individual lines with probability 0.1\n            for i in range(len(self.swarm)):\n                if random.random() < 0.1:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm that adapts the swarm's diversity by changing individual lines with a probability of 0.1.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "0d6f1cc0-df21-4989-becc-d66f4aaae0a3", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Refine strategy with probability 0.1\n            if np.random.rand() < self.refine_prob:\n                for i in range(len(self.swarm)):\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.05 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.05 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-0.5, 0.5, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-0.5, 0.5, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probability Refinement\"", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "4b19c985-2160-415c-bd7b-2badf1cde98b", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_rate = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Adaptive mutation\n            if np.random.rand() < self.adaptation_rate:\n                new_solution = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                self.swarm[i] = new_solution\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Adaptive Mutation\" algorithm", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "a9a70ef5-ae99-41c7-a6b7-19c0123f1dc4", "solution": "import numpy as np\nimport random\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.refine_probability = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.2:\n                    self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                elif r2 < 0.4:\n                    self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                elif r1 < 0.6:\n                    self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                elif r2 < 0.8:\n                    self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if np.random.rand() < 0.01:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Probabilistic refinement\n            if np.random.rand() < self.refine_probability:\n                r1, r2 = random.random(), random.random()\n                if r1 < 0.5:\n                    self.swarm[i] = self.swarm[i] + 0.05 * np.random.uniform(-1, 1, self.dim)\n                else:\n                    self.swarm[i] = self.swarm[i] - 0.05 * np.random.uniform(-1, 1, self.dim)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation and Probabilistic Refinement\" algorithm", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
{"id": "9cbca152-2585-4587-a2ff-eb9925948eb7", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MultiSwarmHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm = self.initialize_swarm()\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.adaptation_prob = 0.1\n        self.refine_prob = 0.1\n\n    def initialize_swarm(self):\n        swarm = []\n        for _ in range(self.budget):\n            solution = np.random.uniform(-5.0, 5.0, self.dim)\n            swarm.append(solution)\n        return swarm\n\n    def fitness(self, solution):\n        return func(solution)\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            if self.best_fitness > func(self.swarm[0]):\n                self.best_solution = self.swarm[0]\n                self.best_fitness = func(self.swarm[0])\n\n            for i, solution in enumerate(self.swarm):\n                fitness = func(solution)\n                if fitness < self.best_fitness:\n                    self.swarm[i] = solution\n                    self.best_fitness = fitness\n\n            # Adaptation phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.adaptation_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.2:\n                        self.swarm[i] = self.swarm[i] + 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r2 < 0.4:\n                        self.swarm[i] = self.swarm[i] - 0.1 * (self.swarm[i] - self.best_solution)\n                    elif r1 < 0.6:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    elif r2 < 0.8:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n            # Harmony search phase\n            for i in range(len(self.swarm)):\n                if random.random() < self.refine_prob:\n                    r1, r2 = random.random(), random.random()\n                    if r1 < 0.5:\n                        self.swarm[i] = self.swarm[i] + 0.1 * np.random.uniform(-1, 1, self.dim)\n                    else:\n                        self.swarm[i] = self.swarm[i] - 0.1 * np.random.uniform(-1, 1, self.dim)\n\n        # Refine the best solution\n        new_solution = copy.deepcopy(self.best_solution)\n        for _ in range(int(self.budget * self.refine_prob)):\n            r1, r2 = random.random(), random.random()\n            if r1 < 0.5:\n                new_solution = new_solution + 0.1 * np.random.uniform(-1, 1, self.dim)\n            else:\n                new_solution = new_solution - 0.1 * np.random.uniform(-1, 1, self.dim)\n            if func(new_solution) < func(self.best_solution):\n                self.best_solution = new_solution\n                self.best_fitness = func(self.best_solution)\n\n        return self.best_solution, self.best_fitness\n\ndef func(solution):\n    # Example noiseless function\n    return np.sum(solution**2)\n\n# Example usage\nms = MultiSwarmHarmonySearch(100, 10)\nbest_solution, best_fitness = ms(func)\nprint(f\"Best solution: {best_solution}\")\nprint(f\"Best fitness: {best_fitness}\")", "name": "MultiSwarmHarmonySearch", "description": "Novel \"Multi-Swarm Harmony Search with Dynamic Adaptation\" algorithm", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: FileNotFoundError(2, 'No such file or directory').", "error": "FileNotFoundError(2, 'No such file or directory')", "parent_id": "58dc2815-3032-4600-8552-b8dc2b97f84e", "metadata": {}, "mutation_prompt": null}
