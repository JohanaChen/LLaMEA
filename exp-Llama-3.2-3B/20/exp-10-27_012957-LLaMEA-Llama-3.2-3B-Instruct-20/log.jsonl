{"id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM)", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 50, in optimize\n  File \"/opt/conda/lib/python3.11/random.py\", line 439, in sample\n    raise TypeError(\"Population must be a sequence.  \"\nTypeError: Population must be a sequence.  For dicts or sets, use sorted(d).\n.", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')Traceback (most recent call last):\n  File \"/root/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/LLaMEA/mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 50, in optimize\n  File \"/opt/conda/lib/python3.11/random.py\", line 439, in sample\n    raise TypeError(\"Population must be a sequence.  \"\nTypeError: Population must be a sequence.  For dicts or sets, use sorted(d).\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "beac0efe-bb2d-4fde-bb11-f952a1245581", "solution": "import numpy as np\nimport random\n\nclass AdaptiveMOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.adaptive_crossover_rate = 0.7\n        self.adaptive_mutation_rate = 0.1\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        if random.random() < self.adaptive_crossover_rate:\n            child = child * (1 + random.uniform(-0.1, 0.1))\n        return child\n\n    def adaptive_mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.adaptive_mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.adaptive_crossover(parent1, parent2)\n                child = self.adaptive_mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nadaptive_moecbm = AdaptiveMOE_CBM(budget=100, dim=10)\nbest_fitness = adaptive_moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveMOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "943919a2-2187-416e-8c48-703183a6d955", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)\n\n# Novel \"Probabilistic Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\"\n# ```python\nimport numpy as np\nimport random\n\nclass PMOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def probabilistic_mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def probabilistic_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        child = self.probabilistic_mutation(child)\n        return child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.probabilistic_crossover(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npmoe_cbm = PMOE_CBM(budget=100, dim=10)\nbest_fitness = pmoe_cbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic mutation and crossover", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2ce17031-d106-402c-a8fb-16fa29933b75", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)\n\n# Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\"\n# ```python\nimport numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.adaptive_probabilities = [0.2] * self.population_size\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def update_adaptive_probabilities(self):\n        for i in range(self.population_size):\n            if self.fitness_values[sorted_indices[i]] > self.fitness_values[sorted_indices[i+1]]:\n                self.adaptive_probabilities[i] += 0.01\n            else:\n                self.adaptive_probabilities[i] -= 0.01\n            self.adaptive_probabilities[i] = max(0.0, min(1.0, self.adaptive_probabilities[i]))\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.update_adaptive_probabilities()\n            selected_indices = np.argsort(self.fitness_values)\n            selected_individuals = self.population[selected_indices[:int(self.population_size/2)]]\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.choices(selected_individuals, weights=self.adaptive_probabilities, k=2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with adaptive mutation and crossover probabilities.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "5c29da4d-6b61-44c8-8f95-9ad944e8e767", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        if random.random() < self.refinement_rate:\n            i = np.random.randint(0, self.dim)\n            individual[i] += random.uniform(-0.1, 0.1)\n            individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.refine(child)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "183bab83-b98c-419f-acd7-ac5e43a9dbc2", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                mutation = random.uniform(-1.0, 1.0)\n                individual[i] += mutation\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, selected_individuals):\n        refined_population = []\n        for individual in selected_individuals:\n            if random.random() < 0.2:\n                refined_individual = self.mutation(individual)\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            refined_population = self.refine_strategy(selected_individuals)\n            self.population = np.concatenate((selected_individuals, refined_population))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based mutation and crossover", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "79081f83-a044-4a73-a262-0793e8594d17", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability mutation", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "9e51e0d7-7865-40f8-8448-135e2c9188f8", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refine_strategy = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, parent1, parent2):\n        if random.random() < self.refine_strategy:\n            child = parent1 + parent2 * (parent2 - parent1)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine_strategy(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with probability 0.2 to refine its strategy", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "03d8b9ca-9ae0-4f8c-abc6-bf2ff813fdd6", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, individual):\n        if random.random() < self.refine_probability:\n            new_individual = individual + random.uniform(-1.0, 1.0) * np.random.choice([-1, 1])\n            new_individual = max(-5.0, min(5.0, new_individual))\n            return new_individual\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_strategy(child)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization with Probability Refinement\"", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "ecb7ab21-7e7c-42d9-ab0f-490fdafd9cb4", "solution": "import numpy as np\nimport random\n\nclass ProbabilisticMOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, parent1, parent2):\n        for i in range(self.dim):\n            if random.random() < self.probability:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine_strategy(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nprobabilisticmoecbm = ProbabilisticMOE_CBM(budget=100, dim=10)\nbest_fitness = probabilisticmoecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "ProbabilisticMOE_CBM", "description": "Novel \"Probabilistic Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "0cae3bfc-b5f6-4dc4-beb2-008e6aa0cf91", "solution": "import numpy as np\nimport random\nfrom scipy.stats import truncnorm\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        for i in range(self.population_size):\n            if random.random() < self.refine_probability:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                self.population[i] = child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine_strategy()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "cefeaeab-b93a-4279-9f95-bf11ffd60354", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            child = parent1 + parent2 * (parent2 - parent1)\n            return child\n        else:\n            return parent1\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability crossover and mutation.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "18b20d4a-2013-4a47-b348-b6f1f418f9ab", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def probabilistic_refinement(self, func):\n        refined_individuals = []\n        for individual in self.population:\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_individuals.append(child)\n        self.population = np.concatenate((self.population, refined_individuals))\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.probabilistic_refinement(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "dae88ffa-87f0-43a7-9695-909467d14dbe", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, selected_individuals):\n        refined_population = selected_individuals.copy()\n        for _ in range(int(self.population_size * 0.2)):\n            i = np.random.randint(0, self.population_size)\n            j = np.random.randint(0, self.population_size)\n            if np.random.rand() < 0.2:\n                refined_population[i] = self.mutate(refined_population[i], self.mutation_rate)\n                refined_population[j] = self.mutate(refined_population[j], self.mutation_rate)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_population = self.refine(selected_individuals)\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(refined_population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'MOE_CBM' object has no attribute 'mutate'\").", "error": "AttributeError(\"'MOE_CBM' object has no attribute 'mutate'\")", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2db8c1fc-b7e4-4fc6-a7d0-2143a1ec7ae8", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.refinement_rate:\n                individual[i] += random.uniform(-0.5, 0.5)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                child = self.refine(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probabilistic Refinement for Black Box Optimization\"", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "da4d5d2d-0bdd-4896-9b7c-437a76b749ec", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                if random.random() < self.crossover_rate:\n                    child = self.crossover(parent1, parent2)\n                else:\n                    child = parent1\n                if random.random() < self.mutation_rate:\n                    child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability mutation and 20% probability crossover.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "9a1a88b7-b0a0-4851-8dd6-9693f1cf2e03", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        refined_population = self.population.copy()\n        for i in range(self.population_size):\n            if random.random() < 0.2:\n                refined_individual = self.population[i] + random.uniform(-0.5, 0.5)\n                refined_population[i] = max(-5.0, min(5.0, refined_individual))\n        self.population = refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.refine_strategy()\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "d11384d5-4861-4988-b9d2-7e0c3abb765c", "solution": "import numpy as np\nimport random\n\nclass PME_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        refined_population = []\n        for individual in self.population:\n            if random.random() < self.refine_rate:\n                refined_individual = individual + random.uniform(-0.1, 0.1) * (individual - self.population[np.random.choice(self.population_size)])\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        self.population = refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npmecbm = PME_CBM(budget=100, dim=10)\nbest_fitness = pmecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "PME_CBM", "description": "Novel \"Probabilistic Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (PME-CBM)", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "933e640d-f0dd-4f7e-9d9d-5acde9d2f1f1", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.adaptive_prob = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def adapt_prob(self):\n        avg_fitness = np.mean(self.fitness_values)\n        if avg_fitness < 0.5:\n            self.adaptive_prob = 0.2\n        elif avg_fitness < 0.7:\n            self.adaptive_prob = 0.4\n        else:\n            self.adaptive_prob = 0.6\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.adapt_prob()\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            if random.random() < self.adaptive_prob:\n                for individual in self.population:\n                    individual += random.uniform(-0.5, 0.5)\n                    individual = max(-5.0, min(5.0, individual))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation and Adaptive Probability for Black Box Optimization\"", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "1cdf1f79-916b-4d3f-af66-dea63362205a", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        for _ in range(int(self.population_size * 0.2)):\n            selected_individual = random.choice(self.population)\n            new_individual = selected_individual.copy()\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    new_individual[i] += random.uniform(-1.0, 1.0)\n                    new_individual[i] = max(-5.0, min(5.0, new_individual[i]))\n            self.population = np.concatenate((self.population, new_individual))\n            self.population = self.population[np.argsort(self.fitness_values)]\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.refine_strategy()\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "bc60948a-bb3d-4db4-af30-ab63dbf4d059", "solution": "import numpy as np\nimport random\n\nclass PCM_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, selected_individuals):\n        refined_individuals = []\n        for individual in selected_individuals:\n            if random.random() < self.refine_rate:\n                for i in range(self.dim):\n                    individual[i] += random.uniform(-0.1, 0.1)\n                    individual[i] = max(-5.0, min(5.0, individual[i]))\n            refined_individuals.append(individual)\n        return refined_individuals\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            refined_individuals = self.refine(selected_individuals)\n            self.population = np.concatenate((selected_individuals, offspring, refined_individuals))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npcm_bbo = PCM_BBO(budget=100, dim=10)\nbest_fitness = pcm_bbo.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "PCM_BBO", "description": "Novel \"Probabilistic Crossover with Mutation for Black Box Optimization\" (PCM-BBO)", "configspace": "", "generation": 20, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2cb7f94b-2433-4eec-98c8-c4f795b0d8b7", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MOE_ACM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        for i in range(self.dim):\n            if random.random() < self.crossover_rate:\n                child[i] = (parent1[i] + parent2[i]) / 2\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_solution(self, selected_individuals):\n        refined_population = []\n        for individual in selected_individuals:\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.adaptive_crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population.append(child)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = self.refine_solution(selected_individuals)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoe_acm = MOE_ACM(budget=100, dim=10)\nbest_fitness = moe_acm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_ACM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\" (MOE-ACM)", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2460af31-7179-4ce5-8349-162ef9431fd4", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, func):\n        refined_population = []\n        for individual in self.population:\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population.append(child)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "7637031a-39a8-43bf-aab5-3283c2346267", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        refined_population = []\n        for individual in self.population:\n            if random.random() < 0.2:\n                for i in range(self.dim):\n                    individual[i] += random.uniform(-1.0, 1.0)\n                    individual[i] = max(-5.0, min(5.0, individual[i]))\n            refined_population.append(individual)\n        self.population = refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine_strategy()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "1ca8a0fa-c844-4319-8c41-9883dca78ce8", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, selected_individuals):\n        refined_individuals = []\n        for individual in selected_individuals:\n            if random.random() < self.refinement_probability:\n                for i in range(self.dim):\n                    individual[i] += random.uniform(-0.5, 0.5)\n                    individual[i] = max(-5.0, min(5.0, individual[i]))\n            refined_individuals.append(individual)\n        return refined_individuals\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_individuals = self.refine(selected_individuals)\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, refined_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "aaa9baab-c80f-4e00-927e-d9b1e0345338", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.adaptation_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def adapt_probabilities(self):\n        selected_indices = np.argsort(self.fitness_values)\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        probabilities = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            probabilities[i] = np.mean([selected_individuals[j, i] for j in range(int(self.population_size/2))])\n        probabilities = probabilities / np.sum(probabilities)\n        new_probabilities = probabilities * (1 - self.adaptation_rate) + self.adaptation_rate * np.random.rand(self.population_size)\n        return new_probabilities\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            new_probabilities = self.adapt_probabilities()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.choices(selected_individuals, weights=new_probabilities, k=2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Adaptive Probabilities for Black Box Optimization\"", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'sorted_indices' is not defined\").", "error": "NameError(\"name 'sorted_indices' is not defined\")", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "d29976cc-7cd1-4362-8bba-4413504eb4c5", "solution": "import numpy as np\nimport random\n\nclass PMOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        for i in range(self.population_size):\n            if random.random() < self.refine_probability:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                self.population[i] = child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npmoe_cbm = PMOE_CBM(budget=100, dim=10)\nbest_fitness = pmoe_cbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "PMOE_CBM", "description": "Novel \"Probabilistic Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (PMOE-CBM)", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "a6040bbb-2159-4d87-9e9d-b4a07b1a250d", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            # Adaptive mutation rate\n            self.mutation_rate = 0.2 * (self.fitness_values[np.argmin(self.fitness_values)] / 255)\n            self.mutation_rate = max(0, min(1, self.mutation_rate))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with adaptive mutation rate", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "310dc8a0-b918-4cfa-80e5-fc3d1b605a25", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, parent1, parent2):\n        if random.random() < 0.2:\n            child = parent1 + random.uniform(-1.0, 1.0) * (parent2 - parent1)\n        else:\n            child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine_strategy(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based strategy refinement", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "05e5e385-a74f-40a3-9a59-98885d276738", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        if random.random() < self.refine_probability:\n            child = parent1 + parent2 * (parent2 - parent1)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization with Probability-Based Refinement\"", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "44fccd22-a62f-491b-a2b3-2d299ab0868a", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_solution(self, selected_individuals):\n        refined_population = selected_individuals.copy()\n        for i in range(self.population_size):\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population[i] = child\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_population = self.refine_solution(selected_individuals)\n            offspring = refined_population\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "a1f7e3fe-1df2-4538-9549-7f1b4726b510", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, func):\n        for _ in range(int(self.population_size*0.2)):\n            selected_individual = random.choice(self.population)\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    new_individual = selected_individual.copy()\n                    new_individual[i] += random.uniform(-1.0, 1.0)\n                    new_individual[i] = max(-5.0, min(5.0, new_individual[i]))\n                    if func(new_individual) > func(selected_individual):\n                        selected_individual = new_individual\n        return selected_individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            refined_individuals = []\n            for individual in self.population:\n                refined_individual = self.refine(func)\n                refined_individuals.append(refined_individual)\n            self.population = refined_individuals\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "7291a13b-ed60-4b39-9c46-d302908a7bc2", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        if random.random() < 0.2:\n            child = parent1 + parent2 * (parent2 - parent1)\n            return child\n        else:\n            return parent1\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability crossover and mutation refinement", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "ca3b5a33-06b7-4ab8-990a-344a78f8f1bb", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_prob = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        new_population = np.copy(self.population)\n        for individual in new_population:\n            if random.random() < self.refine_prob:\n                for i in range(self.dim):\n                    individual[i] += random.uniform(-0.5, 0.5)\n                    individual[i] = max(-5.0, min(5.0, individual[i]))\n        return new_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            if _ % 10 == 0:\n                self.population = self.refine()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with probabilistic refinement.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "01df2976-8919-494f-a0fa-309725003ce8", "solution": "import numpy as np\nimport random\nfrom scipy.optimize import minimize\n\nclass MultiObjectiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def probabilistic_line_search(self, func, x, step_size):\n        if random.random() < 0.2:\n            new_x = x + step_size\n            new_fitness = func(new_x)\n            if new_fitness < func(x):\n                x = new_x\n        return x\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                child = self.probabilistic_line_search(func, child, 0.1)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MultiObjectiveEvolutionaryAlgorithm(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MultiObjectiveEvolutionaryAlgorithm", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation and Probabilistic Line Search for Black Box Optimization\"", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "1e79442c-f371-48cb-9f14-547d3dc308fa", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        refined_population = []\n        for individual in self.population:\n            if random.random() < 0.2:\n                for i in range(self.dim):\n                    individual[i] += random.uniform(-0.5, 0.5)\n                    individual[i] = max(-5.0, min(5.0, individual[i]))\n            refined_population.append(individual)\n        self.population = np.array(refined_population)\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine_strategy()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with probability 0.2 to refine its strategy.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "46ecb51a-c16d-4a99-9590-4040fd354ec3", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_solution(self, parent1, parent2):\n        refined_individual = parent1 + parent2 * (parent2 - parent1)\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                refined_individual[i] += random.uniform(-1.0, 1.0)\n                refined_individual[i] = max(-5.0, min(5.0, refined_individual[i]))\n        return refined_individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_solution(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with refinement probability", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "38c2d1db-f7be-4af4-b775-e2ca0ba76b15", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def line_mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.line_mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability of line mutation.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "f2862d5d-bc6f-4d5b-9440-24c73ffb5d1a", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, func):\n        refined_population = []\n        for individual in self.population:\n            if random.random() < 0.2:\n                mutation = random.uniform(-1.0, 1.0)\n                individual += mutation\n                individual = max(-5.0, min(5.0, individual))\n            refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.population = self.refine(func)\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "0b3e3934-4dbd-4fc2-b4af-9ef8cfb035eb", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        if random.random() < self.crossover_rate:\n            child = 0.2 * parent1 + 0.8 * parent2\n        else:\n            child = parent1\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability crossover and mutation.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "653b3403-db95-4b6d-91ce-833e57f9c1b0", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.adaptive_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def adaptive_crossover(self, parent1, parent2):\n        if random.random() < self.adaptive_probability:\n            child = parent1 + parent2 * (parent2 - parent1)\n        else:\n            child = parent1\n        return child\n\n    def adaptive_mutation(self, individual):\n        if random.random() < self.adaptive_probability:\n            for i in range(self.dim):\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.adaptive_crossover(parent1, parent2)\n                child = self.adaptive_mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Adaptive Probability for Black Box Optimization\"", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "df027a46-0a6b-4b0a-9f60-3c3016a29159", "solution": "import numpy as np\nimport random\n\nclass PCM_EA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        for i in range(self.population_size):\n            if random.random() < 0.2:\n                new_individual = self.population[i] + random.uniform(-1.0, 1.0)\n                new_individual = max(-5.0, min(5.0, new_individual))\n                self.population[i] = new_individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine_strategy()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npcm_ea = PCM_EA(budget=100, dim=10)\nbest_fitness = pcm_ea.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "PCM_EA", "description": "Novel \"Probabilistic Crossover and Mutation for Black Box Optimization with Evolutionary Algorithm\" (PCM-EA)", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "5873be4c-c03b-4f2c-af6a-bd511564481f", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def probabilistic_line_search(self, parent1, parent2):\n        alpha = random.uniform(0.0, 1.0)\n        child = parent1 + alpha * (parent2 - parent1)\n        return child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                if random.random() < self.probability:\n                    child = self.probabilistic_line_search(parent1, parent2)\n                else:\n                    child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probabilistic Line Search for Black Box Optimization\"", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "a70a87b9-9ab4-4d8b-bf46-875d85451f70", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, selected_individuals):\n        refined_population = np.copy(self.population)\n        for i in range(self.population_size):\n            if random.random() < self.refinement_probability:\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population[i] = child\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_population = self.refine(selected_individuals)\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(refined_population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "48a38fd2-c7c1-476b-8f6a-648c3c6259ea", "solution": "import numpy as np\nimport random\n\nclass MOE_ACM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        # Adapt the crossover rate based on the fitness values\n        if np.mean(self.fitness_values) > 0.5:\n            self.crossover_rate = 0.8\n        else:\n            self.crossover_rate = 0.5\n        child = child * self.crossover_rate\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, parent1, parent2):\n        # Refine the crossover and mutation strategy based on the fitness values\n        if np.mean(self.fitness_values) > 0.5:\n            self.mutation_rate = 0.12\n            self.crossover_rate = 0.8\n        else:\n            self.mutation_rate = 0.08\n            self.crossover_rate = 0.5\n        return parent1, parent2\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.adaptive_crossover(parent1, parent2)\n                child = self.refine_strategy(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecam = MOE_ACM(budget=100, dim=10)\nbest_fitness = moecam.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_ACM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\" (MOE-ACM)", "configspace": "", "generation": 44, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "3b414ccd-5e1e-4eb7-865a-ef62530053c0", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM_Probabilistic_Replacement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def probabilistic_replacement(self, parent, child):\n        if random.random() < self.probability:\n            self.population = np.delete(self.population, np.where(self.population == parent))\n            self.population = np.vstack((self.population, child))\n        else:\n            self.population = np.vstack((self.population, child))\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            for i in range(len(offspring)):\n                parent = offspring[i]\n                child = offspring[(i+1)%len(offspring)]\n                self.probabilistic_replacement(parent, child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm_probabilistic_replacement = MOE_CBM_Probabilistic_Replacement(budget=100, dim=10)\nbest_fitness = moecbm_probabilistic_replacement.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM_Probabilistic_Replacement", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probabilistic Replacement for Black Box Optimization\" using Probabilistic Replacement Strategy", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "fc04d1ef-1dfe-4d58-bbdc-d369a5f63b52", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        refined_population = []\n        for individual in self.population:\n            if random.random() < self.refine_probability:\n                # Select two parents randomly\n                parent1, parent2 = random.sample(self.population, 2)\n                # Create a child by crossover\n                child = self.crossover(parent1, parent2)\n                # Refine the child by mutation\n                child = self.mutation(child)\n                refined_population.append(child)\n        self.population = np.concatenate((self.population, refined_population))\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            # Refine the population every 10 generations\n            if (_ + 1) % 10 == 0:\n                self.refine()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2f4dd4e7-977b-43c7-8acb-cf65d06079a0", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, func):\n        for _ in range(int(self.population_size/2)):\n            selected_individual = random.choice(self.population)\n            for i in range(self.dim):\n                if random.random() < 0.2:\n                    new_value = random.uniform(-5.0, 5.0)\n                    if random.random() < 0.5:\n                        selected_individual[i] += new_value\n                    else:\n                        selected_individual[i] -= new_value\n                    selected_individual[i] = max(-5.0, min(5.0, selected_individual[i]))\n        return selected_individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.population = np.array([self.refine(func)(individual) for individual in self.population])\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "03a740ff-e103-4a3c-82e2-111535b7a1a6", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.adaptive_crossover_rate = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        if random.random() < self.adaptive_crossover_rate:\n            child = self.mutation(child)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.adaptive_crossover(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "27679792-6c8c-4501-b86b-c61a80494277", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def change_individual(self, individual):\n        if random.random() < 0.2:\n            for i in range(self.dim):\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                child = self.change_individual(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability of changing individual lines for better exploration-exploitation trade-off.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "26ce10a9-5f56-4a08-8664-4aa73a8f6318", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.adaptive_prob = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def adaptive_selection(self):\n        for i in range(self.population_size):\n            if random.random() < self.adaptive_prob:\n                self.population[i] = self.mutation(self.population[i])\n        return self.population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.population = self.adaptive_selection()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with adaptive probability", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "97887ef5-1027-4c11-8661-c06991cccec6", "solution": "import numpy as np\nimport random\n\nclass PEACBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refine_rate = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, selected_individuals):\n        refined_individuals = []\n        for individual in selected_individuals:\n            if random.random() < self.refine_rate:\n                i = np.random.randint(0, self.dim)\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n            refined_individuals.append(individual)\n        return refined_individuals\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            refined_individuals = self.refine(selected_individuals)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npeacbm = PEACBM(budget=100, dim=10)\nbest_fitness = peacbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "PEACBM", "description": "Novel \"Probabilistic Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (PEACBM)", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "683029df-6f82-4077-ae64-9e937b6590f9", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        mutated_individual = individual.copy()\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                mutated_individual[i] += random.uniform(-1.0, 1.0)\n                mutated_individual[i] = max(-5.0, min(5.0, mutated_individual[i]))\n        return mutated_individual\n\n    def refine_strategy(self, parent1, parent2):\n        if random.random() < 0.2:\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine_strategy(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic mutation.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "c2f6e1ab-b26d-4989-8e1a-87771860dec9", "solution": "import numpy as np\nimport random\n\nclass PCAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, selected_individuals):\n        refined_population = []\n        for individual in selected_individuals:\n            if random.random() < 0.2:\n                refined_individual = individual + random.uniform(-1.0, 1.0) * random.choice([-1.0, 1.0])\n                refined_individual = max(-5.0, min(5.0, refined_individual))\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_population = self.refine_strategy(selected_individuals)\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npcam = PCAM(budget=100, dim=10)\nbest_fitness = pcam.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "PCAM", "description": "Novel \"Probabilistic Crossover with Adaptive Mutation for Black Box Optimization\" (PCAM)", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "0884020b-eeca-4bb7-9517-c631994b80e6", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.prob_refine_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        if random.random() < self.prob_refine_rate:\n            index = random.randint(0, self.dim-1)\n            new_value = random.uniform(-5.0, 5.0)\n            individual[index] = new_value\n            individual[index] = max(-5.0, min(5.0, individual[index]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                child = self.refine(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probabilistic Refinement for Black Box Optimization\"", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "535e20ca-0c4e-48ad-8e38-98f8eb813f22", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_solution(self, selected_individuals):\n        new_population = selected_individuals.copy()\n        for i in range(len(selected_individuals)):\n            if random.random() < 0.2:\n                j = random.randint(0, self.dim-1)\n                new_individual = selected_individuals[i].copy()\n                new_individual[j] += random.uniform(-1.0, 1.0)\n                new_individual[j] = max(-5.0, min(5.0, new_individual[j]))\n                new_population[i] = new_individual\n        return new_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            new_population = self.refine_solution(selected_individuals)\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with a 20% probability of changing the individual lines of the selected solution.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2bfd2ee2-7b70-4cb7-a97c-00dd29f42a85", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refinement_prob = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent):\n        if random.random() < self.refinement_prob:\n            for i in range(self.dim):\n                parent[i] += random.uniform(-0.2, 0.2)\n                parent[i] = max(-5.0, min(5.0, parent[i]))\n        return parent\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.refine(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "392d5a9d-6fa2-4e01-9032-f35e04b18257", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        for i in range(self.population_size):\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                self.population[i] = child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.refine_strategy()\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2dc2cf71-5210-40db-8dbe-18fb9da567ab", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        for i in range(self.population_size):\n            if random.random() < self.refine_rate:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                self.population[i] = child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.refine()\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "6786c09b-97d9-46db-9a2f-8740a23b5791", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_prob = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        if random.random() < self.refine_prob:\n            i = random.randint(0, self.dim-1)\n            individual[i] += random.uniform(-1.0, 1.0)\n            individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                child = self.refine(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probabilistic Refinement for Black Box Optimization\"", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "26e67c68-d35d-4a0c-814c-2a9c0c15597f", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        if random.random() < 0.2:\n            parent1 += random.uniform(-1.0, 1.0)\n            parent1 = max(-5.0, min(5.0, parent1))\n        if random.random() < 0.2:\n            parent2 += random.uniform(-1.0, 1.0)\n            parent2 = max(-5.0, min(5.0, parent2))\n        return parent1, parent2\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child1, child2 = self.refine(parent1, parent2)\n                child1 = self.mutation(child1)\n                child2 = self.mutation(child2)\n                offspring.append(child1)\n                offspring.append(child2)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "e43cf549-63ce-49da-8227-ca36d2919998", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        for i in range(self.dim):\n            if random.random() < self.refinement_rate:\n                child[i] += random.uniform(-0.5, 0.5)\n                child[i] = max(-5.0, min(5.0, child[i]))\n        return child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "71af4270-b9b5-4e80-9fe9-1e89ece10ded", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, selected_individuals):\n        refined_population = []\n        for individual in selected_individuals:\n            if random.random() < 0.2:\n                refined_individual = individual + random.uniform(-0.5, 0.5) * (individual - np.mean(individual))\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_population = self.refine_strategy(selected_individuals)\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, refined_population, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "9498f0b0-c946-4b01-8162-461251ee527f", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.probability = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def probabilistic_line_search(self, func, individual):\n        # Perform a probabilistic line search to find the optimal step size\n        step_size = np.random.uniform(-1.0, 1.0)\n        new_individual = individual + step_size * np.sign(np.random.uniform(-1.0, 1.0))\n        new_individual = max(-5.0, min(5.0, new_individual))\n        fitness = func(new_individual)\n        if np.random.rand() < self.probability:\n            return self.mutation(new_individual)\n        else:\n            return new_individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.probabilistic_line_search(func, child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probabilistic Line Search for Black Box Optimization\"", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "c906c61f-9438-4804-a2da-745ce47a3811", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            # Adaptive mutation and crossover rates\n            self.mutation_rate *= 0.8\n            self.crossover_rate *= 0.8\n            if random.random() < 0.2:\n                self.mutation_rate *= 1.2\n                self.crossover_rate *= 1.2\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with adaptive mutation and crossover rates.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "183bbb85-35bf-4267-bada-2246cc52f397", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability of mutation and 70% probability of crossover.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "a0c828ae-c7d2-4c04-bf4d-ecf7db782464", "solution": "import numpy as np\nimport random\nimport operator\n\nclass AdaptiveMOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                if random.random() < self.crossover_rate:\n                    parent1, parent2 = random.sample(selected_individuals, 2)\n                    child = self.adaptive_crossover(parent1, parent2)\n                    child = self.mutation(child)\n                    offspring.append(child)\n                else:\n                    parent1 = random.choice(selected_individuals)\n                    child = parent1\n                    offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            # Refine the strategy by changing individual lines with probability 0.2\n            if random.random() < 0.2:\n                for i in range(self.population_size):\n                    if random.random() < 0.2:\n                        self.population[i] += random.uniform(-0.1, 0.1)\n                        self.population[i] = max(-5.0, min(5.0, self.population[i]))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nadaptive_moe_cbm = AdaptiveMOE_CBM(budget=100, dim=10)\nbest_fitness = adaptive_moe_cbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveMOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 66, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "67e8fafc-a7de-4fd3-ae44-57184b8f437e", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refine_strategy = False\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        if self.refine_strategy:\n            new_population = np.zeros((self.population_size, self.dim))\n            for i in range(self.population_size):\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                if random.random() < 0.2:\n                    child = self.refine_child(child)\n                new_population[i] = child\n            self.population = new_population\n            self.refine_strategy = False\n\n    def refine_child(self, child):\n        # Refine the child by changing one of its dimensions\n        index = random.randint(0, self.dim - 1)\n        child[index] += random.uniform(-1.0, 1.0)\n        child[index] = max(-5.0, min(5.0, child[index]))\n        return child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                if random.random() < self.crossover_rate:\n                    child = self.crossover(child, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine_strategy = True\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based strategy refinement.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2815dfa6-023e-40d3-ab79-70015669895c", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1) * (1 + random.random() * 2 * self.refinement_rate - 1)\n        return child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with refinement strategy", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "c586f8c6-962b-40e5-9a52-00f1994a7aae", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, func):\n        refined_population = []\n        for individual in self.population:\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population.append(child)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = self.refine_strategy(func)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "46440051-0110-44a9-a219-8adf2d02d2b7", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability mutation rate refinement", "configspace": "", "generation": 70, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "eddaf892-d411-4eab-9f66-8e76e83e446d", "solution": "import numpy as np\nimport random\nimport copy\n\nclass MOE_CBM_ProbRefine:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, selected_individuals):\n        refined_population = []\n        for individual in selected_individuals:\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population.append(child)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_population = self.refine(selected_individuals)\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(refined_population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm_probrefine = MOE_CBM_ProbRefine(budget=100, dim=10)\nbest_fitness = moecbm_probrefine.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM_ProbRefine", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization with Probability Refinement\"", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "b467e2af-73c8-4a46-bc0b-d774dd46dee5", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.adaptive_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, selected_individuals):\n        refined_population = []\n        for individual in selected_individuals:\n            if random.random() < self.adaptive_probability:\n                refined_individual = individual + random.uniform(-1.0, 1.0)\n                refined_individual = max(-5.0, min(5.0, refined_individual))\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            refined_population = self.refine_strategy(selected_individuals)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Adaptive Probability for Black Box Optimization\"", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "35857ffc-eeec-48e6-a5b5-439e4b7f1fc7", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, parent1, parent2):\n        if random.random() < 0.2:\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine_strategy(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability crossover and mutation.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "80a3b8fa-f5af-436f-b291-a440d00f6297", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def mutate_line(self, individual, index):\n        if random.random() < 0.2:\n            individual[index] += random.uniform(-1.0, 1.0)\n            individual[index] = max(-5.0, min(5.0, individual[index]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                mutated_child = self.mutate_line(child, random.randint(0, self.dim - 1))\n                offspring.append(mutated_child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability of line mutation.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "e121ba4e-ecf9-41c6-92bc-7af6fbe59abd", "solution": "import numpy as np\nimport random\n\nclass MOPR_BBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_prob = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        if random.random() < self.refine_prob:\n            for i in range(self.dim):\n                individual[i] += random.uniform(-0.5, 0.5)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                child = self.refine(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmopr_bbo = MOPR_BBO(budget=100, dim=10)\nbest_fitness = mopr_bbo.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOPR_BBO", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probabilistic Refinement for Black Box Optimization\" (MOPR-BBO)", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "9b5236d4-5490-49ac-bdfe-9f9fd5b8896b", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        for i in range(self.population_size):\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                self.population[i] = child\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.refine()\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probabilistic refinement", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "60d84c51-dd51-44e4-9a9b-737d84651934", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        new_population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            if random.random() < 0.2:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population[i] = child\n            else:\n                new_population[i] = self.population[i]\n        self.population = new_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            self.refine()\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "a31815cc-bf60-49b0-a56f-4cc9337c69d2", "solution": "import numpy as np\nimport random\nimport copy\n\nclass AdaptiveMOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.adaptive_crossover = self.initialize_adaptive_crossover()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def initialize_adaptive_crossover(self):\n        adaptive_crossover = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            parent1, parent2 = random.sample(range(self.population_size), 2)\n            child = parent1 + parent2 * (parent2 - parent1)\n            adaptive_crossover[i] = child\n        return adaptive_crossover\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        for i in range(self.dim):\n            if random.random() < self.adaptive_crossover[i]:\n                child[i] += random.uniform(-1.0, 1.0)\n                child[i] = max(-5.0, min(5.0, child[i]))\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.adaptive_crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = AdaptiveMOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "AdaptiveMOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2c04fe5a-01c8-421f-86ea-3fef0cf664d0", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self):\n        new_population = np.copy(self.population)\n        for i in range(self.population_size):\n            if random.random() < self.refine_probability:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                new_population[i] = child\n        self.population = new_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.refine_strategy()\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with a probability of 0.2 to refine its strategy.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "3442d5c0-aef6-467f-9c3f-34d15a9e6012", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def adaptive_crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        # Adapt crossover rate based on the distance between parents\n        distance = np.linalg.norm(child - (parent1 + parent2) / 2)\n        if distance < 1.0:\n            self.crossover_rate = 0.5\n        elif distance < 2.0:\n            self.crossover_rate = 0.7\n        else:\n            self.crossover_rate = 0.9\n        child = child * self.crossover_rate + (parent1 - child) * (1 - self.crossover_rate)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.adaptive_crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbam = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbam.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\" (MOE-CBAM)", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "5c73b9af-1013-4bef-b33b-d577976a06ad", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, func):\n        for _ in range(int(self.population_size/2)):\n            parent1, parent2 = random.sample(self.population, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            child = self.refine_individual(child, func)\n            self.population = np.concatenate((self.population, [child]))\n        return np.mean(self.fitness_values)\n\n    def refine_individual(self, individual, func):\n        for _ in range(int(self.mutation_rate * 0.2)):\n            if random.random() < 0.5:\n                individual += random.uniform(-1.0, 1.0)\n                individual = max(-5.0, min(5.0, individual))\n            else:\n                individual -= random.uniform(-1.0, 1.0)\n                individual = max(-5.0, min(5.0, individual))\n        return individual\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.refine_strategy(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "4895e1d7-75aa-4c12-85dd-1f552b70c5d7", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self):\n        refined_population = self.population.copy()\n        for i in range(self.population_size):\n            if random.random() < self.refinement_probability:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                refined_population[i] = child\n        self.population = refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.refine()\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "79c221aa-e347-4555-8cf1-0c590e1d7dbd", "solution": "import numpy as np\nimport random\n\nclass PMOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        if random.random() < self.refine_probability:\n            child = parent1 + parent2 * (parent2 - parent1)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\npmoe_cbm = PMOE_CBM(budget=100, dim=10)\nbest_fitness = pmoe_cbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "PMOE_CBM", "description": "Novel \"Probabilistic Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "73a2a41c-cc7c-47dd-98f2-9306e7181b3c", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        if random.random() < self.refinement_probability:\n            child = parent1 + parent2 * (parent2 - parent1)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "175c3318-8417-47c0-9641-2b2181767fc9", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, parent1, parent2):\n        refinement_probability = 0.2\n        if random.random() < refinement_probability:\n            child = parent1 + parent2 * (parent2 - parent1)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine_strategy(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "d3d519d5-cc46-45d1-8596-b51860633946", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        if random.random() < self.refinement_probability:\n            child = parent1 + parent2 * (parent2 - parent1)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "841b62cd-45b8-4023-b6d2-2eccb32040ac", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.adaptation_rate = 0.2\n        self.adaptation_history = []\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def adapt_crossover(self):\n        if len(self.adaptation_history) > 0:\n            adaptation_rate = self.adaptation_rate * (1 - len(self.adaptation_history) / self.budget)\n        else:\n            adaptation_rate = self.adaptation_rate\n        for i in range(self.population_size):\n            if random.random() < adaptation_rate:\n                parent1, parent2 = random.sample(self.population, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                self.population[i] = child\n        self.adaptation_history.append(len(self.adaptation_history))\n        return self.population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = self.adapt_crossover()\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Adaptive Crossover and Mutation for Black Box Optimization\"", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2cdfb3f8-c4f3-4b81-a46e-1a7ddacfcbe9", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        if random.random() < self.refinement_probability:\n            for i in range(self.dim):\n                individual[i] += random.uniform(-0.5, 0.5)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.refine(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based refinement", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "c1be9bd7-4124-4d10-b7db-7e0d1f63ab6a", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refine_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        if random.random() < self.refine_probability:\n            for i in range(self.dim):\n                individual[i] += random.uniform(-0.5, 0.5)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            self.population = np.array([self.refine(individual) for individual in self.population])\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with refinement probability.", "configspace": "", "generation": 89, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "739df408-1c1a-4f02-a892-2d78be739b18", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM_Probabilistic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.refinement_rate = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, individual):\n        if random.random() < self.refinement_rate:\n            i = random.randint(0, self.dim-1)\n            new_value = random.uniform(-5.0, 5.0)\n            individual[i] = max(-5.0, min(5.0, individual[i] + new_value))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                child = self.refine(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm_probabilistic = MOE_CBM_Probabilistic(budget=100, dim=10)\nbest_fitness = moecbm_probabilistic.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM_Probabilistic", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization with Probabilistic Refinement\"", "configspace": "", "generation": 90, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "f6fc09fc-94bd-4439-a6ec-b54461be830f", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.mutation_probability = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def line_mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_probability:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.line_mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with 20% probability of line mutation.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "d82330e5-b6cf-481f-89da-e577ea6200a8", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n        self.refine_probability = 0.2\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, individual):\n        if random.random() < self.refine_probability:\n            for i in range(self.dim):\n                individual[i] += random.uniform(-0.5, 0.5)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_strategy(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability-based strategy refinement.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "9aab324d-fcce-4606-aab2-f6568940a1a9", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)\n\n# Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with adaptive mutation and crossover rates\n# ```python\nimport numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" (MOE-CBM) with adaptive mutation and crossover rates.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "141998ec-7a11-4b41-8f69-d1c46e18bd05", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < 0.2:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.refine_mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization with 20% Probability Mutation Refinement\"", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "15ec66ea-02fd-4503-b34e-d13772f81989", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n            # Refine the strategy by changing individual lines with a probability of 0.2\n            for i in range(self.population_size):\n                if random.random() < 0.2:\n                    for j in range(self.dim):\n                        self.population[i, j] += random.uniform(-0.5, 0.5)\n                        self.population[i, j] = max(-5.0, min(5.0, self.population[i, j]))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with adaptive mutation rate and crossover probability.", "configspace": "", "generation": 95, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "90c94559-4e40-4699-97f9-d44384bb55cc", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.2\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with 20% probability mutation", "configspace": "", "generation": 96, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "d8866e4e-a0e4-4453-bf60-49654e9cec33", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_solution(self, selected_individuals):\n        refined_population = []\n        for individual in selected_individuals:\n            if random.random() < 0.2:\n                refined_individual = individual + random.uniform(-1.0, 1.0) * (random.uniform(-1.0, 1.0) - random.uniform(-1.0, 1.0))\n                refined_individual = max(-5.0, min(5.0, refined_individual))\n                refined_population.append(refined_individual)\n            else:\n                refined_population.append(individual)\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.crossover(parent1, parent2)\n                child = self.mutation(child)\n                offspring.append(child)\n            refined_population = self.refine_solution(selected_individuals)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover and Mutation for Black Box Optimization\" with probability 0.2 to refine the solution", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "474b3890-3b8d-46d1-a04c-effad85889bc", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.adaptive_probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine_strategy(self, selected_individuals):\n        refined_population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            parent1, parent2 = random.sample(selected_individuals, 2)\n            child = self.crossover(parent1, parent2)\n            child = self.mutation(child)\n            if random.random() < self.adaptive_probability:\n                refined_population[i] = parent1\n            else:\n                refined_population[i] = child\n        return refined_population\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            refined_population = self.refine_strategy(selected_individuals)\n            self.population = np.concatenate((selected_individuals, refined_population))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Adaptive Probability for Black Box Optimization\"", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
{"id": "2968a0c7-6a7c-4914-99a2-990cb4a2016f", "solution": "import numpy as np\nimport random\n\nclass MOE_CBM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.probability = 0.2\n        self.fitness_values = []\n        self.population = self.initialize_population()\n\n    def initialize_population(self):\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            for j in range(self.dim):\n                population[i, j] = random.uniform(-5.0, 5.0)\n        return population\n\n    def evaluate(self, func):\n        self.fitness_values = []\n        for individual in self.population:\n            fitness = func(individual)\n            self.fitness_values.append(fitness)\n\n    def selection(self):\n        sorted_indices = np.argsort(self.fitness_values)\n        selected_indices = sorted_indices[:int(self.population_size/2)]\n        selected_individuals = self.population[sorted_indices[:int(self.population_size/2)]]\n        return selected_individuals\n\n    def crossover(self, parent1, parent2):\n        child = parent1 + parent2 * (parent2 - parent1)\n        return child\n\n    def mutation(self, individual):\n        for i in range(self.dim):\n            if random.random() < self.mutation_rate:\n                individual[i] += random.uniform(-1.0, 1.0)\n                individual[i] = max(-5.0, min(5.0, individual[i]))\n        return individual\n\n    def refine(self, parent1, parent2):\n        if random.random() < self.probability:\n            child = parent1 + parent2 * (parent2 - parent1)\n            child = self.mutation(child)\n            return child\n        else:\n            return parent1\n\n    def optimize(self, func):\n        for _ in range(self.budget):\n            self.evaluate(func)\n            selected_individuals = self.selection()\n            offspring = []\n            for _ in range(int(self.population_size/2)):\n                parent1, parent2 = random.sample(selected_individuals, 2)\n                child = self.refine(parent1, parent2)\n                offspring.append(child)\n            self.population = np.concatenate((selected_individuals, offspring))\n        return np.mean(self.fitness_values)\n\n# Example usage:\ndef func(x):\n    return np.sum(x**2)\n\nmoecbm = MOE_CBM(budget=100, dim=10)\nbest_fitness = moecbm.optimize(func)\nprint(\"Best fitness:\", best_fitness)", "name": "MOE_CBM", "description": "Novel \"Multi-Objective Evolutionary Algorithm with Crossover, Mutation, and Probability-based Refinement for Black Box Optimization\"", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).').", "error": "TypeError('Population must be a sequence.  For dicts or sets, use sorted(d).')", "parent_id": "18c0db0f-efc3-42cd-8b36-e8a8addc17b4", "metadata": {}, "mutation_prompt": null}
