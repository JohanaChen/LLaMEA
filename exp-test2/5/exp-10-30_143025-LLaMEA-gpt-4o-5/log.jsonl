{"id": "c1cc23b0-7772-4a6a-bdb0-0c9d40555cea", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "A hybrid particle swarm optimization with adaptive differential mutation to balance exploration and exploitation while solving black box optimization problems.", "configspace": "", "generation": 0, "fitness": 0.26882279723886976, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6755464439268493, 0.6599543495878428, 0.5931891766203407, 0.6318591733504126, 0.5761809317216096, 0.5047129249057851, 0.69126998050439, 0.6405433475675464, 0.592376518897187, 0.18160146693591728, 0.19945588101073253, 0.16467421670469884, 0.2776156392207795, 0.041089680550226104, 0.14060287389565151, 0.27863096148181976, 0.245404691420274, 0.18147751822723135, 0.09239744894380142, 0.13376025843254413, 0.14384308309426908, 0.1025183050198879, 0.1298101749030025, 0.10806924376125449, 0.11792228259156978, 0.13032834968860074, 0.11572973185030788, 0.13231382298952143, 0.11001304445105742, 0.10939818758867181, 0.12114569525363017, 0.08948279469631581, 0.10511310912894678, 0.09399150213275875, 0.12337371601703528, 0.10497986782521607, 0.961612535169297, 0.9450184523281101, 0.9505846707497135, 0.9385351312089266, 0.9571476812463018, 0.9457875351204383, 0.9624621138837111, 0.9622838705471384, 0.9557936852069443, 0.2823716506192654, 0.3190510378142327, 0.33303854727753546, 0.2879597366420431, 0.2859178435764692, 0.29959786175490066, 0.3077723472091958, 0.2691679691028338, 0.29733570942239207, 0.7476974338333693, 0.6363731783356938, 0.3886005068938455, 0.24772165480586705, 0.2783473673256194, 0.2700961468634179, 0.6221075079489573, 0.5630592001563064, 0.47783916799889525, 0.11616719592134539, 0.2283169220231568, 0.12174462401835151, 0.21137139002762684, 0.17206364347997916, 0.20993518994588944, 0.19932818313367895, 0.23605701315624406, 0.21688548889541404, 0.25530049076560823, 0.2294953643149663, 0.13128256780980496, 0.1817989235136771, 0.18035981632428644, 0.1809674196260267, 0.1449998200409025, 0.2821710076334376, 0.1324788583230342, 0.05542267979662663, 9.999999999998899e-05, 0.1143868092213659, 0.059062478129708884, 0.10026442353160692, 0.027845257316534533, 0.0288460670873536, 0.01018620455550645, 0.03723867550569815, 0.15635511384589917, 0.0982452800382334, 0.15762868694280296, 0.1248609828202043, 0.07698503884592378, 0.07359891395165363, 0.1331910271944624, 0.13106184147420974, 0.10952461486092746, 0.03240599932066979, 0.07848202636626411, 0.04842653383056439, 0.051216855995794286, 0.10401153878604108, 0.12306618995490626, 0.1294123628061099, 0.06799514595383149, 0.048042609923187096, 0.1306351377916002, 0.08717063056427121, 0.13206830059913954, 0.14382532572601525, 0.13570607496909393, 0.1624595146551373, 0.11938039672500267, 0.17192793051800692, 0.11873547159516418, 0.49691071804262976, 0.4887553833378717, 0.4681084618273802, 0.46267348873187386, 0.49343577468567246, 0.4813413104819102, 0.5001126953848567, 0.5441691007019643, 0.49695468832953194, 0.1312158229063336, 0.09094032853172485, 0.117727646099278, 0.150593910025404, 0.09242539695612473, 0.09723425680417008, 0.1264264804260471, 0.10499207753009199, 0.12295525940330065, 0.3165875131541822, 0.29379463318713606, 0.31504550830787803, 0.17997968054121716, 0.34428084870492603, 0.3066069915385832, 0.322090373075929, 0.18821813582140134, 0.23403667624701707, 0.354622213394964, 0.32615357149411806, 0.215075029942003, 0.31364326254296204, 0.3476928026963715, 0.3276498446957665, 0.3118596452970259, 0.356616326113835, 0.3316481227419513, 0.2591957652761363, 0.27106281146665256, 0.25964001568639494, 0.27136203918767354, 0.2246544053047571, 0.22029507080244326, 0.2650537556028958, 0.21446645640932283, 0.2616602191767663, 0.22565898291515463, 0.21428584287296604, 0.19512504607371906, 0.20708732165324695, 0.22329689416566967, 0.18913185611004868, 0.2414335300679341, 0.21984379828301004, 0.18968334708136347, 0.19263784170127496, 0.20197874667609172, 0.2117741832989204, 0.1903123047739842, 0.19918196117826914, 0.212974579923914, 0.19443543917032124, 0.18284571547918826, 0.18631045631523124, 0.12431442688958327, 0.18720629109954057, 0.15404211845512417, 0.8309591665496737, 0.1989505506418472, 0.8192991426363745, 0.7947023993368589, 0.16878186894928637, 0.15318588484833906, 0.8531706451618025, 0.2127110280922232, 0.688673332810919, 0.21032441018936998, 0.16843293084729105, 0.2074664825627417, 0.10496544201059732, 0.6874945087451116, 0.6974092396998233, 0.18520720777170674, 0.1706183718443257, 0.1792751787201109, 0.17407101611869225, 0.1769266393936274, 0.1781918408529134, 0.19213158183195456, 0.19210923271268154, 0.1736669751178802, 0.08256590213296278, 0.0907269040376596, 0.09162205538242485, 0.09329414197891361, 0.07437653149005363, 0.08259286713692526, 0.07178832981557026, 0.08595161850302335, 0.08640257477909796]}, "mutation_prompt": null}
{"id": "3fcfd4b6-4448-4b0c-9e5b-a516ab297b79", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "A hybrid particle swarm optimization with adaptive differential mutation to balance exploration and exploitation while solving black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1cc23b0-7772-4a6a-bdb0-0c9d40555cea", "metadata": {"aucs": [0.6755464439268493, 0.6599543495878428, 0.5931891766203407, 0.6318591733504126, 0.5761809317216096, 0.5047129249057851, 0.69126998050439, 0.6405433475675464, 0.592376518897187, 0.18160146693591728, 0.19945588101073253, 0.16467421670469884, 0.2776156392207795, 0.041089680550226104, 0.14060287389565151, 0.27863096148181976, 0.245404691420274, 0.18147751822723135, 0.09239744894380142, 0.13376025843254413, 0.14384308309426908, 0.1025183050198879, 0.1298101749030025, 0.10806924376125449, 0.11792228259156978, 0.13032834968860074, 0.11572973185030788, 0.13231382298952143, 0.11001304445105742, 0.10939818758867181, 0.12114569525363017, 0.08948279469631581, 0.10511310912894678, 0.09399150213275875, 0.12337371601703528, 0.10497986782521607, 0.961612535169297, 0.9450184523281101, 0.9505846707497135, 0.9385351312089266, 0.9571476812463018, 0.9457875351204383, 0.9624621138837111, 0.9622838705471384, 0.9557936852069443, 0.2823716506192654, 0.3190510378142327, 0.33303854727753546, 0.2879597366420431, 0.2859178435764692, 0.29959786175490066, 0.3077723472091958, 0.2691679691028338, 0.29733570942239207, 0.7476974338333693, 0.6363731783356938, 0.3886005068938455, 0.24772165480586705, 0.2783473673256194, 0.2700961468634179, 0.6221075079489573, 0.5630592001563064, 0.47783916799889525, 0.11616719592134539, 0.2283169220231568, 0.12174462401835151, 0.21137139002762684, 0.17206364347997916, 0.20993518994588944, 0.19932818313367895, 0.23605701315624406, 0.21688548889541404, 0.25530049076560823, 0.2294953643149663, 0.13128256780980496, 0.1817989235136771, 0.18035981632428644, 0.1809674196260267, 0.1449998200409025, 0.2821710076334376, 0.1324788583230342, 0.05542267979662663, 9.999999999998899e-05, 0.1143868092213659, 0.059062478129708884, 0.10026442353160692, 0.027845257316534533, 0.0288460670873536, 0.01018620455550645, 0.03723867550569815, 0.15635511384589917, 0.0982452800382334, 0.15762868694280296, 0.1248609828202043, 0.07698503884592378, 0.07359891395165363, 0.1331910271944624, 0.13106184147420974, 0.10952461486092746, 0.03240599932066979, 0.07848202636626411, 0.04842653383056439, 0.051216855995794286, 0.10401153878604108, 0.12306618995490626, 0.1294123628061099, 0.06799514595383149, 0.048042609923187096, 0.1306351377916002, 0.08717063056427121, 0.13206830059913954, 0.14382532572601525, 0.13570607496909393, 0.1624595146551373, 0.11938039672500267, 0.17192793051800692, 0.11873547159516418, 0.49691071804262976, 0.4887553833378717, 0.4681084618273802, 0.46267348873187386, 0.49343577468567246, 0.4813413104819102, 0.5001126953848567, 0.5441691007019643, 0.49695468832953194, 0.1312158229063336, 0.09094032853172485, 0.117727646099278, 0.150593910025404, 0.09242539695612473, 0.09723425680417008, 0.1264264804260471, 0.10499207753009199, 0.12295525940330065, 0.3165875131541822, 0.29379463318713606, 0.31504550830787803, 0.17997968054121716, 0.34428084870492603, 0.3066069915385832, 0.322090373075929, 0.18821813582140134, 0.23403667624701707, 0.354622213394964, 0.32615357149411806, 0.215075029942003, 0.31364326254296204, 0.3476928026963715, 0.3276498446957665, 0.3118596452970259, 0.356616326113835, 0.3316481227419513, 0.2591957652761363, 0.27106281146665256, 0.25964001568639494, 0.27136203918767354, 0.2246544053047571, 0.22029507080244326, 0.2650537556028958, 0.21446645640932283, 0.2616602191767663, 0.22565898291515463, 0.21428584287296604, 0.19512504607371906, 0.20708732165324695, 0.22329689416566967, 0.18913185611004868, 0.2414335300679341, 0.21984379828301004, 0.18968334708136347, 0.19263784170127496, 0.20197874667609172, 0.2117741832989204, 0.1903123047739842, 0.19918196117826914, 0.212974579923914, 0.19443543917032124, 0.18284571547918826, 0.18631045631523124, 0.12431442688958327, 0.18720629109954057, 0.15404211845512417, 0.8309591665496737, 0.1989505506418472, 0.8192991426363745, 0.7947023993368589, 0.16878186894928637, 0.15318588484833906, 0.8531706451618025, 0.2127110280922232, 0.688673332810919, 0.21032441018936998, 0.16843293084729105, 0.2074664825627417, 0.10496544201059732, 0.6874945087451116, 0.6974092396998233, 0.18520720777170674, 0.1706183718443257, 0.1792751787201109, 0.17407101611869225, 0.1769266393936274, 0.1781918408529134, 0.19213158183195456, 0.19210923271268154, 0.1736669751178802, 0.08256590213296278, 0.0907269040376596, 0.09162205538242485, 0.09329414197891361, 0.07437653149005363, 0.08259286713692526, 0.07178832981557026, 0.08595161850302335, 0.08640257477909796]}, "mutation_prompt": null}
{"id": "855aeb88-5898-4398-b34f-97e4f04d276e", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "A hybrid particle swarm optimization with adaptive differential mutation to balance exploration and exploitation while solving black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1cc23b0-7772-4a6a-bdb0-0c9d40555cea", "metadata": {"aucs": [0.6755464439268493, 0.6599543495878428, 0.5931891766203407, 0.6318591733504126, 0.5761809317216096, 0.5047129249057851, 0.69126998050439, 0.6405433475675464, 0.592376518897187, 0.18160146693591728, 0.19945588101073253, 0.16467421670469884, 0.2776156392207795, 0.041089680550226104, 0.14060287389565151, 0.27863096148181976, 0.245404691420274, 0.18147751822723135, 0.09239744894380142, 0.13376025843254413, 0.14384308309426908, 0.1025183050198879, 0.1298101749030025, 0.10806924376125449, 0.11792228259156978, 0.13032834968860074, 0.11572973185030788, 0.13231382298952143, 0.11001304445105742, 0.10939818758867181, 0.12114569525363017, 0.08948279469631581, 0.10511310912894678, 0.09399150213275875, 0.12337371601703528, 0.10497986782521607, 0.961612535169297, 0.9450184523281101, 0.9505846707497135, 0.9385351312089266, 0.9571476812463018, 0.9457875351204383, 0.9624621138837111, 0.9622838705471384, 0.9557936852069443, 0.2823716506192654, 0.3190510378142327, 0.33303854727753546, 0.2879597366420431, 0.2859178435764692, 0.29959786175490066, 0.3077723472091958, 0.2691679691028338, 0.29733570942239207, 0.7476974338333693, 0.6363731783356938, 0.3886005068938455, 0.24772165480586705, 0.2783473673256194, 0.2700961468634179, 0.6221075079489573, 0.5630592001563064, 0.47783916799889525, 0.11616719592134539, 0.2283169220231568, 0.12174462401835151, 0.21137139002762684, 0.17206364347997916, 0.20993518994588944, 0.19932818313367895, 0.23605701315624406, 0.21688548889541404, 0.25530049076560823, 0.2294953643149663, 0.13128256780980496, 0.1817989235136771, 0.18035981632428644, 0.1809674196260267, 0.1449998200409025, 0.2821710076334376, 0.1324788583230342, 0.05542267979662663, 9.999999999998899e-05, 0.1143868092213659, 0.059062478129708884, 0.10026442353160692, 0.027845257316534533, 0.0288460670873536, 0.01018620455550645, 0.03723867550569815, 0.15635511384589917, 0.0982452800382334, 0.15762868694280296, 0.1248609828202043, 0.07698503884592378, 0.07359891395165363, 0.1331910271944624, 0.13106184147420974, 0.10952461486092746, 0.03240599932066979, 0.07848202636626411, 0.04842653383056439, 0.051216855995794286, 0.10401153878604108, 0.12306618995490626, 0.1294123628061099, 0.06799514595383149, 0.048042609923187096, 0.1306351377916002, 0.08717063056427121, 0.13206830059913954, 0.14382532572601525, 0.13570607496909393, 0.1624595146551373, 0.11938039672500267, 0.17192793051800692, 0.11873547159516418, 0.49691071804262976, 0.4887553833378717, 0.4681084618273802, 0.46267348873187386, 0.49343577468567246, 0.4813413104819102, 0.5001126953848567, 0.5441691007019643, 0.49695468832953194, 0.1312158229063336, 0.09094032853172485, 0.117727646099278, 0.150593910025404, 0.09242539695612473, 0.09723425680417008, 0.1264264804260471, 0.10499207753009199, 0.12295525940330065, 0.3165875131541822, 0.29379463318713606, 0.31504550830787803, 0.17997968054121716, 0.34428084870492603, 0.3066069915385832, 0.322090373075929, 0.18821813582140134, 0.23403667624701707, 0.354622213394964, 0.32615357149411806, 0.215075029942003, 0.31364326254296204, 0.3476928026963715, 0.3276498446957665, 0.3118596452970259, 0.356616326113835, 0.3316481227419513, 0.2591957652761363, 0.27106281146665256, 0.25964001568639494, 0.27136203918767354, 0.2246544053047571, 0.22029507080244326, 0.2650537556028958, 0.21446645640932283, 0.2616602191767663, 0.22565898291515463, 0.21428584287296604, 0.19512504607371906, 0.20708732165324695, 0.22329689416566967, 0.18913185611004868, 0.2414335300679341, 0.21984379828301004, 0.18968334708136347, 0.19263784170127496, 0.20197874667609172, 0.2117741832989204, 0.1903123047739842, 0.19918196117826914, 0.212974579923914, 0.19443543917032124, 0.18284571547918826, 0.18631045631523124, 0.12431442688958327, 0.18720629109954057, 0.15404211845512417, 0.8309591665496737, 0.1989505506418472, 0.8192991426363745, 0.7947023993368589, 0.16878186894928637, 0.15318588484833906, 0.8531706451618025, 0.2127110280922232, 0.688673332810919, 0.21032441018936998, 0.16843293084729105, 0.2074664825627417, 0.10496544201059732, 0.6874945087451116, 0.6974092396998233, 0.18520720777170674, 0.1706183718443257, 0.1792751787201109, 0.17407101611869225, 0.1769266393936274, 0.1781918408529134, 0.19213158183195456, 0.19210923271268154, 0.1736669751178802, 0.08256590213296278, 0.0907269040376596, 0.09162205538242485, 0.09329414197891361, 0.07437653149005363, 0.08259286713692526, 0.07178832981557026, 0.08595161850302335, 0.08640257477909796]}, "mutation_prompt": null}
{"id": "7aec7415-6f07-4fbb-8938-8a4fce7f9e92", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "A hybrid particle swarm optimization with adaptive differential mutation to balance exploration and exploitation while solving black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1cc23b0-7772-4a6a-bdb0-0c9d40555cea", "metadata": {"aucs": [0.6755464439268493, 0.6599543495878428, 0.5931891766203407, 0.6318591733504126, 0.5761809317216096, 0.5047129249057851, 0.69126998050439, 0.6405433475675464, 0.592376518897187, 0.18160146693591728, 0.19945588101073253, 0.16467421670469884, 0.2776156392207795, 0.041089680550226104, 0.14060287389565151, 0.27863096148181976, 0.245404691420274, 0.18147751822723135, 0.09239744894380142, 0.13376025843254413, 0.14384308309426908, 0.1025183050198879, 0.1298101749030025, 0.10806924376125449, 0.11792228259156978, 0.13032834968860074, 0.11572973185030788, 0.13231382298952143, 0.11001304445105742, 0.10939818758867181, 0.12114569525363017, 0.08948279469631581, 0.10511310912894678, 0.09399150213275875, 0.12337371601703528, 0.10497986782521607, 0.961612535169297, 0.9450184523281101, 0.9505846707497135, 0.9385351312089266, 0.9571476812463018, 0.9457875351204383, 0.9624621138837111, 0.9622838705471384, 0.9557936852069443, 0.2823716506192654, 0.3190510378142327, 0.33303854727753546, 0.2879597366420431, 0.2859178435764692, 0.29959786175490066, 0.3077723472091958, 0.2691679691028338, 0.29733570942239207, 0.7476974338333693, 0.6363731783356938, 0.3886005068938455, 0.24772165480586705, 0.2783473673256194, 0.2700961468634179, 0.6221075079489573, 0.5630592001563064, 0.47783916799889525, 0.11616719592134539, 0.2283169220231568, 0.12174462401835151, 0.21137139002762684, 0.17206364347997916, 0.20993518994588944, 0.19932818313367895, 0.23605701315624406, 0.21688548889541404, 0.25530049076560823, 0.2294953643149663, 0.13128256780980496, 0.1817989235136771, 0.18035981632428644, 0.1809674196260267, 0.1449998200409025, 0.2821710076334376, 0.1324788583230342, 0.05542267979662663, 9.999999999998899e-05, 0.1143868092213659, 0.059062478129708884, 0.10026442353160692, 0.027845257316534533, 0.0288460670873536, 0.01018620455550645, 0.03723867550569815, 0.15635511384589917, 0.0982452800382334, 0.15762868694280296, 0.1248609828202043, 0.07698503884592378, 0.07359891395165363, 0.1331910271944624, 0.13106184147420974, 0.10952461486092746, 0.03240599932066979, 0.07848202636626411, 0.04842653383056439, 0.051216855995794286, 0.10401153878604108, 0.12306618995490626, 0.1294123628061099, 0.06799514595383149, 0.048042609923187096, 0.1306351377916002, 0.08717063056427121, 0.13206830059913954, 0.14382532572601525, 0.13570607496909393, 0.1624595146551373, 0.11938039672500267, 0.17192793051800692, 0.11873547159516418, 0.49691071804262976, 0.4887553833378717, 0.4681084618273802, 0.46267348873187386, 0.49343577468567246, 0.4813413104819102, 0.5001126953848567, 0.5441691007019643, 0.49695468832953194, 0.1312158229063336, 0.09094032853172485, 0.117727646099278, 0.150593910025404, 0.09242539695612473, 0.09723425680417008, 0.1264264804260471, 0.10499207753009199, 0.12295525940330065, 0.3165875131541822, 0.29379463318713606, 0.31504550830787803, 0.17997968054121716, 0.34428084870492603, 0.3066069915385832, 0.322090373075929, 0.18821813582140134, 0.23403667624701707, 0.354622213394964, 0.32615357149411806, 0.215075029942003, 0.31364326254296204, 0.3476928026963715, 0.3276498446957665, 0.3118596452970259, 0.356616326113835, 0.3316481227419513, 0.2591957652761363, 0.27106281146665256, 0.25964001568639494, 0.27136203918767354, 0.2246544053047571, 0.22029507080244326, 0.2650537556028958, 0.21446645640932283, 0.2616602191767663, 0.22565898291515463, 0.21428584287296604, 0.19512504607371906, 0.20708732165324695, 0.22329689416566967, 0.18913185611004868, 0.2414335300679341, 0.21984379828301004, 0.18968334708136347, 0.19263784170127496, 0.20197874667609172, 0.2117741832989204, 0.1903123047739842, 0.19918196117826914, 0.212974579923914, 0.19443543917032124, 0.18284571547918826, 0.18631045631523124, 0.12431442688958327, 0.18720629109954057, 0.15404211845512417, 0.8309591665496737, 0.1989505506418472, 0.8192991426363745, 0.7947023993368589, 0.16878186894928637, 0.15318588484833906, 0.8531706451618025, 0.2127110280922232, 0.688673332810919, 0.21032441018936998, 0.16843293084729105, 0.2074664825627417, 0.10496544201059732, 0.6874945087451116, 0.6974092396998233, 0.18520720777170674, 0.1706183718443257, 0.1792751787201109, 0.17407101611869225, 0.1769266393936274, 0.1781918408529134, 0.19213158183195456, 0.19210923271268154, 0.1736669751178802, 0.08256590213296278, 0.0907269040376596, 0.09162205538242485, 0.09329414197891361, 0.07437653149005363, 0.08259286713692526, 0.07178832981557026, 0.08595161850302335, 0.08640257477909796]}, "mutation_prompt": null}
{"id": "b9d46119-69d1-4c32-b038-0d44b2cac2cc", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "A hybrid particle swarm optimization with adaptive differential mutation to balance exploration and exploitation while solving black box optimization problems.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1cc23b0-7772-4a6a-bdb0-0c9d40555cea", "metadata": {"aucs": [0.6755464439268493, 0.6599543495878428, 0.5931891766203407, 0.6318591733504126, 0.5761809317216096, 0.5047129249057851, 0.69126998050439, 0.6405433475675464, 0.592376518897187, 0.18160146693591728, 0.19945588101073253, 0.16467421670469884, 0.2776156392207795, 0.041089680550226104, 0.14060287389565151, 0.27863096148181976, 0.245404691420274, 0.18147751822723135, 0.09239744894380142, 0.13376025843254413, 0.14384308309426908, 0.1025183050198879, 0.1298101749030025, 0.10806924376125449, 0.11792228259156978, 0.13032834968860074, 0.11572973185030788, 0.13231382298952143, 0.11001304445105742, 0.10939818758867181, 0.12114569525363017, 0.08948279469631581, 0.10511310912894678, 0.09399150213275875, 0.12337371601703528, 0.10497986782521607, 0.961612535169297, 0.9450184523281101, 0.9505846707497135, 0.9385351312089266, 0.9571476812463018, 0.9457875351204383, 0.9624621138837111, 0.9622838705471384, 0.9557936852069443, 0.2823716506192654, 0.3190510378142327, 0.33303854727753546, 0.2879597366420431, 0.2859178435764692, 0.29959786175490066, 0.3077723472091958, 0.2691679691028338, 0.29733570942239207, 0.7476974338333693, 0.6363731783356938, 0.3886005068938455, 0.24772165480586705, 0.2783473673256194, 0.2700961468634179, 0.6221075079489573, 0.5630592001563064, 0.47783916799889525, 0.11616719592134539, 0.2283169220231568, 0.12174462401835151, 0.21137139002762684, 0.17206364347997916, 0.20993518994588944, 0.19932818313367895, 0.23605701315624406, 0.21688548889541404, 0.25530049076560823, 0.2294953643149663, 0.13128256780980496, 0.1817989235136771, 0.18035981632428644, 0.1809674196260267, 0.1449998200409025, 0.2821710076334376, 0.1324788583230342, 0.05542267979662663, 9.999999999998899e-05, 0.1143868092213659, 0.059062478129708884, 0.10026442353160692, 0.027845257316534533, 0.0288460670873536, 0.01018620455550645, 0.03723867550569815, 0.15635511384589917, 0.0982452800382334, 0.15762868694280296, 0.1248609828202043, 0.07698503884592378, 0.07359891395165363, 0.1331910271944624, 0.13106184147420974, 0.10952461486092746, 0.03240599932066979, 0.07848202636626411, 0.04842653383056439, 0.051216855995794286, 0.10401153878604108, 0.12306618995490626, 0.1294123628061099, 0.06799514595383149, 0.048042609923187096, 0.1306351377916002, 0.08717063056427121, 0.13206830059913954, 0.14382532572601525, 0.13570607496909393, 0.1624595146551373, 0.11938039672500267, 0.17192793051800692, 0.11873547159516418, 0.49691071804262976, 0.4887553833378717, 0.4681084618273802, 0.46267348873187386, 0.49343577468567246, 0.4813413104819102, 0.5001126953848567, 0.5441691007019643, 0.49695468832953194, 0.1312158229063336, 0.09094032853172485, 0.117727646099278, 0.150593910025404, 0.09242539695612473, 0.09723425680417008, 0.1264264804260471, 0.10499207753009199, 0.12295525940330065, 0.3165875131541822, 0.29379463318713606, 0.31504550830787803, 0.17997968054121716, 0.34428084870492603, 0.3066069915385832, 0.322090373075929, 0.18821813582140134, 0.23403667624701707, 0.354622213394964, 0.32615357149411806, 0.215075029942003, 0.31364326254296204, 0.3476928026963715, 0.3276498446957665, 0.3118596452970259, 0.356616326113835, 0.3316481227419513, 0.2591957652761363, 0.27106281146665256, 0.25964001568639494, 0.27136203918767354, 0.2246544053047571, 0.22029507080244326, 0.2650537556028958, 0.21446645640932283, 0.2616602191767663, 0.22565898291515463, 0.21428584287296604, 0.19512504607371906, 0.20708732165324695, 0.22329689416566967, 0.18913185611004868, 0.2414335300679341, 0.21984379828301004, 0.18968334708136347, 0.19263784170127496, 0.20197874667609172, 0.2117741832989204, 0.1903123047739842, 0.19918196117826914, 0.212974579923914, 0.19443543917032124, 0.18284571547918826, 0.18631045631523124, 0.12431442688958327, 0.18720629109954057, 0.15404211845512417, 0.8309591665496737, 0.1989505506418472, 0.8192991426363745, 0.7947023993368589, 0.16878186894928637, 0.15318588484833906, 0.8531706451618025, 0.2127110280922232, 0.688673332810919, 0.21032441018936998, 0.16843293084729105, 0.2074664825627417, 0.10496544201059732, 0.6874945087451116, 0.6974092396998233, 0.18520720777170674, 0.1706183718443257, 0.1792751787201109, 0.17407101611869225, 0.1769266393936274, 0.1781918408529134, 0.19213158183195456, 0.19210923271268154, 0.1736669751178802, 0.08256590213296278, 0.0907269040376596, 0.09162205538242485, 0.09329414197891361, 0.07437653149005363, 0.08259286713692526, 0.07178832981557026, 0.08595161850302335, 0.08640257477909796]}, "mutation_prompt": null}
{"id": "e845578f-dc62-49c7-84bb-16c1bffc28a5", "solution": "import numpy as np\n\nclass HybridPSO_ADM_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    # Line modified for improved mutation\n                    trial_vector = mutant_vector if func(mutant_vector) < func(self.positions[i]) else self.positions[i]\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM_Refined", "description": "A refined hybrid particle swarm optimization with adaptive differential mutation enhancing mutation diversity for improved search efficiency.", "configspace": "", "generation": 5, "fitness": 0.22142834740524767, "feedback": "The algorithm HybridPSO_ADM_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "c1cc23b0-7772-4a6a-bdb0-0c9d40555cea", "metadata": {"aucs": [0.5057728506315335, 0.5213794949542101, 0.5311102506392473, 0.526730028428293, 0.5306097135947007, 0.5004178611096193, 0.4399342806371215, 0.47768915859687755, 0.40015514662155394, 0.09731219325265827, 0.07810754945393783, 0.024855923495913368, 0.04376598305469248, 0.11089770895043405, 0.028597076466552962, 0.030234899818709193, 0.04078488475084252, 0.06524645924805705, 0.07741913666871592, 0.1017819162324104, 0.08038994045213399, 0.08923567173387859, 0.09939365218636942, 0.09755636441491955, 0.08491280769840281, 0.0929085498732175, 0.08845936461062265, 0.07966530729597598, 0.07122828165148931, 0.04746297395617638, 0.0789228789310018, 0.08919118812064208, 0.07613017259873889, 0.07029879763229763, 0.0741068507863194, 0.07882072392146633, 0.9320357862086515, 0.9037295842634524, 0.9156724714393566, 0.9139500740473296, 0.938844801908201, 0.8803230210140555, 0.9375462538247996, 0.9207337507247042, 0.9382712063292338, 0.2170472096896504, 0.2442873203207514, 0.23262022376992886, 0.23175074732024192, 0.14329091806074667, 0.19961604632321872, 0.24265245983430628, 0.2261118919574172, 0.20889753593925775, 0.5115206721576218, 0.47089789879454447, 0.2336299346601599, 0.6348157127278446, 0.19330769150567806, 0.47073900576182104, 0.2617257100217485, 0.2799875904952519, 0.48350781105262797, 0.1863569994144647, 0.13572145470571617, 0.17550847446086504, 0.1617204175329673, 0.14527362038164615, 0.11946982630292258, 0.18349661681714768, 0.1414065160851129, 0.12576444151855626, 0.1325324886274799, 0.1285351724399899, 0.24985200095909454, 0.18091835677309354, 0.13467716439147115, 0.18895026033042672, 0.2108038615679394, 0.1368990995002508, 0.1306671873673496, 0.00791548656162977, 9.999999999998899e-05, 0.055400247240492195, 0.03199365657781905, 0.07701944034324482, 9.999999999998899e-05, 0.04064397193543534, 9.999999999998899e-05, 0.10569545157426707, 0.15851302421631064, 0.07048210625834128, 0.12541771846808847, 0.10586620368312782, 0.038199328425657764, 0.020416855691554714, 0.12236215110829984, 0.08562064615552811, 0.09840994826180727, 0.00521779805978817, 9.999999999998899e-05, 0.014610296408669843, 0.04718092488888326, 0.01031169848657243, 0.07408413194230656, 0.005943972190474378, 0.047870583125094734, 0.034027394276994194, 0.15915685908788713, 0.12944038680160597, 0.14160193415687028, 0.03120054575161979, 0.004892155718202451, 0.13958848626586096, 0.1785475573904035, 0.04512123104678245, 0.07070144328134353, 0.4435914299914878, 0.41719358893816105, 0.4338559725963259, 0.40165827572403956, 0.43142119441716664, 0.4428536596472009, 0.39713822462199544, 0.4236931360438023, 0.3978141865060615, 0.09099383814909101, 0.091576584832044, 0.07932736331543488, 0.08179677258451834, 0.09776100806821364, 0.10024148192239712, 0.10655196467094796, 0.09813809950878383, 0.09506706713642288, 0.1928921425575153, 0.16825546996113694, 0.2369066520590989, 0.19845292611420173, 0.22987391848940786, 0.17285557702330334, 0.17037407007115435, 0.17740995344186017, 0.17610484232294477, 0.26966271348025805, 0.3210484980940106, 0.25396584388136956, 0.2896819759352004, 0.2944636278704167, 0.2820652001895173, 0.2302056381008889, 0.328519896347488, 0.2856792512903221, 0.2582572922647469, 0.23320965875105715, 0.23693419701940366, 0.18467534303009092, 0.20121112819208387, 0.20875571758619904, 0.20048723249237743, 0.22900784889674908, 0.18901195335597154, 0.2162202059614714, 0.19358973659441703, 0.19645132127636866, 0.20724904819360412, 0.21240162881300162, 0.1892562014248722, 0.19858343662612976, 0.23380645777372833, 0.21262196477826134, 0.17279778867701678, 0.19750290039333385, 0.18567014194273757, 0.19262908798145628, 0.1914422832059317, 0.1810115061188603, 0.17602819280024118, 0.1883432886532802, 0.1742850900594476, 0.17102315338649332, 0.1471504396306924, 0.15118852337893318, 0.6798914139496777, 0.19680769580167046, 0.567657950053804, 0.09931401563754028, 0.1678844347230466, 0.16153953410660593, 0.7160015290787121, 0.20882680796957098, 0.544602532109401, 0.7163923722117558, 0.16730819289400756, 0.19995278226625646, 0.1674572831914909, 0.16400170094624877, 0.5182275667873624, 0.1927680693540742, 0.1781689539982192, 0.18315037254767264, 0.1871890732585484, 0.17665536533704684, 0.17156787932986695, 0.1747931014004931, 0.1811516231990542, 0.17081756605870635, 0.0905106774612725, 0.10166430170019525, 0.0759899280844436, 0.08059888735691823, 0.0825152318350647, 0.08599229544784737, 0.07214654930792552, 0.07047508419402615, 0.08520048559202675]}, "mutation_prompt": null}
{"id": "f96fffa9-927b-412e-bfef-66c49e6e2e61", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Dynamically adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance search dynamics by introducing a dynamic inertia weight to improve convergence speed and solution quality.", "configspace": "", "generation": 6, "fitness": 0.30483822054249793, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "c1cc23b0-7772-4a6a-bdb0-0c9d40555cea", "metadata": {"aucs": [0.7452395394613854, 0.7070494168229561, 0.7283607565754064, 0.7321526172656028, 0.7483426522308709, 0.7197289805958553, 0.7099116430373531, 0.7148052947123562, 0.7162432333482849, 0.45931838175202566, 0.4744655195895524, 0.4552424759727012, 0.41008748832678443, 0.42457927260059336, 0.45244380892414726, 0.4125614551539063, 0.4229639809118553, 0.04768045226300677, 0.12938698624441658, 0.13086064489840465, 0.11408312937068454, 0.09624366662816952, 0.12554246151944082, 0.1372583551189891, 0.116807527126638, 0.1369768107295909, 0.12796493248430418, 0.1231118929138294, 0.09877420860611641, 0.10356832520924308, 0.11853514527732256, 0.1064625056767392, 0.09644319354583164, 0.0944403814985395, 0.13774425488907727, 0.10037055017388319, 0.960229651386316, 0.9449515077249501, 0.9505592009796797, 0.9380808133146306, 0.9571231333899516, 0.9457507218638319, 0.9624306839157186, 0.9622725343819403, 0.955755045452742, 0.4446948186168398, 0.37281437085792035, 0.37835063669119884, 0.44182592653901875, 0.40069185108062444, 0.384357463779316, 0.42270070703788565, 0.3810781418083571, 0.45073059630064716, 0.6684559297816309, 0.6013077554792958, 0.7078535955184747, 0.19186718092234567, 0.34363670981291194, 0.1942396148258997, 0.23404947527719833, 0.3564990721916126, 0.23088759761806465, 0.13106681327091574, 0.13017887970675546, 0.26117152155217516, 0.29437335001999776, 0.3320493062009394, 0.28272014638222054, 0.3925558738466437, 0.3628379540953437, 0.2794800633494411, 0.3972906696776686, 0.2274281256164764, 0.13015660157773856, 0.5008240618914707, 0.37608782268184227, 0.2879771991153338, 0.2554707838835375, 0.2512447371349117, 0.3043596147037938, 0.04856820653174254, 9.999999999998899e-05, 0.1943842075503246, 0.05569727851890183, 0.04262435056923408, 0.06167694560214676, 0.14304170759727808, 0.06441026896739366, 0.09617461637908875, 0.1747414331254653, 0.24325887287868686, 0.2613668169957858, 0.20064702854320926, 0.08748718305427106, 0.12616031315508447, 0.14162969678706594, 0.14929515889388345, 0.18987446877861947, 0.04365495316199319, 0.1474481954731045, 0.05083520173431355, 0.0644388555294767, 0.15345987082452717, 0.16758382817947803, 0.21839668803588597, 0.08084094345445425, 0.05270740124744411, 0.15333291692345408, 0.2077191864019149, 0.1685593922769364, 0.20322620770571498, 0.264587632523652, 0.00601765346574179, 0.1248218107102248, 0.17105774273326246, 0.1627440332674316, 0.6017529519209028, 0.6660881694064238, 0.5098828780240161, 0.5757651728534836, 0.5514003657027681, 0.6892485684579241, 0.6329592520543359, 0.6305016896409579, 0.6175420735097591, 0.13388514565141574, 0.09960194049129678, 0.1082706204384365, 0.10185862907066112, 0.09548820248955014, 0.14609213132222343, 0.10502187796709772, 0.12409176295201674, 0.14115696504048936, 0.2845202220822435, 0.3913546585846469, 0.21448586880428588, 0.28438617508354047, 0.49279952399172455, 0.1898797824288524, 0.2598830002676231, 0.3181366561128417, 0.15734004298348192, 0.4000040032247145, 0.3141192150416535, 0.40788529770674276, 0.3419924841641203, 0.3517132744706507, 0.36233536500614505, 0.2278324080191152, 0.3997104744819604, 0.13911217857141, 0.1622980585789131, 0.28240179428673096, 0.23806874579747694, 0.2189023082749496, 0.29836803517529575, 0.3020048116044072, 0.2391073348700461, 0.23850242491058693, 0.2171321563432932, 0.19736864218718575, 0.20115501811028258, 0.19108328389067286, 0.2099561084945052, 0.2179899084576875, 0.20883407264705556, 0.21879268783619676, 0.2087899614567842, 0.20514487054720953, 0.1985189495269235, 0.22778856291864658, 0.2042258533379414, 0.21448630863469875, 0.19148438121443334, 0.18267063709114495, 0.1929081064629692, 0.18312218914531786, 0.1801885696092379, 0.12577523266852353, 0.18723179935434708, 0.15390619353377621, 0.8458272416788387, 0.19987204174090112, 0.8922179166153674, 0.8924992914522053, 0.16929447855844115, 0.15311721314346938, 0.7816104670273015, 0.2125545327016518, 0.7550818189343727, 0.21198669708253004, 0.16839544168143128, 0.20756967677641058, 0.10494963901380816, 0.8092261742361625, 0.736388544537272, 0.17832350354858606, 0.18352294573069028, 0.1786184944004663, 0.17395116131357446, 0.1779301750171418, 0.1877364180647081, 0.17418003123125358, 0.22527947421928407, 0.1874671027590149, 0.0821192419859803, 0.08885520907293798, 0.09979411942496974, 0.08563882575880544, 0.08536936538052686, 0.09206823169831768, 0.08871101988228802, 0.0927819059480669, 0.07701993128676399]}, "mutation_prompt": null}
{"id": "305b917a-a89c-4255-ae04-3843104a15cd", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance exploration by introducing a chaotic map for inertia weight adaptation to escape local optima.", "configspace": "", "generation": 7, "fitness": 0.3288807720171725, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f96fffa9-927b-412e-bfef-66c49e6e2e61", "metadata": {"aucs": [0.7626510153372054, 0.758361447005451, 0.8019944326822811, 0.7677793482849101, 0.7931794346996555, 0.7635622292717625, 0.7514948172608066, 0.7484923949461122, 0.7883101623287387, 0.5322142548715464, 0.5624569028019182, 0.5216618713809842, 0.47002989455498234, 0.4919098568426227, 0.5384682000245932, 0.3913009330016616, 0.5300223324879814, 0.48432447020592784, 0.1162081469767482, 0.13340951330024764, 0.1168773010712213, 0.11846033227928054, 0.10778302475247725, 0.12659464954367072, 0.13705508107530417, 0.13707259468460997, 0.16562132760889858, 0.10610859987110777, 0.10733115910091184, 0.09356453902082107, 0.10581895909972716, 0.10922857715162715, 0.09728317417077614, 0.09071252288977316, 0.15629168676505356, 0.1432211606816005, 0.9601615280555446, 0.944911968368431, 0.9505456598871816, 0.9340082356989522, 0.9571176511477193, 0.9432334042307653, 0.9624276332858931, 0.962266362802393, 0.955734842146662, 0.49897917390051194, 0.44821616833444267, 0.5188799385504561, 0.4750959910714653, 0.4712398386314056, 0.4117251972063569, 0.5123248389632119, 0.5223674244123975, 0.42292314646936624, 0.781368747691503, 0.7473263088607738, 0.3711229816927809, 0.19196477021715241, 0.8458446341273942, 0.1939419235299482, 0.7844070836772649, 0.584671322464728, 0.34007306603381915, 0.13038543051114848, 0.3581031050411876, 0.12626363344069835, 0.4618915844656579, 0.40446425762571336, 0.13110942702568062, 0.5905599668565662, 0.1318565043954255, 0.3310865859652886, 0.3927349342708635, 0.36209091919141423, 0.1325300045387685, 0.5214298822606174, 0.4061589516623588, 0.24254097825503917, 0.291965346428547, 0.1299901047422769, 0.45946380123262953, 0.04730690047427322, 0.1187249772362704, 0.262362781422513, 0.04490285505790692, 0.08355961206361806, 0.013761221923370037, 0.1429595502107035, 0.08152930726740837, 0.06160145925625071, 0.15837235819992146, 0.20734333966768914, 0.2224588799529409, 0.11146807723087981, 0.015941604392964437, 0.09013960709666302, 0.16094695183253027, 0.17089659925719958, 0.1398865667839897, 0.04026020959377841, 0.15612062898218415, 0.07098250123740724, 0.063184106588979, 0.17467597435941296, 0.14096902963040925, 0.24048019999077008, 0.07146318428838017, 0.05555213749492871, 0.12955754058668956, 0.17128900281598347, 0.24855719779683005, 0.165359437921195, 0.2226724811746269, 0.005995079191471464, 0.15212344221420027, 0.25365410179300785, 0.16245696839781953, 0.6819395454580988, 0.5318227800552272, 0.6794989512110985, 0.617295285186668, 0.5548573237353612, 0.6293543771606405, 0.5608416805340661, 0.5828695142381226, 0.6114995651680801, 0.12994564356809857, 0.14516520129236066, 0.0917139750463748, 0.11197881156813783, 0.08965772120348703, 0.14321221200500733, 0.1439534668157476, 0.12998676065258064, 0.13583784868531368, 0.28977316046810897, 0.40168842820063344, 0.29629657420029243, 0.3077692982841932, 0.4015091977836649, 0.18665367333640692, 0.3723502854155968, 0.5858019069958553, 0.2855384769651841, 0.208684442256452, 0.3114403951323296, 0.19437883292856029, 0.45434518589478456, 0.5063134600768375, 0.43313548059229057, 0.414247787900933, 0.4417503563101861, 0.39975683719505795, 0.3430993398290674, 0.3793402934140939, 0.17721669625543113, 0.29069838447608176, 0.25218565398985715, 0.3590099774992921, 0.1107248914971467, 0.27421807068488613, 0.11007489940269222, 0.21165824443159986, 0.2039292946401039, 0.21647013393278758, 0.2600824692371536, 0.2263595709427746, 0.21508707199236554, 0.2091340560099011, 0.23433401519314667, 0.21690775614561086, 0.1983739301181423, 0.19796934829148172, 0.2119207069181379, 0.1956823220331516, 0.24492936850282077, 0.1903177866887822, 0.20248837575537537, 0.19744227776054224, 0.1921367115502398, 0.12545379052013728, 0.18712503969115069, 0.1538787210515371, 0.8468612684715693, 0.19999362532279286, 0.8831121736882211, 0.8953765821390258, 0.16930962716481424, 0.15330696462509408, 0.8505880794164278, 0.21273798226078255, 0.8289048869606683, 0.21181616231961242, 0.16847115029963167, 0.20876755979248185, 0.10495124919735643, 0.8082549026693703, 0.7368194573552288, 0.17798049094527235, 0.17187562547999202, 0.18123962725669174, 0.17669747154831672, 0.1963996331738178, 0.20890293874683385, 0.1930336545554725, 0.20103422606317256, 0.19999091723625573, 0.08609711393069797, 0.08664696505673186, 0.09903753065446674, 0.09711362364453802, 0.09055709934637457, 0.09921416397718663, 0.08443954156094091, 0.08383891644727104, 0.08988442163823696]}, "mutation_prompt": null}
{"id": "cf749a49-8c7e-4005-a049-342bd395ba73", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve exploitation by introducing a random neighborhood attraction for better local search.", "configspace": "", "generation": 8, "fitness": 0.3671605090975969, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "305b917a-a89c-4255-ae04-3843104a15cd", "metadata": {"aucs": [0.8241008672235293, 0.8311965225389619, 0.8289433730792466, 0.8037206009093094, 0.7875924639244705, 0.8051444920314463, 0.8403036027130719, 0.8115854366876442, 0.8103947904949478, 0.6626318398703405, 0.6302088581057206, 0.5772678064112169, 0.5730746191555753, 0.6561326987410698, 0.6224846805293501, 0.5990286194573077, 0.6243839680359629, 0.6541394839550803, 0.11278705302014713, 0.1349896609681438, 0.11478478144559612, 0.1129570575659189, 0.10464949955231928, 0.10749338586074031, 0.09204475713777904, 0.13594643130212958, 0.11402804215686357, 0.07613362140659952, 0.11238540969835831, 0.09926216037076485, 0.10218048408800062, 0.10887957041090268, 0.10556224221210109, 0.09866807030364777, 0.12755932680178628, 0.08819175748058183, 0.9428185057386761, 0.9406440303349056, 0.9475167841006182, 0.9149884877554674, 0.9184189341134202, 0.9525814924920104, 0.9339460386480938, 0.940553951474462, 0.932784385932915, 0.6178488420919677, 0.5672920529131055, 0.6474745250527725, 0.6047342196761774, 0.25228827570730916, 0.6007920847900382, 0.6247964911975157, 0.6054790255996536, 0.6460670899017689, 0.9061595105033675, 0.23594172462205665, 0.16670647709322983, 0.1908439340556619, 0.27931904079054426, 0.887520012963608, 0.17742792617581615, 0.17619851639328354, 0.23146164793701207, 0.13106296603325684, 0.6785973238001466, 0.7008715633915359, 0.6394133930660912, 0.47452340147489025, 0.545619549934198, 0.46708865319628357, 0.13360878980292457, 0.13310446387016361, 0.5159051862522659, 0.546024484139231, 0.41626944244389985, 0.6099919413995731, 0.5491976040023108, 0.5556359773482187, 0.6168534214758609, 0.4619239465872522, 0.5044886568720911, 0.04007300451625029, 0.10803427790043318, 0.2901789394163441, 0.053847333328186475, 0.31605152355217536, 0.005937077276660596, 0.09168147090670331, 0.04215287560215697, 0.25839121368249873, 0.29571373336205875, 0.38646785765876845, 0.1636841114261508, 0.2104257057616492, 0.09882070305763269, 0.07922821227432308, 0.44991971975429856, 0.3480069326890606, 0.4365667124761292, 0.12378955026262606, 0.1615008092878104, 0.06988055527211923, 0.07141791609594672, 0.1791493361592731, 0.11282531835737741, 0.13029868929999544, 0.15795554345971463, 0.07591848166752557, 0.2220573354120835, 0.26997711000955515, 0.2692796842667864, 0.29842932551980006, 0.2982348119524726, 0.2523479052894154, 0.05335168460798212, 0.08053879097062888, 0.17526741899645892, 0.7805055916658334, 0.6826778849126816, 0.6271483798082663, 0.673229234783296, 0.698427406512544, 0.7580601964037462, 0.6480765999628999, 0.642168367640575, 0.6078937279469265, 0.04290598964331005, 0.08861516067425035, 0.09203722836157435, 0.07246526476974957, 0.1111705830164792, 0.08899494835041388, 0.13968805480245972, 0.14078194372442743, 0.1516282680574217, 0.5019256834143989, 0.5538349412694585, 0.2020532791301679, 0.6389679775262376, 0.25915280917970607, 0.3739316536691384, 0.33193519668180504, 0.2126368549949943, 0.2570834825594269, 0.385700148566648, 0.36324385076069376, 0.4699067932382677, 0.472936505212029, 0.40624522606252356, 0.40797260238053434, 0.571012320947434, 0.49092732083547896, 0.2783974602678535, 0.2910634628601716, 0.2853673547117951, 0.21336891640552658, 0.33767932551727264, 0.27055871262873443, 0.2614923244564379, 0.21621051283961856, 0.27429094778636165, 0.10750873542852912, 0.20944160866156913, 0.21684049062079314, 0.1909147582135826, 0.2179692718022993, 0.2005666676150537, 0.22900879975372934, 0.23340838399996355, 0.22598366328202601, 0.22833327626801836, 0.20553075855086222, 0.19939739080679364, 0.2009529791395912, 0.20283089575769286, 0.21773410534825066, 0.19720435047715645, 0.18594898147684835, 0.22289609425090207, 0.19561469735783343, 0.8938380006185781, 0.18821334904405118, 0.1520891637363202, 0.8895486750160593, 0.19988717987209204, 0.20024067765699616, 0.10847933092007189, 0.20996521148270053, 0.16639197292310604, 0.8639666874828592, 0.21181540243944808, 0.8298416049076068, 0.21218519851099904, 0.8494567042726668, 0.8676838227685837, 0.8508231861525634, 0.8339831799641458, 0.8678779809078759, 0.17736102250505625, 0.2020467395733091, 0.20740126857008934, 0.19748638821649833, 0.19951216291344898, 0.17344523240321874, 0.1736681199986917, 0.17663744093982114, 0.1969869567691792, 0.0982164330974239, 0.1344798933156104, 0.08778622739886521, 0.08384896008347187, 0.07651658396607675, 0.11260366687390999, 0.0846949876770634, 0.08640416002066631, 0.08780550800940523]}, "mutation_prompt": null}
{"id": "25f507b4-ed99-4108-b0f9-2f1aebdd2125", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve exploitation by introducing a random neighborhood attraction for better local search.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8241008672235293, 0.8311965225389619, 0.8289433730792466, 0.8037206009093094, 0.7875924639244705, 0.8051444920314463, 0.8403036027130719, 0.8115854366876442, 0.8103947904949478, 0.6626318398703405, 0.6302088581057206, 0.5772678064112169, 0.5730746191555753, 0.6561326987410698, 0.6224846805293501, 0.5990286194573077, 0.6243839680359629, 0.6541394839550803, 0.11278705302014713, 0.1349896609681438, 0.11478478144559612, 0.1129570575659189, 0.10464949955231928, 0.10749338586074031, 0.09204475713777904, 0.13594643130212958, 0.11402804215686357, 0.07613362140659952, 0.11238540969835831, 0.09926216037076485, 0.10218048408800062, 0.10887957041090268, 0.10556224221210109, 0.09866807030364777, 0.12755932680178628, 0.08819175748058183, 0.9428185057386761, 0.9406440303349056, 0.9475167841006182, 0.9149884877554674, 0.9184189341134202, 0.9525814924920104, 0.9339460386480938, 0.940553951474462, 0.932784385932915, 0.6178488420919677, 0.5672920529131055, 0.6474745250527725, 0.6047342196761774, 0.25228827570730916, 0.6007920847900382, 0.6247964911975157, 0.6054790255996536, 0.6460670899017689, 0.9061595105033675, 0.23594172462205665, 0.16670647709322983, 0.1908439340556619, 0.27931904079054426, 0.887520012963608, 0.17742792617581615, 0.17619851639328354, 0.23146164793701207, 0.13106296603325684, 0.6785973238001466, 0.7008715633915359, 0.6394133930660912, 0.47452340147489025, 0.545619549934198, 0.46708865319628357, 0.13360878980292457, 0.13310446387016361, 0.5159051862522659, 0.546024484139231, 0.41626944244389985, 0.6099919413995731, 0.5491976040023108, 0.5556359773482187, 0.6168534214758609, 0.4619239465872522, 0.5044886568720911, 0.04007300451625029, 0.10803427790043318, 0.2901789394163441, 0.053847333328186475, 0.31605152355217536, 0.005937077276660596, 0.09168147090670331, 0.04215287560215697, 0.25839121368249873, 0.29571373336205875, 0.38646785765876845, 0.1636841114261508, 0.2104257057616492, 0.09882070305763269, 0.07922821227432308, 0.44991971975429856, 0.3480069326890606, 0.4365667124761292, 0.12378955026262606, 0.1615008092878104, 0.06988055527211923, 0.07141791609594672, 0.1791493361592731, 0.11282531835737741, 0.13029868929999544, 0.15795554345971463, 0.07591848166752557, 0.2220573354120835, 0.26997711000955515, 0.2692796842667864, 0.29842932551980006, 0.2982348119524726, 0.2523479052894154, 0.05335168460798212, 0.08053879097062888, 0.17526741899645892, 0.7805055916658334, 0.6826778849126816, 0.6271483798082663, 0.673229234783296, 0.698427406512544, 0.7580601964037462, 0.6480765999628999, 0.642168367640575, 0.6078937279469265, 0.04290598964331005, 0.08861516067425035, 0.09203722836157435, 0.07246526476974957, 0.1111705830164792, 0.08899494835041388, 0.13968805480245972, 0.14078194372442743, 0.1516282680574217, 0.5019256834143989, 0.5538349412694585, 0.2020532791301679, 0.6389679775262376, 0.25915280917970607, 0.3739316536691384, 0.33193519668180504, 0.2126368549949943, 0.2570834825594269, 0.385700148566648, 0.36324385076069376, 0.4699067932382677, 0.472936505212029, 0.40624522606252356, 0.40797260238053434, 0.571012320947434, 0.49092732083547896, 0.2783974602678535, 0.2910634628601716, 0.2853673547117951, 0.21336891640552658, 0.33767932551727264, 0.27055871262873443, 0.2614923244564379, 0.21621051283961856, 0.27429094778636165, 0.10750873542852912, 0.20944160866156913, 0.21684049062079314, 0.1909147582135826, 0.2179692718022993, 0.2005666676150537, 0.22900879975372934, 0.23340838399996355, 0.22598366328202601, 0.22833327626801836, 0.20553075855086222, 0.19939739080679364, 0.2009529791395912, 0.20283089575769286, 0.21773410534825066, 0.19720435047715645, 0.18594898147684835, 0.22289609425090207, 0.19561469735783343, 0.8938380006185781, 0.18821334904405118, 0.1520891637363202, 0.8895486750160593, 0.19988717987209204, 0.20024067765699616, 0.10847933092007189, 0.20996521148270053, 0.16639197292310604, 0.8639666874828592, 0.21181540243944808, 0.8298416049076068, 0.21218519851099904, 0.8494567042726668, 0.8676838227685837, 0.8508231861525634, 0.8339831799641458, 0.8678779809078759, 0.17736102250505625, 0.2020467395733091, 0.20740126857008934, 0.19748638821649833, 0.19951216291344898, 0.17344523240321874, 0.1736681199986917, 0.17663744093982114, 0.1969869567691792, 0.0982164330974239, 0.1344798933156104, 0.08778622739886521, 0.08384896008347187, 0.07651658396607675, 0.11260366687390999, 0.0846949876770634, 0.08640416002066631, 0.08780550800940523]}, "mutation_prompt": null}
{"id": "fc4f8685-bc55-47ef-aac9-b496d68b1e58", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce adaptive neighborhood attraction\n                adaptive_factor = 0.1 * (1 - evaluations / self.budget)\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = adaptive_factor * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance global convergence by introducing an adaptive neighborhood attraction factor.", "configspace": "", "generation": 10, "fitness": 0.3620882656292815, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8060758864716817, 0.8188045932074819, 0.8473510015158366, 0.8541414669179397, 0.8070158483048365, 0.8023129262983382, 0.8325389286459899, 0.8456934464426923, 0.7951470152659683, 0.6215632666413431, 0.5426578247009313, 0.5684906555829443, 0.6648224958943107, 0.6172717461629771, 0.6488451895602807, 0.5440758652868933, 0.6301463146923437, 0.5937295144488094, 0.11020074028368088, 0.15348033775165548, 0.1228830052790123, 0.09004262647992567, 0.09497051931758593, 0.10994814796241736, 0.09330751268668558, 0.13663386723999815, 0.120710274870662, 0.08919265199384718, 0.13827045189717446, 0.07891912103712562, 0.10513586000447672, 0.11134852773887016, 0.1062348139355832, 0.10464706685580494, 0.09927231343495402, 0.09850481933227206, 0.9413276531735766, 0.9408298286003928, 0.9475654171200882, 0.9150979832393948, 0.926507191222708, 0.9525915413756594, 0.9340101624138377, 0.9407345082796926, 0.9330854098871948, 0.5679279123503056, 0.6170658283125292, 0.6258879799487231, 0.6089087645874225, 0.23403527790413436, 0.6274359117438324, 0.6381947713954126, 0.6192657723115584, 0.6231989242084441, 0.8888610130388512, 0.2243446813133103, 0.1675799791874888, 0.21057675589187308, 0.278710626126505, 0.8688789346662523, 0.22931421844929978, 0.20027633164071434, 0.23242419696749106, 0.1308339724845644, 0.6704639724452495, 0.6495356926416609, 0.5315818484447246, 0.5500205649911649, 0.5283216021876775, 0.4580722126709429, 0.13360878153286193, 0.13330552825361286, 0.5972050507776637, 0.4584088588553453, 0.5162678552174991, 0.42718821336032486, 0.4819578109474312, 0.5466101840720983, 0.5508551205552188, 0.5641006362518515, 0.5196742529330443, 0.07765288074666354, 0.11741626495735602, 0.18232917163059548, 0.0548940013664343, 0.07674790717655322, 0.0309087804126692, 0.054471135527621506, 0.0554436375849211, 0.08525341910976836, 0.22837885585538786, 0.13333587403808755, 0.21709664492232472, 0.21328637174363763, 0.21770154370837147, 0.08427944043950919, 0.3651428021804851, 0.22039581445209677, 0.15462996021295117, 0.1382529544994583, 0.14743224202659022, 0.09577173003783723, 0.07304835679215727, 0.26272997636983086, 0.13561794405678285, 0.1091174199390591, 0.1780395324298676, 0.06401686930620165, 0.23002419265531815, 0.20961457387165205, 0.25024089684401374, 0.3742524528859378, 0.14640888609967606, 0.2409799294378212, 0.2618152696885764, 0.08023079765320706, 0.13457109095993347, 0.6972384141929462, 0.6480436939455723, 0.6563160351025521, 0.621564957540635, 0.6527451994673471, 0.7600641470198514, 0.6250311451084256, 0.674745812619671, 0.6698447459502412, 0.04611769024567547, 0.08989347304909845, 0.09383988293391887, 0.11504231162977918, 0.07808522053290778, 0.44141492642026015, 0.11255987879047902, 0.10797316689252479, 0.07716067464799214, 0.2509524660283803, 0.2879550654386548, 0.3877728611157949, 0.359766631647475, 0.2549935732011397, 0.4936105984241145, 0.656705983400268, 0.6961455769195655, 0.1983075643170198, 0.3660776484062158, 0.4044106514936904, 0.2628779484450281, 0.31440620870454417, 0.4575674524484783, 0.4943070320975378, 0.2310169781726279, 0.45208286733860115, 0.38675785841697885, 0.27723468574131604, 0.33900254775541694, 0.17951278303554685, 0.23986585611589206, 0.3976219603520379, 0.3388309538723774, 0.18838998370212978, 0.2481174732569439, 0.19875092538513972, 0.23127434569183247, 0.2241522799488347, 0.2286349083412451, 0.21074050698175828, 0.24604607129169942, 0.2079334593116452, 0.24204895695342377, 0.24343825767138905, 0.21882709534477485, 0.20717385317000303, 0.199142817537996, 0.2404651305576191, 0.19361886285949081, 0.21875104299271875, 0.19834223977023668, 0.18696393727570437, 0.1945401558026315, 0.20157447275172946, 0.9099808539411974, 0.18827852405121404, 0.15266589942545483, 0.8963937730413486, 0.19965531530256897, 0.20006780579513672, 0.10848747063742137, 0.20967640107386631, 0.16637071632385925, 0.87138225405415, 0.21191801925257236, 0.878085716993829, 0.2116071940403047, 0.8378013575172869, 0.872410090298027, 0.8471141774735341, 0.827634215978363, 0.8759676794667939, 0.17426443614100895, 0.1929065612454236, 0.20788387952532073, 0.18707095154137787, 0.18450181002414645, 0.18769936443502544, 0.1766856999910268, 0.1846669956808753, 0.17744058576654642, 0.0951271609937352, 0.08367278928203215, 0.08070723073655117, 0.08322297513331267, 0.08725153937025465, 0.09959310466946658, 0.0915143337772717, 0.08825285048905585, 0.09014773713560664]}, "mutation_prompt": null}
{"id": "53277360-76ce-4a5b-a67b-88fc3aab79b0", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce chaotic inertia weight adjustment and selective mutation to enhance exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.35668590497640185, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8541505076589547, 0.8376051960766965, 0.8663371664464594, 0.8203466730513231, 0.8363278701029161, 0.8262240110402654, 0.8470149823865332, 0.8606805708255622, 0.8430489713423198, 0.707654348372631, 0.6890265647361966, 0.5905052464012778, 0.6950083231663058, 0.6791449126851519, 0.6664342897426027, 0.6757257549516904, 0.6909475659126099, 0.6762217777541084, 0.09514894947968, 0.13179270939207632, 0.07742145512290921, 0.09450698351552311, 0.11139881333555801, 0.10745737275244083, 0.11535648396585507, 0.11652404386152415, 0.09774035541435966, 0.10612788612429525, 0.13196726729085073, 0.07935866635682143, 0.11389944089162929, 0.11593719616480391, 0.08728521109928755, 0.08473178186819552, 0.09913672033050425, 0.09045647593144712, 0.942282665403528, 0.9399701200361998, 0.9474625608044352, 0.9125661634957929, 0.9181615691807739, 0.9542946092895417, 0.9333396070968134, 0.9396456376524399, 0.9338412377908712, 0.693148113331274, 0.6119448728085186, 0.720922296037658, 0.6566529390195244, 0.15295302742640637, 0.6754594557862785, 0.7057643213162578, 0.5866657469781611, 0.6798630902593756, 0.3920279028161835, 0.22437930328740108, 0.14012729165409565, 0.2035335777952726, 0.27772945156277407, 0.3714437417591915, 0.2180788916625609, 0.17765040124585918, 0.22849689883768765, 0.13208090920510418, 0.7084557714241408, 0.677142953109422, 0.648443172141272, 0.5665758441626727, 0.24153298082225272, 0.2561686924622335, 0.13380271758825057, 0.13341740488740417, 0.6426365262537547, 0.4273093230058459, 0.45362124016315974, 0.3472586691471029, 0.3591909464805546, 0.30572719908457957, 0.3170924478885683, 0.5511709017864028, 0.48173956786838945, 0.0044046930268334394, 0.052164284879656075, 0.23400799674297146, 0.04805410541786115, 0.11459165783497705, 0.01834821652003138, 0.026350569973509153, 0.058032529171379243, 0.15494199819080023, 0.15572187223368417, 0.2094404714824244, 0.18391288762329328, 0.10429578319760435, 0.12775126548851878, 0.05725642692468824, 0.2507871494278655, 0.2039679099244568, 0.12135625188269483, 0.07580695426451534, 0.1438741576468512, 0.06859806231564813, 0.07355303791513002, 0.18977598084655778, 0.11147605030063112, 0.09672054544446052, 0.1898141158296388, 0.06723997377693136, 0.20375660523462857, 0.27334711591040084, 0.23482744430779945, 0.3121432722396853, 0.33978639971764635, 0.27444944336496035, 0.24409162589808575, 0.08111723705835061, 0.08116924475649923, 0.6293444019609636, 0.6789162477802926, 0.7847950041481437, 0.6194261758733585, 0.6686301853555693, 0.7796425357364158, 0.7217537346673055, 0.6151173851531087, 0.593811211499665, 0.0725182693948585, 0.10837395153278628, 0.1003135430687555, 0.07802329159070509, 0.08910908536490914, 0.1283305161201913, 0.13790337680040832, 0.15672994287245834, 0.10865292010021477, 0.7369730500546378, 0.6294795617829736, 0.2836206635215416, 0.18513413617894448, 0.4547123102462982, 0.18338870174244737, 0.5947788032077792, 0.2543914651447158, 0.251487320695886, 0.3923001966927048, 0.28568103520482735, 0.3267202606082962, 0.3307005342308018, 0.48110038411403977, 0.3630683491497134, 0.22927976150075646, 0.5233315506970011, 0.484766236063643, 0.2786430505158529, 0.21933127976632827, 0.20699087955695072, 0.43523848249332864, 0.25383545600129565, 0.2748025365521133, 0.2026318580604568, 0.3458050708145459, 0.10366580821517113, 0.20593130732258447, 0.23166975631207698, 0.19814982181367746, 0.23711515310607845, 0.2995683778200693, 0.21676980758468378, 0.2713907736643538, 0.1973542652897674, 0.24050492317333472, 0.2037881952550522, 0.22425729923661852, 0.22331185674373832, 0.6803691980153117, 0.18479487353479152, 0.19664178090469075, 0.19724563456551858, 0.18351537365880066, 0.1938368223519047, 0.9223796079487552, 0.18812126990928546, 0.15180449312734778, 0.9207832046265235, 0.20004366882202584, 0.20031082905771092, 0.10846266965852158, 0.2109613351441072, 0.16545844047511582, 0.8824513972639457, 0.21178397281485928, 0.865934599771201, 0.21238715379576223, 0.8387827616498416, 0.8891547084804501, 0.860833760974734, 0.8586257059701743, 0.8747229176173168, 0.17647156361089378, 0.1764272736261442, 0.1944166813049112, 0.17990874074065488, 0.18703205274922308, 0.18236756035603785, 0.17504641871393833, 0.17829338368817427, 0.19573224860491967, 0.08592707900767071, 0.1165942334730713, 0.0740860648886803, 0.08427347069022328, 0.09601463848777914, 0.13076511712160643, 0.07960778058366413, 0.07529327454748203, 0.09607100927480405]}, "mutation_prompt": null}
{"id": "5baba196-689b-46c2-b8c8-19989cf3b2b5", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve exploitation by introducing a random neighborhood attraction for better local search.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8241008672235293, 0.8311965225389619, 0.8289433730792466, 0.8037206009093094, 0.7875924639244705, 0.8051444920314463, 0.8403036027130719, 0.8115854366876442, 0.8103947904949478, 0.6626318398703405, 0.6302088581057206, 0.5772678064112169, 0.5730746191555753, 0.6561326987410698, 0.6224846805293501, 0.5990286194573077, 0.6243839680359629, 0.6541394839550803, 0.11278705302014713, 0.1349896609681438, 0.11478478144559612, 0.1129570575659189, 0.10464949955231928, 0.10749338586074031, 0.09204475713777904, 0.13594643130212958, 0.11402804215686357, 0.07613362140659952, 0.11238540969835831, 0.09926216037076485, 0.10218048408800062, 0.10887957041090268, 0.10556224221210109, 0.09866807030364777, 0.12755932680178628, 0.08819175748058183, 0.9428185057386761, 0.9406440303349056, 0.9475167841006182, 0.9149884877554674, 0.9184189341134202, 0.9525814924920104, 0.9339460386480938, 0.940553951474462, 0.932784385932915, 0.6178488420919677, 0.5672920529131055, 0.6474745250527725, 0.6047342196761774, 0.25228827570730916, 0.6007920847900382, 0.6247964911975157, 0.6054790255996536, 0.6460670899017689, 0.9061595105033675, 0.23594172462205665, 0.16670647709322983, 0.1908439340556619, 0.27931904079054426, 0.887520012963608, 0.17742792617581615, 0.17619851639328354, 0.23146164793701207, 0.13106296603325684, 0.6785973238001466, 0.7008715633915359, 0.6394133930660912, 0.47452340147489025, 0.545619549934198, 0.46708865319628357, 0.13360878980292457, 0.13310446387016361, 0.5159051862522659, 0.546024484139231, 0.41626944244389985, 0.6099919413995731, 0.5491976040023108, 0.5556359773482187, 0.6168534214758609, 0.4619239465872522, 0.5044886568720911, 0.04007300451625029, 0.10803427790043318, 0.2901789394163441, 0.053847333328186475, 0.31605152355217536, 0.005937077276660596, 0.09168147090670331, 0.04215287560215697, 0.25839121368249873, 0.29571373336205875, 0.38646785765876845, 0.1636841114261508, 0.2104257057616492, 0.09882070305763269, 0.07922821227432308, 0.44991971975429856, 0.3480069326890606, 0.4365667124761292, 0.12378955026262606, 0.1615008092878104, 0.06988055527211923, 0.07141791609594672, 0.1791493361592731, 0.11282531835737741, 0.13029868929999544, 0.15795554345971463, 0.07591848166752557, 0.2220573354120835, 0.26997711000955515, 0.2692796842667864, 0.29842932551980006, 0.2982348119524726, 0.2523479052894154, 0.05335168460798212, 0.08053879097062888, 0.17526741899645892, 0.7805055916658334, 0.6826778849126816, 0.6271483798082663, 0.673229234783296, 0.698427406512544, 0.7580601964037462, 0.6480765999628999, 0.642168367640575, 0.6078937279469265, 0.04290598964331005, 0.08861516067425035, 0.09203722836157435, 0.07246526476974957, 0.1111705830164792, 0.08899494835041388, 0.13968805480245972, 0.14078194372442743, 0.1516282680574217, 0.5019256834143989, 0.5538349412694585, 0.2020532791301679, 0.6389679775262376, 0.25915280917970607, 0.3739316536691384, 0.33193519668180504, 0.2126368549949943, 0.2570834825594269, 0.385700148566648, 0.36324385076069376, 0.4699067932382677, 0.472936505212029, 0.40624522606252356, 0.40797260238053434, 0.571012320947434, 0.49092732083547896, 0.2783974602678535, 0.2910634628601716, 0.2853673547117951, 0.21336891640552658, 0.33767932551727264, 0.27055871262873443, 0.2614923244564379, 0.21621051283961856, 0.27429094778636165, 0.10750873542852912, 0.20944160866156913, 0.21684049062079314, 0.1909147582135826, 0.2179692718022993, 0.2005666676150537, 0.22900879975372934, 0.23340838399996355, 0.22598366328202601, 0.22833327626801836, 0.20553075855086222, 0.19939739080679364, 0.2009529791395912, 0.20283089575769286, 0.21773410534825066, 0.19720435047715645, 0.18594898147684835, 0.22289609425090207, 0.19561469735783343, 0.8938380006185781, 0.18821334904405118, 0.1520891637363202, 0.8895486750160593, 0.19988717987209204, 0.20024067765699616, 0.10847933092007189, 0.20996521148270053, 0.16639197292310604, 0.8639666874828592, 0.21181540243944808, 0.8298416049076068, 0.21218519851099904, 0.8494567042726668, 0.8676838227685837, 0.8508231861525634, 0.8339831799641458, 0.8678779809078759, 0.17736102250505625, 0.2020467395733091, 0.20740126857008934, 0.19748638821649833, 0.19951216291344898, 0.17344523240321874, 0.1736681199986917, 0.17663744093982114, 0.1969869567691792, 0.0982164330974239, 0.1344798933156104, 0.08778622739886521, 0.08384896008347187, 0.07651658396607675, 0.11260366687390999, 0.0846949876770634, 0.08640416002066631, 0.08780550800940523]}, "mutation_prompt": null}
{"id": "b56cd64b-0422-4646-b4db-edbb9fe9dd17", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve exploitation by introducing a random neighborhood attraction for better local search.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8241008672235293, 0.8311965225389619, 0.8289433730792466, 0.8037206009093094, 0.7875924639244705, 0.8051444920314463, 0.8403036027130719, 0.8115854366876442, 0.8103947904949478, 0.6626318398703405, 0.6302088581057206, 0.5772678064112169, 0.5730746191555753, 0.6561326987410698, 0.6224846805293501, 0.5990286194573077, 0.6243839680359629, 0.6541394839550803, 0.11278705302014713, 0.1349896609681438, 0.11478478144559612, 0.1129570575659189, 0.10464949955231928, 0.10749338586074031, 0.09204475713777904, 0.13594643130212958, 0.11402804215686357, 0.07613362140659952, 0.11238540969835831, 0.09926216037076485, 0.10218048408800062, 0.10887957041090268, 0.10556224221210109, 0.09866807030364777, 0.12755932680178628, 0.08819175748058183, 0.9428185057386761, 0.9406440303349056, 0.9475167841006182, 0.9149884877554674, 0.9184189341134202, 0.9525814924920104, 0.9339460386480938, 0.940553951474462, 0.932784385932915, 0.6178488420919677, 0.5672920529131055, 0.6474745250527725, 0.6047342196761774, 0.25228827570730916, 0.6007920847900382, 0.6247964911975157, 0.6054790255996536, 0.6460670899017689, 0.9061595105033675, 0.23594172462205665, 0.16670647709322983, 0.1908439340556619, 0.27931904079054426, 0.887520012963608, 0.17742792617581615, 0.17619851639328354, 0.23146164793701207, 0.13106296603325684, 0.6785973238001466, 0.7008715633915359, 0.6394133930660912, 0.47452340147489025, 0.545619549934198, 0.46708865319628357, 0.13360878980292457, 0.13310446387016361, 0.5159051862522659, 0.546024484139231, 0.41626944244389985, 0.6099919413995731, 0.5491976040023108, 0.5556359773482187, 0.6168534214758609, 0.4619239465872522, 0.5044886568720911, 0.04007300451625029, 0.10803427790043318, 0.2901789394163441, 0.053847333328186475, 0.31605152355217536, 0.005937077276660596, 0.09168147090670331, 0.04215287560215697, 0.25839121368249873, 0.29571373336205875, 0.38646785765876845, 0.1636841114261508, 0.2104257057616492, 0.09882070305763269, 0.07922821227432308, 0.44991971975429856, 0.3480069326890606, 0.4365667124761292, 0.12378955026262606, 0.1615008092878104, 0.06988055527211923, 0.07141791609594672, 0.1791493361592731, 0.11282531835737741, 0.13029868929999544, 0.15795554345971463, 0.07591848166752557, 0.2220573354120835, 0.26997711000955515, 0.2692796842667864, 0.29842932551980006, 0.2982348119524726, 0.2523479052894154, 0.05335168460798212, 0.08053879097062888, 0.17526741899645892, 0.7805055916658334, 0.6826778849126816, 0.6271483798082663, 0.673229234783296, 0.698427406512544, 0.7580601964037462, 0.6480765999628999, 0.642168367640575, 0.6078937279469265, 0.04290598964331005, 0.08861516067425035, 0.09203722836157435, 0.07246526476974957, 0.1111705830164792, 0.08899494835041388, 0.13968805480245972, 0.14078194372442743, 0.1516282680574217, 0.5019256834143989, 0.5538349412694585, 0.2020532791301679, 0.6389679775262376, 0.25915280917970607, 0.3739316536691384, 0.33193519668180504, 0.2126368549949943, 0.2570834825594269, 0.385700148566648, 0.36324385076069376, 0.4699067932382677, 0.472936505212029, 0.40624522606252356, 0.40797260238053434, 0.571012320947434, 0.49092732083547896, 0.2783974602678535, 0.2910634628601716, 0.2853673547117951, 0.21336891640552658, 0.33767932551727264, 0.27055871262873443, 0.2614923244564379, 0.21621051283961856, 0.27429094778636165, 0.10750873542852912, 0.20944160866156913, 0.21684049062079314, 0.1909147582135826, 0.2179692718022993, 0.2005666676150537, 0.22900879975372934, 0.23340838399996355, 0.22598366328202601, 0.22833327626801836, 0.20553075855086222, 0.19939739080679364, 0.2009529791395912, 0.20283089575769286, 0.21773410534825066, 0.19720435047715645, 0.18594898147684835, 0.22289609425090207, 0.19561469735783343, 0.8938380006185781, 0.18821334904405118, 0.1520891637363202, 0.8895486750160593, 0.19988717987209204, 0.20024067765699616, 0.10847933092007189, 0.20996521148270053, 0.16639197292310604, 0.8639666874828592, 0.21181540243944808, 0.8298416049076068, 0.21218519851099904, 0.8494567042726668, 0.8676838227685837, 0.8508231861525634, 0.8339831799641458, 0.8678779809078759, 0.17736102250505625, 0.2020467395733091, 0.20740126857008934, 0.19748638821649833, 0.19951216291344898, 0.17344523240321874, 0.1736681199986917, 0.17663744093982114, 0.1969869567691792, 0.0982164330974239, 0.1344798933156104, 0.08778622739886521, 0.08384896008347187, 0.07651658396607675, 0.11260366687390999, 0.0846949876770634, 0.08640416002066631, 0.08780550800940523]}, "mutation_prompt": null}
{"id": "a0341469-c965-4aef-aa4d-d4ec1f88491c", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve exploitation by introducing a random neighborhood attraction for better local search.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8241008672235293, 0.8311965225389619, 0.8289433730792466, 0.8037206009093094, 0.7875924639244705, 0.8051444920314463, 0.8403036027130719, 0.8115854366876442, 0.8103947904949478, 0.6626318398703405, 0.6302088581057206, 0.5772678064112169, 0.5730746191555753, 0.6561326987410698, 0.6224846805293501, 0.5990286194573077, 0.6243839680359629, 0.6541394839550803, 0.11278705302014713, 0.1349896609681438, 0.11478478144559612, 0.1129570575659189, 0.10464949955231928, 0.10749338586074031, 0.09204475713777904, 0.13594643130212958, 0.11402804215686357, 0.07613362140659952, 0.11238540969835831, 0.09926216037076485, 0.10218048408800062, 0.10887957041090268, 0.10556224221210109, 0.09866807030364777, 0.12755932680178628, 0.08819175748058183, 0.9428185057386761, 0.9406440303349056, 0.9475167841006182, 0.9149884877554674, 0.9184189341134202, 0.9525814924920104, 0.9339460386480938, 0.940553951474462, 0.932784385932915, 0.6178488420919677, 0.5672920529131055, 0.6474745250527725, 0.6047342196761774, 0.25228827570730916, 0.6007920847900382, 0.6247964911975157, 0.6054790255996536, 0.6460670899017689, 0.9061595105033675, 0.23594172462205665, 0.16670647709322983, 0.1908439340556619, 0.27931904079054426, 0.887520012963608, 0.17742792617581615, 0.17619851639328354, 0.23146164793701207, 0.13106296603325684, 0.6785973238001466, 0.7008715633915359, 0.6394133930660912, 0.47452340147489025, 0.545619549934198, 0.46708865319628357, 0.13360878980292457, 0.13310446387016361, 0.5159051862522659, 0.546024484139231, 0.41626944244389985, 0.6099919413995731, 0.5491976040023108, 0.5556359773482187, 0.6168534214758609, 0.4619239465872522, 0.5044886568720911, 0.04007300451625029, 0.10803427790043318, 0.2901789394163441, 0.053847333328186475, 0.31605152355217536, 0.005937077276660596, 0.09168147090670331, 0.04215287560215697, 0.25839121368249873, 0.29571373336205875, 0.38646785765876845, 0.1636841114261508, 0.2104257057616492, 0.09882070305763269, 0.07922821227432308, 0.44991971975429856, 0.3480069326890606, 0.4365667124761292, 0.12378955026262606, 0.1615008092878104, 0.06988055527211923, 0.07141791609594672, 0.1791493361592731, 0.11282531835737741, 0.13029868929999544, 0.15795554345971463, 0.07591848166752557, 0.2220573354120835, 0.26997711000955515, 0.2692796842667864, 0.29842932551980006, 0.2982348119524726, 0.2523479052894154, 0.05335168460798212, 0.08053879097062888, 0.17526741899645892, 0.7805055916658334, 0.6826778849126816, 0.6271483798082663, 0.673229234783296, 0.698427406512544, 0.7580601964037462, 0.6480765999628999, 0.642168367640575, 0.6078937279469265, 0.04290598964331005, 0.08861516067425035, 0.09203722836157435, 0.07246526476974957, 0.1111705830164792, 0.08899494835041388, 0.13968805480245972, 0.14078194372442743, 0.1516282680574217, 0.5019256834143989, 0.5538349412694585, 0.2020532791301679, 0.6389679775262376, 0.25915280917970607, 0.3739316536691384, 0.33193519668180504, 0.2126368549949943, 0.2570834825594269, 0.385700148566648, 0.36324385076069376, 0.4699067932382677, 0.472936505212029, 0.40624522606252356, 0.40797260238053434, 0.571012320947434, 0.49092732083547896, 0.2783974602678535, 0.2910634628601716, 0.2853673547117951, 0.21336891640552658, 0.33767932551727264, 0.27055871262873443, 0.2614923244564379, 0.21621051283961856, 0.27429094778636165, 0.10750873542852912, 0.20944160866156913, 0.21684049062079314, 0.1909147582135826, 0.2179692718022993, 0.2005666676150537, 0.22900879975372934, 0.23340838399996355, 0.22598366328202601, 0.22833327626801836, 0.20553075855086222, 0.19939739080679364, 0.2009529791395912, 0.20283089575769286, 0.21773410534825066, 0.19720435047715645, 0.18594898147684835, 0.22289609425090207, 0.19561469735783343, 0.8938380006185781, 0.18821334904405118, 0.1520891637363202, 0.8895486750160593, 0.19988717987209204, 0.20024067765699616, 0.10847933092007189, 0.20996521148270053, 0.16639197292310604, 0.8639666874828592, 0.21181540243944808, 0.8298416049076068, 0.21218519851099904, 0.8494567042726668, 0.8676838227685837, 0.8508231861525634, 0.8339831799641458, 0.8678779809078759, 0.17736102250505625, 0.2020467395733091, 0.20740126857008934, 0.19748638821649833, 0.19951216291344898, 0.17344523240321874, 0.1736681199986917, 0.17663744093982114, 0.1969869567691792, 0.0982164330974239, 0.1344798933156104, 0.08778622739886521, 0.08384896008347187, 0.07651658396607675, 0.11260366687390999, 0.0846949876770634, 0.08640416002066631, 0.08780550800940523]}, "mutation_prompt": null}
{"id": "493d16d5-9e2a-49ea-a8e1-e4c627a756b7", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                chaotic_term = 0.05 * np.sin(evaluations / self.budget * np.pi)  # New chaotic term\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + chaotic_term)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance exploration by introducing a non-linear chaotic term to particle velocities.", "configspace": "", "generation": 15, "fitness": 0.2630004545436337, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.5490630189565318, 0.5102047550433306, 0.5407133358255254, 0.5657650095247888, 0.5187334579743501, 0.5585257166557851, 0.5108843917035131, 0.5176102628241555, 0.5267713442386206, 0.10451336187450577, 0.08859393196730236, 0.05709836360267995, 0.06269051998916164, 0.08617328913001077, 0.09156668742319163, 0.05662630786076028, 0.06970347290977497, 0.07989211842504429, 0.092022147399492, 0.15097069300342225, 0.12561138963502583, 0.10396177966183318, 0.08146886553752952, 0.11731637545529738, 0.07961657930448529, 0.09061362574191278, 0.10298640801144643, 0.08021544126887525, 0.13138434025674195, 0.09513393064130271, 0.10389263667525994, 0.10585047717404761, 0.0954236536482187, 0.10425687763815117, 0.1336144127518899, 0.08891797843088312, 0.9420667826654631, 0.9310806629934364, 0.9475264681324518, 0.8683845839452489, 0.7871706501037197, 0.9527916906947093, 0.9333912805271227, 0.8883873163637902, 0.9283719636435176, 0.35477386223023244, 0.35373775087021153, 0.3588067549641021, 0.33780750303685203, 0.28963849981622203, 0.41660229148603134, 0.35849033804420916, 0.36587140110051963, 0.3147728901964637, 0.7516870920519344, 0.35552415468726817, 0.19486619742187772, 0.20937873158348197, 0.7490919500497454, 0.8412447366787686, 0.23194273736411164, 0.23120038826084488, 0.20910404008173655, 0.1289352182061142, 0.25096974267823835, 0.31838830275895147, 0.30788516944291344, 0.29352921039242996, 0.2201275641455086, 0.3063298580506316, 0.13080929859702806, 0.1319948913396356, 0.21084696724440632, 0.1968469471713965, 0.20908471366260883, 0.17331528564355647, 0.19265301497496856, 0.23044133974790415, 0.17516319569743832, 0.20733824566534909, 0.1702343016147484, 0.0037132826813373043, 0.08356591336599051, 0.02074656330912461, 0.028750633555323257, 0.14127176749487824, 9.999999999998899e-05, 0.045099363246627555, 0.008472209838184197, 0.11438861408863299, 0.16399943628710845, 0.15247389314662652, 0.12762365280148136, 0.09452113858154787, 0.0774874416532415, 0.06526793900266348, 0.16218827758397636, 0.14329067465123102, 0.13524463820713317, 0.05194602816462868, 9.999999999998899e-05, 0.011635268603324977, 0.03315993821330043, 0.05189327618462758, 0.03641919419073525, 0.02374431975558311, 0.07856036416210632, 0.027883812250802276, 0.13433581919240045, 0.1542405075147073, 0.14729827402722262, 0.1153180688365204, 0.08598056519977759, 0.147455351920166, 0.05408046642099229, 0.07963914363224589, 0.100769208244746, 0.4844020184681782, 0.5078405869623168, 0.5076551662980056, 0.5097981947545442, 0.4429584785626046, 0.4321915985945798, 0.4751318031632169, 0.46733358829904104, 0.4564969161665783, 0.047443916334438674, 0.08325691988178874, 0.08671992863327271, 0.11091250930643948, 0.07661643557198716, 0.09915459488450618, 0.10614151602043043, 0.11719273118380047, 0.13668511908760628, 0.3098103196007531, 0.27047877680131593, 0.3114717464188883, 0.23997294067761143, 0.2779737077662693, 0.19004345353471808, 0.3569683404303773, 0.3045746817663033, 0.23582914754741302, 0.33373199641620666, 0.2863360660512866, 0.2998069947142583, 0.3236940867185779, 0.31234329389528137, 0.2975380673867225, 0.24475151904742454, 0.30872046435056244, 0.25265359057531234, 0.25878233536073825, 0.26282913680539854, 0.16852814678240624, 0.2811807832132387, 0.2571638607356743, 0.28231085561251823, 0.1908642712566716, 0.22842378028375865, 0.11194980088139761, 0.20875989488988467, 0.2162272708542784, 0.20795748676702897, 0.20316590847844018, 0.1968979954701202, 0.20964954553647208, 0.21346242819355066, 0.22452261134709484, 0.22522787696807545, 0.20438961085622354, 0.32089572065192695, 0.23362496787837084, 0.21405051042318324, 0.2200549961725008, 0.19567846401278455, 0.1952747052806194, 0.18631511638867682, 0.19417324197123775, 0.8903106798153103, 0.1881605440072872, 0.15269647802459207, 0.9062878481041529, 0.19992362858120583, 0.20020825082457094, 0.10850856839010281, 0.2108626079740734, 0.16640825848938, 0.7392538143794298, 0.21194289452948123, 0.8265725428415127, 0.21234206396936384, 0.8565764836294579, 0.821768820277581, 0.7507771648384204, 0.6463119058535072, 0.7498218917162611, 0.19000687226348145, 0.18593548051150743, 0.21432965675567928, 0.19771676408419037, 0.19167339705768038, 0.197998968555943, 0.20041468845991728, 0.1793433393079522, 0.17837353327879502, 0.09556814317663631, 0.09059014661659837, 0.07462326369811834, 0.08610925668599045, 0.08754395253790759, 0.10558176055374258, 0.07586262560139279, 0.08255338737885454, 0.07848796950815973]}, "mutation_prompt": null}
{"id": "c2147c8e-0a22-4d8f-b2c5-b78d2cd07fa1", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction\n                neighbor_idx = np.random.choice(self.population_size)\n                neighbor_attraction = 0.1 * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve exploitation by introducing a random neighborhood attraction for better local search.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8241008672235293, 0.8311965225389619, 0.8289433730792466, 0.8037206009093094, 0.7875924639244705, 0.8051444920314463, 0.8403036027130719, 0.8115854366876442, 0.8103947904949478, 0.6626318398703405, 0.6302088581057206, 0.5772678064112169, 0.5730746191555753, 0.6561326987410698, 0.6224846805293501, 0.5990286194573077, 0.6243839680359629, 0.6541394839550803, 0.11278705302014713, 0.1349896609681438, 0.11478478144559612, 0.1129570575659189, 0.10464949955231928, 0.10749338586074031, 0.09204475713777904, 0.13594643130212958, 0.11402804215686357, 0.07613362140659952, 0.11238540969835831, 0.09926216037076485, 0.10218048408800062, 0.10887957041090268, 0.10556224221210109, 0.09866807030364777, 0.12755932680178628, 0.08819175748058183, 0.9428185057386761, 0.9406440303349056, 0.9475167841006182, 0.9149884877554674, 0.9184189341134202, 0.9525814924920104, 0.9339460386480938, 0.940553951474462, 0.932784385932915, 0.6178488420919677, 0.5672920529131055, 0.6474745250527725, 0.6047342196761774, 0.25228827570730916, 0.6007920847900382, 0.6247964911975157, 0.6054790255996536, 0.6460670899017689, 0.9061595105033675, 0.23594172462205665, 0.16670647709322983, 0.1908439340556619, 0.27931904079054426, 0.887520012963608, 0.17742792617581615, 0.17619851639328354, 0.23146164793701207, 0.13106296603325684, 0.6785973238001466, 0.7008715633915359, 0.6394133930660912, 0.47452340147489025, 0.545619549934198, 0.46708865319628357, 0.13360878980292457, 0.13310446387016361, 0.5159051862522659, 0.546024484139231, 0.41626944244389985, 0.6099919413995731, 0.5491976040023108, 0.5556359773482187, 0.6168534214758609, 0.4619239465872522, 0.5044886568720911, 0.04007300451625029, 0.10803427790043318, 0.2901789394163441, 0.053847333328186475, 0.31605152355217536, 0.005937077276660596, 0.09168147090670331, 0.04215287560215697, 0.25839121368249873, 0.29571373336205875, 0.38646785765876845, 0.1636841114261508, 0.2104257057616492, 0.09882070305763269, 0.07922821227432308, 0.44991971975429856, 0.3480069326890606, 0.4365667124761292, 0.12378955026262606, 0.1615008092878104, 0.06988055527211923, 0.07141791609594672, 0.1791493361592731, 0.11282531835737741, 0.13029868929999544, 0.15795554345971463, 0.07591848166752557, 0.2220573354120835, 0.26997711000955515, 0.2692796842667864, 0.29842932551980006, 0.2982348119524726, 0.2523479052894154, 0.05335168460798212, 0.08053879097062888, 0.17526741899645892, 0.7805055916658334, 0.6826778849126816, 0.6271483798082663, 0.673229234783296, 0.698427406512544, 0.7580601964037462, 0.6480765999628999, 0.642168367640575, 0.6078937279469265, 0.04290598964331005, 0.08861516067425035, 0.09203722836157435, 0.07246526476974957, 0.1111705830164792, 0.08899494835041388, 0.13968805480245972, 0.14078194372442743, 0.1516282680574217, 0.5019256834143989, 0.5538349412694585, 0.2020532791301679, 0.6389679775262376, 0.25915280917970607, 0.3739316536691384, 0.33193519668180504, 0.2126368549949943, 0.2570834825594269, 0.385700148566648, 0.36324385076069376, 0.4699067932382677, 0.472936505212029, 0.40624522606252356, 0.40797260238053434, 0.571012320947434, 0.49092732083547896, 0.2783974602678535, 0.2910634628601716, 0.2853673547117951, 0.21336891640552658, 0.33767932551727264, 0.27055871262873443, 0.2614923244564379, 0.21621051283961856, 0.27429094778636165, 0.10750873542852912, 0.20944160866156913, 0.21684049062079314, 0.1909147582135826, 0.2179692718022993, 0.2005666676150537, 0.22900879975372934, 0.23340838399996355, 0.22598366328202601, 0.22833327626801836, 0.20553075855086222, 0.19939739080679364, 0.2009529791395912, 0.20283089575769286, 0.21773410534825066, 0.19720435047715645, 0.18594898147684835, 0.22289609425090207, 0.19561469735783343, 0.8938380006185781, 0.18821334904405118, 0.1520891637363202, 0.8895486750160593, 0.19988717987209204, 0.20024067765699616, 0.10847933092007189, 0.20996521148270053, 0.16639197292310604, 0.8639666874828592, 0.21181540243944808, 0.8298416049076068, 0.21218519851099904, 0.8494567042726668, 0.8676838227685837, 0.8508231861525634, 0.8339831799641458, 0.8678779809078759, 0.17736102250505625, 0.2020467395733091, 0.20740126857008934, 0.19748638821649833, 0.19951216291344898, 0.17344523240321874, 0.1736681199986917, 0.17663744093982114, 0.1969869567691792, 0.0982164330974239, 0.1344798933156104, 0.08778622739886521, 0.08384896008347187, 0.07651658396607675, 0.11260366687390999, 0.0846949876770634, 0.08640416002066631, 0.08780550800940523]}, "mutation_prompt": null}
{"id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance variability in local search by improving neighborhood attraction using adaptive weights.", "configspace": "", "generation": 17, "fitness": 0.37800702570580597, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "cf749a49-8c7e-4005-a049-342bd395ba73", "metadata": {"aucs": [0.8733467222188125, 0.8800468747191462, 0.8531812348582951, 0.840454015936027, 0.8299037298487622, 0.8109743886521407, 0.8286770787553666, 0.8597404359118376, 0.8663899916039026, 0.6191177799019182, 0.5880852218591728, 0.627587663956462, 0.6818349750343362, 0.6594524859439961, 0.6115047961732246, 0.6517608013393613, 0.6475069459105406, 0.662400641655706, 0.14939112263199572, 0.10727947745955968, 0.07015080046530109, 0.11121948280669114, 0.10919964383713154, 0.14450560003031443, 0.09563297146033889, 0.147595692873706, 0.13287292372629778, 0.11727201173350787, 0.1304062480924727, 0.1114144391723928, 0.11308083719315187, 0.11205571913670942, 0.11596189083552877, 0.12570268036517518, 0.15242782222874907, 0.15435615348326215, 0.9465729895271087, 0.9133222589251591, 0.9379110817584627, 0.9112103615248035, 0.9312747438009714, 0.933725117358282, 0.9235396932878119, 0.9517542515969891, 0.915305257577104, 0.6698633721943557, 0.6743253759579035, 0.6496786280197957, 0.6763389474265235, 0.6312069372721105, 0.6880344561221963, 0.6666573379131737, 0.7165726231428746, 0.581027191137065, 0.8946931384458292, 0.20205037412319293, 0.17161111339445978, 0.8793863711448958, 0.8908154088881319, 0.21150333664454812, 0.22684901508636035, 0.23667652027316088, 0.22676523294540096, 0.5710076497341698, 0.1296321930658325, 0.4190540759326655, 0.3481258329494371, 0.6106399827193334, 0.5834691028501139, 0.7016805999658009, 0.13209544363050496, 0.5460626381837632, 0.43743679536027635, 0.4808498103679453, 0.5272021972235336, 0.6014172602147083, 0.4821348585909514, 0.6624744884141491, 0.4781875635609225, 0.6850886218064574, 0.1345073583866686, 0.05498388671135612, 0.05770014000751034, 0.14325245925195718, 0.055953996345619594, 0.24440908904665992, 0.02587387823943932, 0.1260986598102556, 0.166390782724684, 0.16090011995983533, 0.26913413538540876, 0.20976277054369963, 0.30372154965585685, 0.16274958319829025, 0.11386628559068757, 0.16592061369450894, 0.1716258140985919, 0.21089315905188533, 0.23512445583881447, 0.23822912756174408, 0.12272329937716109, 0.13883704870763725, 0.11841252092727428, 0.07109528152532785, 0.15053963128626469, 0.14372653864960172, 0.08431047827895877, 0.06642836904581395, 0.29375006329141207, 0.2682245817425729, 0.20536290796230972, 0.1526648230013108, 0.20172197175254447, 0.22053067171049212, 0.29157251504776405, 0.16894423900308453, 0.17828915535773926, 0.7546123078110993, 0.6213238001537553, 0.6960601326539999, 0.6089320704567374, 0.7460178401337101, 0.633822398589836, 0.6102482812903496, 0.7249060314243856, 0.7747383594921997, 0.09765012550582053, 0.11738124295152053, 0.13853627843951832, 0.10807752753751976, 0.11540437477618892, 0.1482121444370572, 0.1555114337366078, 0.4597110325024494, 0.09176493942765407, 0.41864370867672906, 0.2574068431627575, 0.4336499925885826, 0.36577264420309463, 0.38761626959325435, 0.48370467259261674, 0.33976850209723797, 0.19527709427278028, 0.7050578438827368, 0.4425851272583855, 0.2705344969231148, 0.17125036016645612, 0.4935032152296932, 0.27178993737877877, 0.517483515470511, 0.17167396259657397, 0.5956996180337386, 0.2369078748290443, 0.19955700202080973, 0.4953905086533572, 0.16197332226380035, 0.31121835014601174, 0.24948333364681896, 0.31095737192666395, 0.23345052262396904, 0.2505166850224172, 0.10239842957652379, 0.253195087503579, 0.21828984752636693, 0.24055941262236535, 0.2535205023204693, 0.24118060688201226, 0.22434183055231793, 0.2284765568874787, 0.18316345721409433, 0.22690424985255486, 0.20838517685982738, 0.21874419328519001, 0.19569636942071977, 0.19949164462270752, 0.17947305459203966, 0.19033015737035042, 0.1797589500722051, 0.195873017575527, 0.21847073361452995, 0.9183661547149484, 0.18858406231725766, 0.15343290317095293, 0.11499144575065134, 0.19976647318559027, 0.9080159014925385, 0.8688200639907376, 0.8833700907733931, 0.16766964386120053, 0.8983994261512201, 0.21298712936709807, 0.8900511235794668, 0.21014994794482755, 0.16760188051941582, 0.8650441790589247, 0.8865652563959153, 0.8888029337400365, 0.8942715120952694, 0.172976472909543, 0.19268439846666197, 0.19728169914524496, 0.17195767395566908, 0.17542355516596964, 0.17667606806037062, 0.18579659069970544, 0.1788170271735693, 0.17117527099228713, 0.08750425049183108, 0.0810075590765662, 0.08194494429165933, 0.08405920703027514, 0.08859950513191595, 0.10195756121688049, 0.07925866265179915, 0.10600068200373602, 0.09151640730847155]}, "mutation_prompt": null}
{"id": "17da530f-fcc8-453a-95cf-85b10dd7ace9", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_social_coeff = self.social_coeff  # Added line for dynamic social coefficient\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n\n            self.social_coeff = initial_social_coeff * (1 - evaluations / self.budget)  # Modified line for dynamic social coefficient\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance global exploration by introducing a dynamic social coefficient that decreases over iterations.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'initial_inertia_weight' is not defined\").", "error": "NameError(\"name 'initial_inertia_weight' is not defined\")", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {}, "mutation_prompt": null}
{"id": "483d5309-bfdd-4bd4-8f5d-975ede13e572", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size, max(1, int(self.population_size * evaluations / self.budget)))  # Dynamic neighborhood size\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff * 0.5:  # Adjust mutation probability\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce adaptive mutation control and dynamic neighborhood size for enhancing exploration-exploitation balance.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"non-broadcastable output operand with shape (5,) doesn't match the broadcast shape (1,5)\").", "error": "ValueError(\"non-broadcastable output operand with shape (5,) doesn't match the broadcast shape (1,5)\")", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {}, "mutation_prompt": null}
{"id": "6050e79d-3cb7-4232-8be0-6581b6ecc553", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n\n                # Dynamic velocity clamping based on evaluations\n                dynamic_clamp = (-1.0, 1.0) if evaluations < self.budget / 2 else (-0.5, 0.5)\n                self.velocities[i] = np.clip(self.velocities[i], dynamic_clamp[0], dynamic_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce dynamic velocity clamping based on evaluation progress to enhance convergence and exploration.", "configspace": "", "generation": 20, "fitness": 0.37800702570580597, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {"aucs": [0.8733467222188125, 0.8800468747191462, 0.8531812348582951, 0.840454015936027, 0.8299037298487622, 0.8109743886521407, 0.8286770787553666, 0.8597404359118376, 0.8663899916039026, 0.6191177799019182, 0.5880852218591728, 0.627587663956462, 0.6818349750343362, 0.6594524859439961, 0.6115047961732246, 0.6517608013393613, 0.6475069459105406, 0.662400641655706, 0.14939112263199572, 0.10727947745955968, 0.07015080046530109, 0.11121948280669114, 0.10919964383713154, 0.14450560003031443, 0.09563297146033889, 0.147595692873706, 0.13287292372629778, 0.11727201173350787, 0.1304062480924727, 0.1114144391723928, 0.11308083719315187, 0.11205571913670942, 0.11596189083552877, 0.12570268036517518, 0.15242782222874907, 0.15435615348326215, 0.9465729895271087, 0.9133222589251591, 0.9379110817584627, 0.9112103615248035, 0.9312747438009714, 0.933725117358282, 0.9235396932878119, 0.9517542515969891, 0.915305257577104, 0.6698633721943557, 0.6743253759579035, 0.6496786280197957, 0.6763389474265235, 0.6312069372721105, 0.6880344561221963, 0.6666573379131737, 0.7165726231428746, 0.581027191137065, 0.8946931384458292, 0.20205037412319293, 0.17161111339445978, 0.8793863711448958, 0.8908154088881319, 0.21150333664454812, 0.22684901508636035, 0.23667652027316088, 0.22676523294540096, 0.5710076497341698, 0.1296321930658325, 0.4190540759326655, 0.3481258329494371, 0.6106399827193334, 0.5834691028501139, 0.7016805999658009, 0.13209544363050496, 0.5460626381837632, 0.43743679536027635, 0.4808498103679453, 0.5272021972235336, 0.6014172602147083, 0.4821348585909514, 0.6624744884141491, 0.4781875635609225, 0.6850886218064574, 0.1345073583866686, 0.05498388671135612, 0.05770014000751034, 0.14325245925195718, 0.055953996345619594, 0.24440908904665992, 0.02587387823943932, 0.1260986598102556, 0.166390782724684, 0.16090011995983533, 0.26913413538540876, 0.20976277054369963, 0.30372154965585685, 0.16274958319829025, 0.11386628559068757, 0.16592061369450894, 0.1716258140985919, 0.21089315905188533, 0.23512445583881447, 0.23822912756174408, 0.12272329937716109, 0.13883704870763725, 0.11841252092727428, 0.07109528152532785, 0.15053963128626469, 0.14372653864960172, 0.08431047827895877, 0.06642836904581395, 0.29375006329141207, 0.2682245817425729, 0.20536290796230972, 0.1526648230013108, 0.20172197175254447, 0.22053067171049212, 0.29157251504776405, 0.16894423900308453, 0.17828915535773926, 0.7546123078110993, 0.6213238001537553, 0.6960601326539999, 0.6089320704567374, 0.7460178401337101, 0.633822398589836, 0.6102482812903496, 0.7249060314243856, 0.7747383594921997, 0.09765012550582053, 0.11738124295152053, 0.13853627843951832, 0.10807752753751976, 0.11540437477618892, 0.1482121444370572, 0.1555114337366078, 0.4597110325024494, 0.09176493942765407, 0.41864370867672906, 0.2574068431627575, 0.4336499925885826, 0.36577264420309463, 0.38761626959325435, 0.48370467259261674, 0.33976850209723797, 0.19527709427278028, 0.7050578438827368, 0.4425851272583855, 0.2705344969231148, 0.17125036016645612, 0.4935032152296932, 0.27178993737877877, 0.517483515470511, 0.17167396259657397, 0.5956996180337386, 0.2369078748290443, 0.19955700202080973, 0.4953905086533572, 0.16197332226380035, 0.31121835014601174, 0.24948333364681896, 0.31095737192666395, 0.23345052262396904, 0.2505166850224172, 0.10239842957652379, 0.253195087503579, 0.21828984752636693, 0.24055941262236535, 0.2535205023204693, 0.24118060688201226, 0.22434183055231793, 0.2284765568874787, 0.18316345721409433, 0.22690424985255486, 0.20838517685982738, 0.21874419328519001, 0.19569636942071977, 0.19949164462270752, 0.17947305459203966, 0.19033015737035042, 0.1797589500722051, 0.195873017575527, 0.21847073361452995, 0.9183661547149484, 0.18858406231725766, 0.15343290317095293, 0.11499144575065134, 0.19976647318559027, 0.9080159014925385, 0.8688200639907376, 0.8833700907733931, 0.16766964386120053, 0.8983994261512201, 0.21298712936709807, 0.8900511235794668, 0.21014994794482755, 0.16760188051941582, 0.8650441790589247, 0.8865652563959153, 0.8888029337400365, 0.8942715120952694, 0.172976472909543, 0.19268439846666197, 0.19728169914524496, 0.17195767395566908, 0.17542355516596964, 0.17667606806037062, 0.18579659069970544, 0.1788170271735693, 0.17117527099228713, 0.08750425049183108, 0.0810075590765662, 0.08194494429165933, 0.08405920703027514, 0.08859950513191595, 0.10195756121688049, 0.07925866265179915, 0.10600068200373602, 0.09151640730847155]}, "mutation_prompt": null}
{"id": "d5e1d8e7-8e41-42cd-9a9b-8717a4df755b", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance variability in local search by improving neighborhood attraction using adaptive weights.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {"aucs": [0.8733467222188125, 0.8800468747191462, 0.8531812348582951, 0.840454015936027, 0.8299037298487622, 0.8109743886521407, 0.8286770787553666, 0.8597404359118376, 0.8663899916039026, 0.6191177799019182, 0.5880852218591728, 0.627587663956462, 0.6818349750343362, 0.6594524859439961, 0.6115047961732246, 0.6517608013393613, 0.6475069459105406, 0.662400641655706, 0.14939112263199572, 0.10727947745955968, 0.07015080046530109, 0.11121948280669114, 0.10919964383713154, 0.14450560003031443, 0.09563297146033889, 0.147595692873706, 0.13287292372629778, 0.11727201173350787, 0.1304062480924727, 0.1114144391723928, 0.11308083719315187, 0.11205571913670942, 0.11596189083552877, 0.12570268036517518, 0.15242782222874907, 0.15435615348326215, 0.9465729895271087, 0.9133222589251591, 0.9379110817584627, 0.9112103615248035, 0.9312747438009714, 0.933725117358282, 0.9235396932878119, 0.9517542515969891, 0.915305257577104, 0.6698633721943557, 0.6743253759579035, 0.6496786280197957, 0.6763389474265235, 0.6312069372721105, 0.6880344561221963, 0.6666573379131737, 0.7165726231428746, 0.581027191137065, 0.8946931384458292, 0.20205037412319293, 0.17161111339445978, 0.8793863711448958, 0.8908154088881319, 0.21150333664454812, 0.22684901508636035, 0.23667652027316088, 0.22676523294540096, 0.5710076497341698, 0.1296321930658325, 0.4190540759326655, 0.3481258329494371, 0.6106399827193334, 0.5834691028501139, 0.7016805999658009, 0.13209544363050496, 0.5460626381837632, 0.43743679536027635, 0.4808498103679453, 0.5272021972235336, 0.6014172602147083, 0.4821348585909514, 0.6624744884141491, 0.4781875635609225, 0.6850886218064574, 0.1345073583866686, 0.05498388671135612, 0.05770014000751034, 0.14325245925195718, 0.055953996345619594, 0.24440908904665992, 0.02587387823943932, 0.1260986598102556, 0.166390782724684, 0.16090011995983533, 0.26913413538540876, 0.20976277054369963, 0.30372154965585685, 0.16274958319829025, 0.11386628559068757, 0.16592061369450894, 0.1716258140985919, 0.21089315905188533, 0.23512445583881447, 0.23822912756174408, 0.12272329937716109, 0.13883704870763725, 0.11841252092727428, 0.07109528152532785, 0.15053963128626469, 0.14372653864960172, 0.08431047827895877, 0.06642836904581395, 0.29375006329141207, 0.2682245817425729, 0.20536290796230972, 0.1526648230013108, 0.20172197175254447, 0.22053067171049212, 0.29157251504776405, 0.16894423900308453, 0.17828915535773926, 0.7546123078110993, 0.6213238001537553, 0.6960601326539999, 0.6089320704567374, 0.7460178401337101, 0.633822398589836, 0.6102482812903496, 0.7249060314243856, 0.7747383594921997, 0.09765012550582053, 0.11738124295152053, 0.13853627843951832, 0.10807752753751976, 0.11540437477618892, 0.1482121444370572, 0.1555114337366078, 0.4597110325024494, 0.09176493942765407, 0.41864370867672906, 0.2574068431627575, 0.4336499925885826, 0.36577264420309463, 0.38761626959325435, 0.48370467259261674, 0.33976850209723797, 0.19527709427278028, 0.7050578438827368, 0.4425851272583855, 0.2705344969231148, 0.17125036016645612, 0.4935032152296932, 0.27178993737877877, 0.517483515470511, 0.17167396259657397, 0.5956996180337386, 0.2369078748290443, 0.19955700202080973, 0.4953905086533572, 0.16197332226380035, 0.31121835014601174, 0.24948333364681896, 0.31095737192666395, 0.23345052262396904, 0.2505166850224172, 0.10239842957652379, 0.253195087503579, 0.21828984752636693, 0.24055941262236535, 0.2535205023204693, 0.24118060688201226, 0.22434183055231793, 0.2284765568874787, 0.18316345721409433, 0.22690424985255486, 0.20838517685982738, 0.21874419328519001, 0.19569636942071977, 0.19949164462270752, 0.17947305459203966, 0.19033015737035042, 0.1797589500722051, 0.195873017575527, 0.21847073361452995, 0.9183661547149484, 0.18858406231725766, 0.15343290317095293, 0.11499144575065134, 0.19976647318559027, 0.9080159014925385, 0.8688200639907376, 0.8833700907733931, 0.16766964386120053, 0.8983994261512201, 0.21298712936709807, 0.8900511235794668, 0.21014994794482755, 0.16760188051941582, 0.8650441790589247, 0.8865652563959153, 0.8888029337400365, 0.8942715120952694, 0.172976472909543, 0.19268439846666197, 0.19728169914524496, 0.17195767395566908, 0.17542355516596964, 0.17667606806037062, 0.18579659069970544, 0.1788170271735693, 0.17117527099228713, 0.08750425049183108, 0.0810075590765662, 0.08194494429165933, 0.08405920703027514, 0.08859950513191595, 0.10195756121688049, 0.07925866265179915, 0.10600068200373602, 0.09151640730847155]}, "mutation_prompt": null}
{"id": "5bcdceab-5105-4924-afad-d1413ce957ca", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance variability in local search by improving neighborhood attraction using adaptive weights.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {"aucs": [0.8733467222188125, 0.8800468747191462, 0.8531812348582951, 0.840454015936027, 0.8299037298487622, 0.8109743886521407, 0.8286770787553666, 0.8597404359118376, 0.8663899916039026, 0.6191177799019182, 0.5880852218591728, 0.627587663956462, 0.6818349750343362, 0.6594524859439961, 0.6115047961732246, 0.6517608013393613, 0.6475069459105406, 0.662400641655706, 0.14939112263199572, 0.10727947745955968, 0.07015080046530109, 0.11121948280669114, 0.10919964383713154, 0.14450560003031443, 0.09563297146033889, 0.147595692873706, 0.13287292372629778, 0.11727201173350787, 0.1304062480924727, 0.1114144391723928, 0.11308083719315187, 0.11205571913670942, 0.11596189083552877, 0.12570268036517518, 0.15242782222874907, 0.15435615348326215, 0.9465729895271087, 0.9133222589251591, 0.9379110817584627, 0.9112103615248035, 0.9312747438009714, 0.933725117358282, 0.9235396932878119, 0.9517542515969891, 0.915305257577104, 0.6698633721943557, 0.6743253759579035, 0.6496786280197957, 0.6763389474265235, 0.6312069372721105, 0.6880344561221963, 0.6666573379131737, 0.7165726231428746, 0.581027191137065, 0.8946931384458292, 0.20205037412319293, 0.17161111339445978, 0.8793863711448958, 0.8908154088881319, 0.21150333664454812, 0.22684901508636035, 0.23667652027316088, 0.22676523294540096, 0.5710076497341698, 0.1296321930658325, 0.4190540759326655, 0.3481258329494371, 0.6106399827193334, 0.5834691028501139, 0.7016805999658009, 0.13209544363050496, 0.5460626381837632, 0.43743679536027635, 0.4808498103679453, 0.5272021972235336, 0.6014172602147083, 0.4821348585909514, 0.6624744884141491, 0.4781875635609225, 0.6850886218064574, 0.1345073583866686, 0.05498388671135612, 0.05770014000751034, 0.14325245925195718, 0.055953996345619594, 0.24440908904665992, 0.02587387823943932, 0.1260986598102556, 0.166390782724684, 0.16090011995983533, 0.26913413538540876, 0.20976277054369963, 0.30372154965585685, 0.16274958319829025, 0.11386628559068757, 0.16592061369450894, 0.1716258140985919, 0.21089315905188533, 0.23512445583881447, 0.23822912756174408, 0.12272329937716109, 0.13883704870763725, 0.11841252092727428, 0.07109528152532785, 0.15053963128626469, 0.14372653864960172, 0.08431047827895877, 0.06642836904581395, 0.29375006329141207, 0.2682245817425729, 0.20536290796230972, 0.1526648230013108, 0.20172197175254447, 0.22053067171049212, 0.29157251504776405, 0.16894423900308453, 0.17828915535773926, 0.7546123078110993, 0.6213238001537553, 0.6960601326539999, 0.6089320704567374, 0.7460178401337101, 0.633822398589836, 0.6102482812903496, 0.7249060314243856, 0.7747383594921997, 0.09765012550582053, 0.11738124295152053, 0.13853627843951832, 0.10807752753751976, 0.11540437477618892, 0.1482121444370572, 0.1555114337366078, 0.4597110325024494, 0.09176493942765407, 0.41864370867672906, 0.2574068431627575, 0.4336499925885826, 0.36577264420309463, 0.38761626959325435, 0.48370467259261674, 0.33976850209723797, 0.19527709427278028, 0.7050578438827368, 0.4425851272583855, 0.2705344969231148, 0.17125036016645612, 0.4935032152296932, 0.27178993737877877, 0.517483515470511, 0.17167396259657397, 0.5956996180337386, 0.2369078748290443, 0.19955700202080973, 0.4953905086533572, 0.16197332226380035, 0.31121835014601174, 0.24948333364681896, 0.31095737192666395, 0.23345052262396904, 0.2505166850224172, 0.10239842957652379, 0.253195087503579, 0.21828984752636693, 0.24055941262236535, 0.2535205023204693, 0.24118060688201226, 0.22434183055231793, 0.2284765568874787, 0.18316345721409433, 0.22690424985255486, 0.20838517685982738, 0.21874419328519001, 0.19569636942071977, 0.19949164462270752, 0.17947305459203966, 0.19033015737035042, 0.1797589500722051, 0.195873017575527, 0.21847073361452995, 0.9183661547149484, 0.18858406231725766, 0.15343290317095293, 0.11499144575065134, 0.19976647318559027, 0.9080159014925385, 0.8688200639907376, 0.8833700907733931, 0.16766964386120053, 0.8983994261512201, 0.21298712936709807, 0.8900511235794668, 0.21014994794482755, 0.16760188051941582, 0.8650441790589247, 0.8865652563959153, 0.8888029337400365, 0.8942715120952694, 0.172976472909543, 0.19268439846666197, 0.19728169914524496, 0.17195767395566908, 0.17542355516596964, 0.17667606806037062, 0.18579659069970544, 0.1788170271735693, 0.17117527099228713, 0.08750425049183108, 0.0810075590765662, 0.08194494429165933, 0.08405920703027514, 0.08859950513191595, 0.10195756121688049, 0.07925866265179915, 0.10600068200373602, 0.09151640730847155]}, "mutation_prompt": null}
{"id": "90fd8ccc-d45c-4157-b3e9-b6b83e3ef386", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            # Dynamically adjust cognitive and social coefficients\n            dynamic_coeff = 0.5 * (1 + np.sin(evaluations / self.budget * np.pi))\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = (self.cognitive_coeff * dynamic_coeff) * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = (self.social_coeff * dynamic_coeff) * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve search diversity by dynamically adjusting the cognitive and social coefficients using a sinusoidal function.", "configspace": "", "generation": 23, "fitness": 0.311902717063187, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {"aucs": [0.8891732145891952, 0.8625831506708833, 0.8955752526009111, 0.8736935349924614, 0.8777251347456158, 0.8832134957343659, 0.8631476867638224, 0.8923128728598103, 0.8653521256157866, 0.34084017543702894, 0.7254086966158357, 0.27716366606612597, 0.7196440172406224, 0.6514062474670237, 0.7394371471543126, 0.753829421267604, 0.673754338069292, 0.18933732050201468, 0.08735071977771969, 0.0851290599563641, 0.09206375665411748, 0.13338067340013893, 0.12215029426911939, 0.11167637693791244, 0.14436958649938825, 0.11447987026051609, 0.11826232834354411, 0.09524857640383655, 0.09475350857544418, 0.07408622048744762, 0.11085132634979966, 0.10387078803798977, 0.05663807565456591, 0.12952536859365993, 0.08217053264490937, 0.11675797423141598, 0.9434696560814251, 0.8941343534499339, 0.9287695625627271, 0.900539658231963, 0.9059383600443786, 0.8479545674969853, 0.9318639058216386, 0.9456849125582137, 0.9168515293390325, 0.4665974934953515, 0.6693731051577128, 0.7745703700391643, 0.7182413384231392, 0.16896463206653367, 0.7663641148174313, 0.4660250632639025, 0.6295093011365598, 0.6089791781233838, 0.21704914130968522, 0.14095174639361407, 0.20872774100851255, 0.2811611257955112, 0.2755038611305758, 0.21407649339343393, 0.23477826610908203, 0.15094828700053875, 0.1392400393370774, 0.22175231357780412, 0.15472864662733954, 0.1727002753634873, 0.15484924460745553, 0.18005188527126137, 0.19760740486007256, 0.5107087813934073, 0.1328771486434276, 0.1525854801624329, 0.19411344861897006, 0.20704255543436278, 0.13631554998600282, 0.2603951220643216, 0.1537016857104554, 0.2445399693410163, 0.24539458451653295, 0.1339407364769597, 0.12916962545279753, 0.03558285284955942, 9.999999999998899e-05, 0.025798145395114935, 0.11101461458773587, 0.1200518064843078, 9.999999999998899e-05, 0.11371089474649654, 0.03394621817603971, 0.12380692432200391, 0.1601186129104688, 0.0948838695991806, 0.17017098188594482, 0.3827527317810707, 0.10602093491415254, 0.054462464075306305, 0.18500624113265918, 0.2140024782081208, 0.10737374487895357, 0.11351717491546309, 0.2143802990474738, 0.07025361194858215, 0.09446452755035284, 0.07380376322230664, 0.1298608418678595, 0.18228049963958193, 0.09662056788282825, 0.07852694375512526, 0.08551369959144228, 0.2460680116169941, 0.1567006543549876, 0.02387956982676731, 0.2941700563668138, 0.017756134599560935, 0.11137859108359338, 0.09994994974177884, 0.09029876991154329, 0.5629266178689155, 0.6679316406340353, 0.5906224328660996, 0.6339129819629337, 0.585734561957177, 0.5668564363500117, 0.6391481096297977, 0.6503237735737956, 0.6461155913476597, 0.05835934671565679, 0.08915091370725459, 0.12520047774667564, 0.12263287460192185, 0.09176153188690717, 0.11081186919194008, 0.11174140170529268, 0.6761952147710926, 0.15819802734343014, 0.25551081409789655, 0.2610097170776571, 0.5520214840894513, 0.20044100212765503, 0.5334489708897362, 0.20625230992196697, 0.552803425824659, 0.20386993658580566, 0.15181575475714204, 0.15794696899552563, 0.3356984075340025, 0.18637990669636129, 0.339672580244998, 0.2783526568446416, 0.2664823738201543, 0.1823016337654022, 0.2423105534614164, 0.13968683040365526, 0.1111650533681352, 0.2992329027155195, 0.2004367656895184, 0.21956949547185278, 0.26772162929186694, 0.2564461581711508, 0.155763318005552, 0.3230167948243876, 0.11442446061050227, 0.2066259011929581, 0.20863358775491192, 0.2236866944385021, 0.25412017979192836, 0.21769682683506686, 0.20896888534488034, 0.2166279623506111, 0.22211379155335909, 0.2680490321714628, 0.1817962191899084, 0.19956162423195478, 0.1892715941779357, 0.17308913643593693, 0.1866425974874344, 0.1903829835463604, 0.20858756317037996, 0.19284287682524126, 0.17878668351935045, 0.9442507711910149, 0.18828366195146518, 0.15380812545327693, 0.933496084752609, 0.1985817116595091, 0.9286757175393884, 0.9189898728870948, 0.905555943590437, 0.15375426318755692, 0.8960186548111827, 0.21284232254849123, 0.7256983027570755, 0.2106859258853876, 0.16752209480515867, 0.2087907457582614, 0.10492129791065508, 0.7635654579795256, 0.42597054901811016, 0.195319637184167, 0.20003684695448942, 0.1851741688195021, 0.18403417449325465, 0.17282290011703283, 0.17794805407860737, 0.18888555835353737, 0.19856199859237267, 0.1971602493235598, 0.09651024863532276, 0.09116497167651505, 0.10100492727046895, 0.09108693903336784, 0.0693004321113323, 0.09278006567436625, 0.10527125897182998, 0.09916838348122148, 0.08102273798946458]}, "mutation_prompt": null}
{"id": "35ce3612-edf8-4b85-9da3-b43e1f755be1", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        initial_inertia_weight = self.inertia_weight\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a chaotic map to adjust the inertia weight\n            self.inertia_weight = initial_inertia_weight * (1 - np.sin(evaluations / self.budget * np.pi / 2))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                # Change (1/3): Dynamic social coefficient decreasing over time\n                dynamic_social_coeff = self.social_coeff * (1 - evaluations / self.budget)\n                social_component = dynamic_social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Improve global exploration by introducing a dynamic social coefficient that decreases over time.", "configspace": "", "generation": 24, "fitness": 0.37660632973223857, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {"aucs": [0.841585495608455, 0.8651855057159126, 0.8660100321018686, 0.8606902124342909, 0.8460506607832265, 0.8569298457273891, 0.8189519701613599, 0.8562489498498768, 0.8547072328469059, 0.6292497352751946, 0.6220403138549006, 0.6316671407570471, 0.6316419959553988, 0.6227915073380754, 0.6497998823751435, 0.6273303778390106, 0.6790462795436829, 0.6643732473556192, 0.1279900188871308, 0.09347185715770023, 0.07040157472816466, 0.11573316329351235, 0.14034520993794974, 0.11123285520400517, 0.10620101564727413, 0.11695381561382823, 0.18074722398082066, 0.11414717302606281, 0.12978095270031442, 0.0929666861952082, 0.09514501735162029, 0.1278758340608307, 0.10961139890558536, 0.12973103895581628, 0.10837461896484002, 0.12570390656949604, 0.9476292834298565, 0.9142251334821736, 0.9377132368045841, 0.9109911174012992, 0.9312422288775482, 0.9333122226382079, 0.9235077196281907, 0.95175420409538, 0.9075123503011638, 0.6908391515755461, 0.7187418280842989, 0.6558928254654162, 0.6656445567446954, 0.647132277637853, 0.6779562468240085, 0.6974048698504907, 0.716918848134762, 0.6493349251058607, 0.3925414594098572, 0.21739489138636514, 0.17161111339445978, 0.872376853112383, 0.8926948007522802, 0.21175363790811175, 0.19227529180688097, 0.860154812196986, 0.23122075321762037, 0.33258074708754315, 0.46236193729692965, 0.5432446621329976, 0.2676269539765993, 0.6526683707788272, 0.5132605027423212, 0.6691175762795645, 0.13093588756506547, 0.2976374610284819, 0.2641710631332558, 0.4791114313425131, 0.40928956595253807, 0.6661941748843425, 0.6535960663438096, 0.5516953115368987, 0.3166555145492763, 0.7440453673045009, 0.13408485438664997, 0.087543590975517, 0.06966054927439946, 0.08795355556052509, 0.05752480987033615, 0.046019090501458915, 0.019127915465748657, 0.12937429416394386, 0.09414729222084606, 0.1730894948422772, 0.18144639059282697, 0.20561928181820233, 0.2826333029636663, 0.09665489532421145, 0.11920619206978023, 0.08550590287854354, 0.15107210726063824, 0.14040538813042203, 0.12746613348576052, 0.2539251415337501, 0.10765093732719566, 0.11464971562505966, 0.11639519973971768, 0.072153614687256, 0.13975814579715407, 0.20285891957766466, 0.08177328844938969, 0.06584989308740663, 0.19139128618430312, 0.41405801278635956, 0.32181886805004967, 0.18460551655601887, 0.24903013858827516, 0.20785498585697681, 0.2332117636269586, 0.20534572655095684, 0.17058126697528642, 0.7902495008623529, 0.665780034839502, 0.6155252837998391, 0.6023785875177954, 0.6843454242982516, 0.6452790150347865, 0.6351377863405688, 0.5797383780096904, 0.6814010927226628, 0.09912022412012667, 0.13219275283356258, 0.11285433941552747, 0.1567149214798128, 0.13218161821894592, 0.1231174598412692, 0.08737281077017467, 0.15190960148627286, 0.15082088881647304, 0.6962690049686093, 0.4482034275967196, 0.728630300556854, 0.2984736062672634, 0.26687900710162427, 0.5921219185769964, 0.4918721555336639, 0.4580463707610215, 0.49990318353587737, 0.4081914376223468, 0.5327447352786492, 0.2334298589313275, 0.4661160896048381, 0.2842171479250465, 0.3773785743032224, 0.16837088417892987, 0.4958533487286728, 0.27544129802021255, 0.1965441895894341, 0.3141082523683253, 0.1491570306770753, 0.40689862753866834, 0.3795585701685348, 0.3148676575250908, 0.2591854484109244, 0.24594373635764022, 0.10631918445427724, 0.20142435647933477, 0.22912503890040048, 0.22921948830912253, 0.20124517551556687, 0.23289978821779045, 0.21118052993043646, 0.2805811560386644, 0.24710990951862655, 0.2209258349897012, 0.1924357771241988, 0.21987072989778422, 0.2354707758848238, 0.22359748134739443, 0.18767851494537358, 0.18762164253246605, 0.20263201700483946, 0.1893437720251231, 0.1984010510332208, 0.9093252638877534, 0.1885862955117794, 0.1534533329704123, 0.11499092474317585, 0.1998107949789022, 0.9157095903954773, 0.8895872017009083, 0.8881869162318291, 0.1677875926545117, 0.9146901419212482, 0.2130418632024753, 0.8925990193321213, 0.2102552772283257, 0.16762381224523926, 0.8550682476819953, 0.8921411370676302, 0.8539515689520673, 0.8517144404079634, 0.17899749549696575, 0.18832735671391287, 0.17918320859290104, 0.17975117315942535, 0.17220585396172083, 0.17188502840830622, 0.1850748555786519, 0.17408170292109448, 0.180702249824227, 0.084943045667904, 0.07690816496150199, 0.08750690803770722, 0.0898587389645874, 0.08308103287054092, 0.10401176232062104, 0.10838524570527497, 0.0844170977876253, 0.09138463070160685]}, "mutation_prompt": null}
{"id": "29ac5932-2840-4675-8dab-c9a6746a7e9e", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a sinusoidal map to adjust the inertia weight\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a sinusoidal inertia weight adjustment for more diverse exploration through varying momentum. ", "configspace": "", "generation": 25, "fitness": 0.37861472434255083, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "12a6f552-c2ce-4124-94d3-cbd15bc21cfa", "metadata": {"aucs": [0.8671601134017389, 0.888085114620206, 0.884927264560184, 0.8447535077485967, 0.8834164289173586, 0.876325917020082, 0.8738786245056805, 0.8747536589046179, 0.8593022907279638, 0.7210651273209338, 0.6550580593491495, 0.6495764267889143, 0.6967787197064065, 0.6936974054333418, 0.5654258197184069, 0.5628093810644141, 0.572599040211077, 0.7377367530727303, 0.08369854118642017, 0.11635247026794693, 0.07778208400781927, 0.11718055185561882, 0.12174852699881089, 0.1331752276084197, 0.1153809460877494, 0.09482195308240737, 0.10847789264454388, 0.09177265189459327, 0.10714076320974675, 0.10106353374426913, 0.11350352217946369, 0.10432455735815671, 0.09128939850081497, 0.09573840421574442, 0.08213861897419628, 0.09553716297621884, 0.9409061386000807, 0.9111828825977696, 0.9271909482740286, 0.9180680094799979, 0.925662361537723, 0.8939051460657357, 0.9235196105091977, 0.945263809595637, 0.8845837245697347, 0.6568947613438703, 0.656055862507793, 0.5655394068204087, 0.49529449644573387, 0.5463879568753263, 0.5665949790290452, 0.5877988913233836, 0.6529299382323175, 0.6013221239176942, 0.22995132062409396, 0.22444614002140084, 0.153856537240603, 0.2828816937225199, 0.9321498897516295, 0.9384078843018726, 0.1666352422410795, 0.15157010987100006, 0.1562323429178527, 0.13433697732715133, 0.13547120299092985, 0.4885080730435063, 0.527803619181259, 0.4333918355101667, 0.6428745056057161, 0.7196517575653574, 0.1352678263109286, 0.5276964265945514, 0.651766740391758, 0.5739318523293271, 0.13590074616157677, 0.6113422116184876, 0.415627302697973, 0.6009675675009514, 0.5883784298938625, 0.7548131253042847, 0.5173949585905612, 0.28277371057894696, 0.057473001207032914, 0.18017164654567663, 0.10680307261764754, 0.20699737377824556, 0.015351919210531917, 0.11006308019008904, 0.12736963222561226, 0.20367697191455858, 0.28785282962965153, 0.18457589239032912, 0.2862422046826433, 0.2181589078359364, 0.09713050734415651, 0.05415341705512711, 0.4099837123401664, 0.30221228154296276, 0.21392878925055192, 0.10126783408436568, 0.31382354494637454, 0.08709708493998203, 0.14953035224209688, 0.226623340383185, 0.1944367139576868, 0.2116245123941849, 0.11735934296978845, 0.07040003342945678, 0.3149264483286155, 0.2848804062595217, 0.2548721965780586, 0.360627352256785, 0.29965385990797155, 0.06543792937150306, 0.2538289775161743, 0.3770753094844501, 0.3001680909791582, 0.7731492859866276, 0.6966999254554302, 0.8147191762565519, 0.7947317549038811, 0.7742558747070338, 0.8132465983817208, 0.6627741092722343, 0.6242658600378816, 0.755872236620369, 0.05983690659461349, 0.09941337662457828, 0.0577733120866073, 0.11463065183835386, 0.0989968923552833, 0.13202034220807513, 0.08536528081909878, 0.09961454985675922, 0.07848304248897897, 0.3808082717048199, 0.447905017713326, 0.27015779879247237, 0.6352302608350165, 0.442871410916695, 0.21174292625782953, 0.251811091509738, 0.2637588035448297, 0.40243731967458884, 0.2771073764420052, 0.33405884816358133, 0.1622879959301723, 0.5192123177415054, 0.2974532705144255, 0.2273267482621838, 0.16994672347260675, 0.47362269467738916, 0.19463698113876693, 0.319184931576183, 0.21905223765888004, 0.23318263270275785, 0.4009179527761244, 0.2516449287370548, 0.26275125619978823, 0.2567844205294364, 0.25469422130184627, 0.10280966251522372, 0.2592433358650007, 0.23473106908794938, 0.2188983811734665, 0.23102203540329036, 0.2603322139778723, 0.22033856184912115, 0.2160120312990298, 0.19456568297828802, 0.22159174533956416, 0.1838386701724093, 0.22221188458452124, 0.18720568792191794, 0.17844297606241621, 0.22465786246604702, 0.19803629840162906, 0.18190326374191068, 0.21220638085515786, 0.19783851513611472, 0.9305647890272866, 0.9026232023117362, 0.1540482677419297, 0.9190172776774135, 0.2003178926750261, 0.8970235686357367, 0.9335855838103938, 0.9354048863885932, 0.16811799625046986, 0.9403098302836854, 0.21333047622773305, 0.8916465050580733, 0.21043468668267695, 0.16811275094313838, 0.21007839182243904, 0.892585983333118, 0.871815271626596, 0.9102376034009533, 0.17461753228282106, 0.23422686358773337, 0.18466696225870738, 0.17671921090972387, 0.1748506068637936, 0.1813547909062765, 0.174151595330449, 0.19651584843627612, 0.18650113722459083, 0.09838188219767485, 0.06166387165671239, 0.07896612343618126, 0.08422007066415604, 0.10322890707709653, 0.09834213235399802, 0.08694786260047371, 0.08092232317386783, 0.095537791764579]}, "mutation_prompt": null}
{"id": "a4ab8ab6-a7f9-4758-8f80-ca855b08e5e5", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a sinusoidal map to adjust the inertia weight\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a sinusoidal inertia weight adjustment for more diverse exploration through varying momentum. ", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29ac5932-2840-4675-8dab-c9a6746a7e9e", "metadata": {"aucs": [0.8671601134017389, 0.888085114620206, 0.884927264560184, 0.8447535077485967, 0.8834164289173586, 0.876325917020082, 0.8738786245056805, 0.8747536589046179, 0.8593022907279638, 0.7210651273209338, 0.6550580593491495, 0.6495764267889143, 0.6967787197064065, 0.6936974054333418, 0.5654258197184069, 0.5628093810644141, 0.572599040211077, 0.7377367530727303, 0.08369854118642017, 0.11635247026794693, 0.07778208400781927, 0.11718055185561882, 0.12174852699881089, 0.1331752276084197, 0.1153809460877494, 0.09482195308240737, 0.10847789264454388, 0.09177265189459327, 0.10714076320974675, 0.10106353374426913, 0.11350352217946369, 0.10432455735815671, 0.09128939850081497, 0.09573840421574442, 0.08213861897419628, 0.09553716297621884, 0.9409061386000807, 0.9111828825977696, 0.9271909482740286, 0.9180680094799979, 0.925662361537723, 0.8939051460657357, 0.9235196105091977, 0.945263809595637, 0.8845837245697347, 0.6568947613438703, 0.656055862507793, 0.5655394068204087, 0.49529449644573387, 0.5463879568753263, 0.5665949790290452, 0.5877988913233836, 0.6529299382323175, 0.6013221239176942, 0.22995132062409396, 0.22444614002140084, 0.153856537240603, 0.2828816937225199, 0.9321498897516295, 0.9384078843018726, 0.1666352422410795, 0.15157010987100006, 0.1562323429178527, 0.13433697732715133, 0.13547120299092985, 0.4885080730435063, 0.527803619181259, 0.4333918355101667, 0.6428745056057161, 0.7196517575653574, 0.1352678263109286, 0.5276964265945514, 0.651766740391758, 0.5739318523293271, 0.13590074616157677, 0.6113422116184876, 0.415627302697973, 0.6009675675009514, 0.5883784298938625, 0.7548131253042847, 0.5173949585905612, 0.28277371057894696, 0.057473001207032914, 0.18017164654567663, 0.10680307261764754, 0.20699737377824556, 0.015351919210531917, 0.11006308019008904, 0.12736963222561226, 0.20367697191455858, 0.28785282962965153, 0.18457589239032912, 0.2862422046826433, 0.2181589078359364, 0.09713050734415651, 0.05415341705512711, 0.4099837123401664, 0.30221228154296276, 0.21392878925055192, 0.10126783408436568, 0.31382354494637454, 0.08709708493998203, 0.14953035224209688, 0.226623340383185, 0.1944367139576868, 0.2116245123941849, 0.11735934296978845, 0.07040003342945678, 0.3149264483286155, 0.2848804062595217, 0.2548721965780586, 0.360627352256785, 0.29965385990797155, 0.06543792937150306, 0.2538289775161743, 0.3770753094844501, 0.3001680909791582, 0.7731492859866276, 0.6966999254554302, 0.8147191762565519, 0.7947317549038811, 0.7742558747070338, 0.8132465983817208, 0.6627741092722343, 0.6242658600378816, 0.755872236620369, 0.05983690659461349, 0.09941337662457828, 0.0577733120866073, 0.11463065183835386, 0.0989968923552833, 0.13202034220807513, 0.08536528081909878, 0.09961454985675922, 0.07848304248897897, 0.3808082717048199, 0.447905017713326, 0.27015779879247237, 0.6352302608350165, 0.442871410916695, 0.21174292625782953, 0.251811091509738, 0.2637588035448297, 0.40243731967458884, 0.2771073764420052, 0.33405884816358133, 0.1622879959301723, 0.5192123177415054, 0.2974532705144255, 0.2273267482621838, 0.16994672347260675, 0.47362269467738916, 0.19463698113876693, 0.319184931576183, 0.21905223765888004, 0.23318263270275785, 0.4009179527761244, 0.2516449287370548, 0.26275125619978823, 0.2567844205294364, 0.25469422130184627, 0.10280966251522372, 0.2592433358650007, 0.23473106908794938, 0.2188983811734665, 0.23102203540329036, 0.2603322139778723, 0.22033856184912115, 0.2160120312990298, 0.19456568297828802, 0.22159174533956416, 0.1838386701724093, 0.22221188458452124, 0.18720568792191794, 0.17844297606241621, 0.22465786246604702, 0.19803629840162906, 0.18190326374191068, 0.21220638085515786, 0.19783851513611472, 0.9305647890272866, 0.9026232023117362, 0.1540482677419297, 0.9190172776774135, 0.2003178926750261, 0.8970235686357367, 0.9335855838103938, 0.9354048863885932, 0.16811799625046986, 0.9403098302836854, 0.21333047622773305, 0.8916465050580733, 0.21043468668267695, 0.16811275094313838, 0.21007839182243904, 0.892585983333118, 0.871815271626596, 0.9102376034009533, 0.17461753228282106, 0.23422686358773337, 0.18466696225870738, 0.17671921090972387, 0.1748506068637936, 0.1813547909062765, 0.174151595330449, 0.19651584843627612, 0.18650113722459083, 0.09838188219767485, 0.06166387165671239, 0.07896612343618126, 0.08422007066415604, 0.10322890707709653, 0.09834213235399802, 0.08694786260047371, 0.08092232317386783, 0.095537791764579]}, "mutation_prompt": null}
{"id": "e3ac05c2-dc0c-4e9a-b9ab-937d8dfea554", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a sinusoidal map to adjust the inertia weight\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i] + cognitive_component * np.tanh(score)  # Nonlinear update\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce nonlinear velocity update to enhance local search around personal best positions.", "configspace": "", "generation": 27, "fitness": 0.30817021235406294, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "29ac5932-2840-4675-8dab-c9a6746a7e9e", "metadata": {"aucs": [0.8581592572705202, 0.8178680391846924, 0.8535171720005829, 0.8425405683413474, 0.8411992780698765, 0.8091522706077523, 0.5614662620387363, 0.5138243375601863, 0.45713376330011113, 0.2238011503630064, 0.18223952062473237, 0.24699986085613046, 0.2142333874891854, 0.27172213542639256, 0.2392091938770845, 0.2569709177112268, 0.26715596433126143, 0.182362562697307, 0.0725893058003716, 0.08084429390998393, 0.07539072961690285, 0.1055108669954623, 0.12640667932955219, 0.10723983003295123, 0.10298743161145596, 0.10898113340700089, 0.10400889014882975, 0.07285156579733554, 0.08540261618181355, 0.09066445823047165, 0.11330195523742437, 0.0873042726102613, 0.10468315214889512, 0.10220271332080921, 0.10041630682863911, 0.1006698287632406, 0.9402167866495452, 0.9284646404811745, 0.908969254898927, 0.9173317401401311, 0.9305485782853817, 0.927178260012304, 0.9340641605098791, 0.9467380939972068, 0.8855356300621606, 0.5021825989335504, 0.4503261704156448, 0.40461220243265994, 0.4837641741744214, 0.4433104354645415, 0.40659123286102283, 0.27202737448819003, 0.3377399281388278, 0.36063150455256887, 0.22930677398197907, 0.3695439198292346, 0.2140740922651655, 0.8940058943708606, 0.7755985165058599, 0.870057978906278, 0.7796293376404749, 0.8203092125399316, 0.8704189752568958, 0.13557170388821727, 0.1341308124966385, 0.33212574195057754, 0.17166327452357566, 0.1671268571364879, 0.194798956869342, 0.6615590362426791, 0.13608221361071882, 0.47855403708624367, 0.5116816974038707, 0.45623676282951, 0.1343334089997954, 0.6161962047466492, 0.4030533176650619, 0.467056816281633, 0.584262786433954, 0.6429523868881531, 0.1354449368908519, 0.05964704131225662, 0.06207350078853702, 0.11466789536809519, 0.07528402243774834, 0.3185018537524368, 0.03322842810551374, 0.06273598144429726, 0.02752358401182642, 0.12690060787263757, 0.2116065672871389, 0.18178330920259445, 0.3072926302227811, 0.19465020675765232, 0.12588548214162165, 0.05513889274180661, 0.3691717924425242, 0.21029949954562588, 0.10749864719120905, 0.18958355592019938, 0.19430151089876668, 0.18789714676738745, 0.0925097879619543, 0.0933493346393448, 0.18960310190231988, 0.17810923599632755, 0.1341739061050763, 0.07068641005426723, 0.22138164285501416, 0.23506741776997886, 0.3061807604696668, 0.14141580908908524, 0.1247643368303698, 0.060871627252431226, 0.08307964207616203, 0.13613016739217332, 0.11597005025681151, 0.45704452761277914, 0.3648845862950767, 0.450346021235132, 0.4419785163060195, 0.38532102185632333, 0.4095395101247399, 0.7685028499744608, 0.6769796457920236, 0.6887681224929669, 0.10380342117041019, 0.09690454749798338, 0.09649117386876715, 0.12960809454802513, 0.07413577403950089, 0.12685950979044014, 0.12530366536128767, 0.10447126853977629, 0.13527565032592415, 0.1965000799392811, 0.24491135491552718, 0.22937750807004276, 0.15653726267539347, 0.12819120336958223, 0.12332204350631404, 0.15306307340160474, 0.15809291523676205, 0.13762966987548575, 0.22801373228306998, 0.3054923599502598, 0.20978697667153312, 0.42573551338039783, 0.26040824012306096, 0.36801707505071835, 0.2668309828072616, 0.4359159637361859, 0.3452495635329329, 0.20596044407352176, 0.2063867573940914, 0.20596512869879757, 0.3248089509019766, 0.24463740587828708, 0.31472650087548404, 0.4099062259091375, 0.25059936543183225, 0.11661386112747663, 0.19076120173649191, 0.20986910893048738, 0.2107800267271568, 0.21449130096604296, 0.22782077552853397, 0.21265598231575022, 0.20524984917786293, 0.2062819289332921, 0.23199927378401708, 0.18191795305469483, 0.1892392095025628, 0.18243762358986493, 0.5835754139522173, 0.23875068129461874, 0.21598727133469597, 0.18358697021740655, 0.200756132010799, 0.1895187845346098, 0.9153401924331186, 0.8677595594506797, 0.15274214126521402, 0.6595918471994282, 0.19751403585267524, 0.6031216295047848, 0.5521920900313877, 0.39927821452827594, 0.1634159900245279, 0.15486173051325625, 0.2131010567318543, 0.6250953132928301, 0.21160190173469606, 0.16851344752819752, 0.3043990308868282, 0.49047770352066544, 0.5158289139845538, 0.6451985184834331, 0.17839016335964097, 0.17145458776440825, 0.1799234192814585, 0.18269244716918787, 0.19879691339986572, 0.19805502009572995, 0.1785846409498023, 0.1777693375344912, 0.182273270800426, 0.08889954451691229, 0.08805628779151264, 0.08406504533615677, 0.08754220846233307, 0.08874988301399955, 0.08921388125785945, 0.08117946718048519, 0.08327927686495118, 0.07524412516924162]}, "mutation_prompt": null}
{"id": "c47454e3-65a8-41f1-a4cb-adc36a395357", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a sinusoidal map to adjust the inertia weight\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a sinusoidal inertia weight adjustment for more diverse exploration through varying momentum. ", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "29ac5932-2840-4675-8dab-c9a6746a7e9e", "metadata": {"aucs": [0.8671601134017389, 0.888085114620206, 0.884927264560184, 0.8447535077485967, 0.8834164289173586, 0.876325917020082, 0.8738786245056805, 0.8747536589046179, 0.8593022907279638, 0.7210651273209338, 0.6550580593491495, 0.6495764267889143, 0.6967787197064065, 0.6936974054333418, 0.5654258197184069, 0.5628093810644141, 0.572599040211077, 0.7377367530727303, 0.08369854118642017, 0.11635247026794693, 0.07778208400781927, 0.11718055185561882, 0.12174852699881089, 0.1331752276084197, 0.1153809460877494, 0.09482195308240737, 0.10847789264454388, 0.09177265189459327, 0.10714076320974675, 0.10106353374426913, 0.11350352217946369, 0.10432455735815671, 0.09128939850081497, 0.09573840421574442, 0.08213861897419628, 0.09553716297621884, 0.9409061386000807, 0.9111828825977696, 0.9271909482740286, 0.9180680094799979, 0.925662361537723, 0.8939051460657357, 0.9235196105091977, 0.945263809595637, 0.8845837245697347, 0.6568947613438703, 0.656055862507793, 0.5655394068204087, 0.49529449644573387, 0.5463879568753263, 0.5665949790290452, 0.5877988913233836, 0.6529299382323175, 0.6013221239176942, 0.22995132062409396, 0.22444614002140084, 0.153856537240603, 0.2828816937225199, 0.9321498897516295, 0.9384078843018726, 0.1666352422410795, 0.15157010987100006, 0.1562323429178527, 0.13433697732715133, 0.13547120299092985, 0.4885080730435063, 0.527803619181259, 0.4333918355101667, 0.6428745056057161, 0.7196517575653574, 0.1352678263109286, 0.5276964265945514, 0.651766740391758, 0.5739318523293271, 0.13590074616157677, 0.6113422116184876, 0.415627302697973, 0.6009675675009514, 0.5883784298938625, 0.7548131253042847, 0.5173949585905612, 0.28277371057894696, 0.057473001207032914, 0.18017164654567663, 0.10680307261764754, 0.20699737377824556, 0.015351919210531917, 0.11006308019008904, 0.12736963222561226, 0.20367697191455858, 0.28785282962965153, 0.18457589239032912, 0.2862422046826433, 0.2181589078359364, 0.09713050734415651, 0.05415341705512711, 0.4099837123401664, 0.30221228154296276, 0.21392878925055192, 0.10126783408436568, 0.31382354494637454, 0.08709708493998203, 0.14953035224209688, 0.226623340383185, 0.1944367139576868, 0.2116245123941849, 0.11735934296978845, 0.07040003342945678, 0.3149264483286155, 0.2848804062595217, 0.2548721965780586, 0.360627352256785, 0.29965385990797155, 0.06543792937150306, 0.2538289775161743, 0.3770753094844501, 0.3001680909791582, 0.7731492859866276, 0.6966999254554302, 0.8147191762565519, 0.7947317549038811, 0.7742558747070338, 0.8132465983817208, 0.6627741092722343, 0.6242658600378816, 0.755872236620369, 0.05983690659461349, 0.09941337662457828, 0.0577733120866073, 0.11463065183835386, 0.0989968923552833, 0.13202034220807513, 0.08536528081909878, 0.09961454985675922, 0.07848304248897897, 0.3808082717048199, 0.447905017713326, 0.27015779879247237, 0.6352302608350165, 0.442871410916695, 0.21174292625782953, 0.251811091509738, 0.2637588035448297, 0.40243731967458884, 0.2771073764420052, 0.33405884816358133, 0.1622879959301723, 0.5192123177415054, 0.2974532705144255, 0.2273267482621838, 0.16994672347260675, 0.47362269467738916, 0.19463698113876693, 0.319184931576183, 0.21905223765888004, 0.23318263270275785, 0.4009179527761244, 0.2516449287370548, 0.26275125619978823, 0.2567844205294364, 0.25469422130184627, 0.10280966251522372, 0.2592433358650007, 0.23473106908794938, 0.2188983811734665, 0.23102203540329036, 0.2603322139778723, 0.22033856184912115, 0.2160120312990298, 0.19456568297828802, 0.22159174533956416, 0.1838386701724093, 0.22221188458452124, 0.18720568792191794, 0.17844297606241621, 0.22465786246604702, 0.19803629840162906, 0.18190326374191068, 0.21220638085515786, 0.19783851513611472, 0.9305647890272866, 0.9026232023117362, 0.1540482677419297, 0.9190172776774135, 0.2003178926750261, 0.8970235686357367, 0.9335855838103938, 0.9354048863885932, 0.16811799625046986, 0.9403098302836854, 0.21333047622773305, 0.8916465050580733, 0.21043468668267695, 0.16811275094313838, 0.21007839182243904, 0.892585983333118, 0.871815271626596, 0.9102376034009533, 0.17461753228282106, 0.23422686358773337, 0.18466696225870738, 0.17671921090972387, 0.1748506068637936, 0.1813547909062765, 0.174151595330449, 0.19651584843627612, 0.18650113722459083, 0.09838188219767485, 0.06166387165671239, 0.07896612343618126, 0.08422007066415604, 0.10322890707709653, 0.09834213235399802, 0.08694786260047371, 0.08092232317386783, 0.095537791764579]}, "mutation_prompt": null}
{"id": "b5293a01-8cfe-4d78-b1cf-f36fca8f8db2", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Use a sinusoidal map to adjust the inertia weight\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                # Introduce random neighborhood attraction with adaptive weights\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Adaptive differential mutation\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Incorporate a dynamic social coefficient adjustment based on evaluation progress for enhanced global exploration.", "configspace": "", "generation": 29, "fitness": 0.3835723119568268, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "29ac5932-2840-4675-8dab-c9a6746a7e9e", "metadata": {"aucs": [0.8567676956251152, 0.8875256077289534, 0.8866976693763275, 0.8865945533316817, 0.8709133728081464, 0.8857266737361363, 0.8625844374658437, 0.8898080148116594, 0.8529733928412011, 0.6872904582369788, 0.6318308818883351, 0.6746509773319797, 0.7083945710727573, 0.6792990347385028, 0.6900234496260993, 0.6597612690024759, 0.667283926952853, 0.6802791652819442, 0.08282347351511798, 0.11726801934781639, 0.08096551838281407, 0.09576722109833513, 0.1566128232801277, 0.08842264177937775, 0.12757298176161025, 0.07967706034509314, 0.09535995495666849, 0.09454234954146756, 0.09890373180267198, 0.10616154917372111, 0.13518184364338193, 0.0965482072980709, 0.11325019815159743, 0.08540719382227213, 0.07609771355911576, 0.09018820815050599, 0.9400884284335029, 0.9112482527750078, 0.938588876524829, 0.9024166843641728, 0.9256317076985037, 0.8851322680387941, 0.9231006429661666, 0.9452858020746956, 0.8750693270379464, 0.664682873469133, 0.6177834072778693, 0.6059691465915079, 0.6616716995737415, 0.6098690464621002, 0.6452544339016143, 0.7125302118993875, 0.6422376064028531, 0.6139704987233399, 0.22601882136183526, 0.2206978059860134, 0.1707850454795895, 0.2829017657484374, 0.38553037432626447, 0.9311726034738096, 0.19350657919465264, 0.17789087206279453, 0.1562321671793535, 0.1341487208310579, 0.13510244156969997, 0.5249480171483001, 0.5824002212445715, 0.5205611884480028, 0.595502268174113, 0.7197331324234385, 0.1348373921674656, 0.6926763935265735, 0.6407284189395333, 0.5500909913958686, 0.1364398005718913, 0.6055800065700405, 0.5144368078559732, 0.61907526543756, 0.486480709428613, 0.7442955212800777, 0.5200450212936396, 0.07962965813334744, 0.06230841155847977, 0.11015201686825382, 0.12006024796410253, 0.21247477289752814, 0.01836893550945984, 0.13332131650665902, 0.0688445803404849, 0.214854358602256, 0.3178452037635515, 0.2586030253962971, 0.3399607771896491, 0.17062182306791296, 0.14405949077275504, 0.0929442586891217, 0.48876634862708623, 0.4176060417667774, 0.17396349685553703, 0.12868850755036032, 0.2926826307690389, 0.08857958893816509, 0.2272994979367381, 0.1909833120756146, 0.23357647736059062, 0.2670670916323441, 0.09280032795124693, 0.07152331814198365, 0.4051393553656224, 0.432774494146981, 0.18548455805358577, 0.1678300912912487, 0.2558697835212729, 0.03171346351851645, 0.23731870955809764, 0.3259345617746894, 0.16509771636650838, 0.7434408687191985, 0.6637436334646187, 0.6598010304710771, 0.6570311055807505, 0.7427138136517951, 0.799429323439182, 0.7794413240107152, 0.7714207324760187, 0.697898557323513, 0.07143067234315514, 0.08465788474092661, 0.11951314925557421, 0.12261109745244847, 0.1251116458360546, 0.1533522364105897, 0.10619503320511448, 0.12264125516936164, 0.06831387400600974, 0.38959158349390466, 0.26619549628856587, 0.27844802926619827, 0.5514891209421069, 0.32864763750694415, 0.38641250518397896, 0.39522826253890775, 0.5310864653971215, 0.6527926226472447, 0.24319229758113947, 0.5073384382367372, 0.17144797538148726, 0.5453482453439913, 0.27813451630053454, 0.21627801380162204, 0.16536169874795492, 0.6153852702816227, 0.23282077350234165, 0.24903007473780647, 0.4280843834681497, 0.19533517645758114, 0.4621751460530583, 0.25666244261840354, 0.36724574619786376, 0.20076849114402284, 0.19611991332028722, 0.2154937773129113, 0.19279207945126975, 0.2120128299432006, 0.22363321315972762, 0.20571139118178094, 0.22794584745186242, 0.1986510994381867, 0.24129077192391213, 0.2560421365204898, 0.19704334780136734, 0.18799365849091876, 0.19943549390871607, 0.17897376933727027, 0.19702300681321772, 0.20426964664489444, 0.1983527011104329, 0.1797965089001442, 0.19274341807796913, 0.18686302891124085, 0.9372242063475024, 0.8857840481111776, 0.1540091531906992, 0.9199996216633057, 0.2001191620985201, 0.9064680229208769, 0.9380163839117649, 0.9316332592069674, 0.16790445366805706, 0.9293840449983253, 0.21334830208160316, 0.9079778247984955, 0.21107856957641413, 0.16811122366747255, 0.21012069425949587, 0.8550203523125831, 0.8910494169671641, 0.9000617144521892, 0.1726858400389225, 0.19350316890739971, 0.17541443368451803, 0.1706579862467419, 0.18369077244787757, 0.1799824909079556, 0.17366126290352735, 0.17183436534398477, 0.19113322185284343, 0.08683490578138431, 0.09261793361455961, 0.08320070207198182, 0.09053943109728446, 0.08576370023495294, 0.11991995099927333, 0.08453067244657853, 0.0678598339358163, 0.07878960628823128]}, "mutation_prompt": null}
{"id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce an adaptive local leader selection to balance exploration and exploitation dynamically.", "configspace": "", "generation": 30, "fitness": 0.3846774965043104, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.30.", "error": "", "parent_id": "b5293a01-8cfe-4d78-b1cf-f36fca8f8db2", "metadata": {"aucs": [0.8809497434737135, 0.8848332269903204, 0.872570886152797, 0.8574847414003834, 0.8943101891275396, 0.9004349162091958, 0.896744504723235, 0.859318924743454, 0.8910728783455985, 0.6976644997820585, 0.7034925050625598, 0.6389937501857749, 0.7122688141106827, 0.6401840605585989, 0.6727944949237297, 0.620754983673673, 0.7050799553665797, 0.6437417304927942, 0.08274578663738452, 0.10963948921470201, 0.0815367569156712, 0.10776035599064948, 0.08495250439051072, 0.12346446672674716, 0.1169291124628864, 0.13478193962171647, 0.11779813200709521, 0.07623547359177063, 0.1297409415271703, 0.0824032568032873, 0.12463889413029372, 0.094135162256476, 0.0855220732007308, 0.10170895399132585, 0.05844743655340756, 0.09192462306985416, 0.9377510760811102, 0.921618427242608, 0.9177936328319375, 0.913665471356257, 0.9302835765887493, 0.9131270521291748, 0.9368924719640629, 0.9478177833888778, 0.9232378661492335, 0.6727237479396322, 0.6987442362984632, 0.7247685600397296, 0.6806227583639143, 0.5648616986035494, 0.15145380408941256, 0.6450057099369693, 0.6052321004889798, 0.7044000626455631, 0.23044721331802442, 0.16964139090986952, 0.13927183271189691, 0.9004580752617931, 0.9285975973659563, 0.8226775798501159, 0.1781666355579189, 0.17800621742133194, 0.8252753932477771, 0.13624036825833796, 0.1353845525030809, 0.48714621960466475, 0.5096279018867999, 0.5696215553117543, 0.13312279751510725, 0.6254578870082087, 0.13580335574730928, 0.49365406271152945, 0.5298432366329708, 0.49261611341194333, 0.6647619381648262, 0.7985558563147419, 0.45149035971807516, 0.526506902891405, 0.5849442047661323, 0.7397096820573418, 0.47629830571880427, 0.042377466545145626, 0.1636324730629356, 0.12508799583580565, 0.12402641385916591, 0.1621764645556235, 0.08911238308523184, 0.10076662998312913, 0.189208003713201, 0.15893777375211726, 0.20885306129919423, 0.17030023309021436, 0.3802276867202329, 0.10522995345995134, 0.1404972684137572, 0.05823525372078786, 0.32805666384394927, 0.25201720102270997, 0.2927162667231499, 0.23788000040070778, 0.1597959756597922, 0.3079686818968178, 0.20294124316617745, 0.13029006029245416, 0.12227188384059173, 0.2961978523482478, 0.20187541859633396, 0.08416728532963957, 0.35173160149797544, 0.19028591937232864, 0.30602468794390714, 0.19610587628311738, 0.31014172981407184, 0.03085110554564685, 0.2122741275632618, 0.3441964548064814, 0.1993732087911183, 0.7713205291127443, 0.7673015642526109, 0.7986960472086123, 0.7552337335266277, 0.6995376313764758, 0.7044866546025724, 0.7729051040417425, 0.7179080228847757, 0.6139284874848385, 0.08497953635498545, 0.08755735640430684, 0.05423252321693128, 0.1222361701556296, 0.10374194004374626, 0.09501757960587676, 0.14731283320902733, 0.10927225376148031, 0.09078449643111908, 0.5244735122184486, 0.3442786869316483, 0.24380342142467915, 0.2678081947040858, 0.3397566923557179, 0.19688621177407373, 0.5837310901929162, 0.6419303443959209, 0.19394013953094147, 0.4222855771735835, 0.32762929139233143, 0.23604275821827692, 0.5804332522640837, 0.3330940849229703, 0.5058902076698465, 0.2646842313465205, 0.5650338941287363, 0.11155272604611, 0.22675905289776244, 0.2759509768361721, 0.13081221794038866, 0.30324406124320635, 0.24398314454053438, 0.276061242312723, 0.18348145312739383, 0.1943200609520508, 0.10313968244742955, 0.21956806884219637, 0.23650136834743818, 0.19881426220703347, 0.2091248313503672, 0.21580885307423325, 0.19769715497234086, 0.2397124533072128, 0.2391218781423463, 0.23304704613836524, 0.1715422193452789, 0.2238357287221937, 0.19558084225504346, 0.24834411570209713, 0.22975403918301085, 0.18776826438065786, 0.18260475757420525, 0.25091205449711673, 0.19006775663112807, 0.937912975883904, 0.9307859681352824, 0.15327475410954416, 0.9268105661254882, 0.20009866355731787, 0.9182389619787827, 0.9349096359476443, 0.9250477611184039, 0.16857916856081434, 0.9045797367996744, 0.21189148912485967, 0.9317809996040731, 0.21056935925940123, 0.16799844324368618, 0.9163101293438725, 0.8338638889650257, 0.885091127828752, 0.10484137664798854, 0.1739185155214471, 0.17043136740878073, 0.1878546746999723, 0.17532969058733838, 0.18142977411394312, 0.19158268696331882, 0.17293738650435386, 0.18130906685759773, 0.17438158275597382, 0.09626954554301681, 0.08604934872892578, 0.08293293634573551, 0.09634276800579644, 0.09058804755314998, 0.11486727617171488, 0.08769516322488202, 0.07947718540116144, 0.09087311271922627]}, "mutation_prompt": null}
{"id": "eddf778f-0a66-4619-a2e6-2fde7ecd34db", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                mutation_intensity = 0.5 + np.abs(np.sin(np.pi * evaluations / self.budget))  # Line 1 changed\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + mutation_intensity * (self.positions[b] - self.positions[c])  # Line 2 changed\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])  # Line 3 changed\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance exploration with adaptive mutation intensity based on convergence rate.", "configspace": "", "generation": 31, "fitness": 0.3814370597638381, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.9002644439371795, 0.8855762965332273, 0.8836821433122745, 0.8747512602841776, 0.8845019578592908, 0.8846312431274838, 0.8675579936789082, 0.881694308601567, 0.8473710492824417, 0.6528581743205982, 0.6730770220598936, 0.6881400425873644, 0.6820331818748981, 0.6439377618647169, 0.6318972830971737, 0.7393549534871213, 0.7175878598984547, 0.6882995011052846, 0.06391772292352782, 0.13930396116332144, 0.08204528756807572, 0.08914733252295393, 0.11407763119437675, 0.12448580342368587, 0.13823495156627252, 0.16323782880395832, 0.11688953566875881, 0.11196147412905177, 0.10426545391186215, 0.10132875999384983, 0.11058083107378369, 0.11127583939798114, 0.11760708416808752, 0.10833658715176786, 0.15132391419404667, 0.10823435514728585, 0.9378567542653776, 0.9264760932058569, 0.9190263778928868, 0.9140126433263424, 0.9355748330567007, 0.9123889636370967, 0.9357705792986453, 0.947552622306907, 0.912686823661738, 0.741604967584786, 0.6503020239286146, 0.6566356052536824, 0.5624698395412011, 0.605468900078095, 0.541190379930068, 0.6590094884179429, 0.5057258367086721, 0.5342751994945524, 0.16365789341600445, 0.16962248873572738, 0.8673694141563373, 0.9276256770156498, 0.27802054966048095, 0.21318043764034966, 0.17831717450044926, 0.17800396977668165, 0.23487629015998468, 0.13621778036015875, 0.1351306795160706, 0.5497032578931837, 0.49078345904496923, 0.1320464307599728, 0.13289613393382715, 0.7730097505838874, 0.13589574707520968, 0.6319486839962765, 0.6156318883868745, 0.5088789758634809, 0.6779229080404772, 0.6768142858888018, 0.6519582503551227, 0.6190127327852081, 0.5517661906889859, 0.7149274884451882, 0.5323632720954214, 9.999999999998899e-05, 0.06579012527049366, 0.2237454903979489, 0.25716063385954413, 0.19906509678859852, 0.09261417085018786, 0.12183994729341796, 0.31274972057632056, 0.10614561279281609, 0.3990058191709144, 0.19981947920219478, 0.2061384096621901, 0.3674162655236807, 0.08196186867964317, 0.051862936714530794, 0.416322462556899, 0.41507415585225804, 0.290828450918042, 0.12695584808610016, 0.15030694913657738, 0.15287891329274172, 0.1645906412236986, 0.13485554783813347, 0.15334042704607143, 0.24745572514885694, 0.1401419668449969, 0.07647987874693263, 0.26717243839226446, 0.20978307524530693, 0.30313092379590023, 0.2919927126547346, 0.3177096984218559, 0.20942563172626227, 0.15875140718098735, 0.29662863419508834, 0.0835914225161134, 0.6722370513295115, 0.7628967010771064, 0.7711811967006792, 0.8004094852502698, 0.5959893183633965, 0.7052697240764249, 0.7007779242884895, 0.6424385148560737, 0.7736143530819928, 0.07098236416228298, 0.10624442696614256, 0.07050019719206024, 0.0944545192821068, 0.13760173799101194, 0.12592299867909806, 0.1600051372252559, 0.10150852408100786, 0.07679308579912103, 0.1844907032670401, 0.7283862130268857, 0.7027186114440427, 0.24510104328628368, 0.24491667318398613, 0.24627331288145038, 0.22885865459750332, 0.20910482597890168, 0.24618593151355705, 0.3561348395154823, 0.5410836182344925, 0.23662645098609092, 0.31813259078268286, 0.29017321683859076, 0.2979005951860275, 0.5138689252484554, 0.511388523943039, 0.471701815476975, 0.12746200995477597, 0.34027300629396307, 0.13727773998030057, 0.2965867065440392, 0.3248054873367966, 0.20060256937450982, 0.24299782251419455, 0.21917159200842673, 0.09727227442673281, 0.24192690441866183, 0.1961369042866543, 0.20933857712005, 0.20923824543990854, 0.2064720348888177, 0.20062565711129632, 0.2170096553475741, 0.22798053730935164, 0.22324220780706228, 0.17150250892172536, 0.21216948556563142, 0.19666538769333153, 0.20318331570889459, 0.2410118602419784, 0.1873774464373078, 0.17220857578384208, 0.1968173233245567, 0.20826197822725068, 0.9462433560307713, 0.9198291491998862, 0.1525474858322603, 0.8943569246721852, 0.1999765790892084, 0.9295750823751806, 0.9176923103959461, 0.9225463964956572, 0.16856814502661932, 0.9190042524385283, 0.21330911391873986, 0.9318858068829566, 0.21046515668118848, 0.1679677505824707, 0.9135165508834081, 0.8578399366958446, 0.8594792281230763, 0.1048758761605948, 0.18841244313163985, 0.18023250457218642, 0.17629931874418092, 0.18172698768505546, 0.18839523783922163, 0.18162540418357975, 0.17244169278910015, 0.2136011242884891, 0.19123230223900045, 0.07968818918536325, 0.08336247478803127, 0.07671365467179425, 0.09742429668429342, 0.0867098873945914, 0.10753165905991902, 0.09137481983158324, 0.08141610524603471, 0.08113302442835446]}, "mutation_prompt": null}
{"id": "0b55d406-8072-40ad-a52b-bbdfeb8543d5", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.5 + 0.5 * (evaluations / self.budget)  # Variable mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a variable mutation coefficient to enhance diversity and exploration in later stages of the optimization process.", "configspace": "", "generation": 32, "fitness": 0.3822389278791563, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.30.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.9147622773545714, 0.9093156184244838, 0.9069861199713278, 0.892209938030346, 0.900609561891443, 0.9100299953991247, 0.8909175115298493, 0.9120332907840983, 0.8721506126608308, 0.7289422850485852, 0.7662554216554722, 0.7060099785012464, 0.7144498364492236, 0.7303494459460877, 0.662161121109555, 0.7602199072391733, 0.7265333688034568, 0.6992530849886431, 0.09362800909284741, 0.10643244542990982, 0.06600280119409907, 0.11711541613088261, 0.10671428240441416, 0.09702701366348543, 0.09799823583078193, 0.08830362203781328, 0.16166000535525693, 0.11238162860331902, 0.09818653533169597, 0.06145052394824202, 0.09249770261616597, 0.05248478699385084, 0.04312667727842634, 0.0632289443735159, 0.05840771112380494, 0.0638351808676445, 0.949075081897507, 0.9340261648003088, 0.941777510119095, 0.9272482401136192, 0.9116771588646031, 0.9255749756306635, 0.9239562000807992, 0.92044671214686, 0.9410676710796079, 0.7153742835228303, 0.7392667000549888, 0.6966170786049348, 0.7405297446056618, 0.7532950080946006, 0.691544944623647, 0.6687048669658049, 0.7922082758829593, 0.7101164315336166, 0.1635501814178939, 0.1412077429418105, 0.22838051786876112, 0.2805389753075508, 0.2797668351639334, 0.9480340673600438, 0.14558067809318787, 0.15287838073742555, 0.40240137159814493, 0.13353573261482066, 0.6898185386308575, 0.506621608600746, 0.1329446602188158, 0.13625036912930177, 0.5839618101564933, 0.643449553006596, 0.6615197617415761, 0.7079239761272595, 0.6896238478514644, 0.1345242071127728, 0.8222896475382889, 0.6293836951961385, 0.5617745244777362, 0.64229263089874, 0.5994478823019451, 0.36333498351412075, 0.6509650823440996, 0.0752212945527797, 0.12437334826548507, 0.16818251809389673, 0.0649378564717954, 0.041249554772714525, 0.24105013450148294, 0.1573079804780524, 0.06594365374406863, 0.1780670402359047, 0.33010800584883104, 0.23263839649705176, 0.18242466966549276, 0.12842296611288095, 0.14450073973012945, 0.11613151490704132, 0.24743973613604853, 0.2736930712654122, 0.16989022524427744, 0.1750517791007138, 0.39134855731252105, 0.07762122666759408, 0.21488028707036355, 0.35841154725729396, 0.34844493076722227, 0.1451023081956051, 0.316381094988042, 0.07896200410855814, 0.2839924243193054, 0.2553487657343112, 0.26633022776016846, 0.2604904115179414, 0.2412117641131628, 0.3681010229605476, 0.15934285203745946, 0.21904114769512983, 0.18353262711720797, 0.7730814245999431, 0.6450053495527753, 0.6713380285721249, 0.7900818968964078, 0.6263338593995116, 0.5938561251005461, 0.7063669881924142, 0.7440640213544722, 0.7851220741956293, 0.1374517590579657, 0.06580121165063213, 0.004276399969214584, 0.10460335205271154, 0.06425024554125047, 0.07710218741266761, 0.10830771053240129, 0.1456526006262282, 0.07787894933971296, 0.47402754933141056, 0.6978084546919932, 0.3541060036022493, 0.5888829558791147, 0.7188991856544693, 0.42955987568894416, 0.26923041950974846, 0.3358798025950601, 0.19094273365459424, 0.4756103336855866, 0.19528455904266862, 0.16399602788480427, 0.3617366901386775, 0.3065315400997771, 0.25332416440667993, 0.2130335513568148, 0.39102962692065846, 0.12075921286881564, 0.3330505817072561, 0.32326763472528863, 0.20565215777547174, 0.24843529577787493, 0.21557611419355527, 0.1634321992986113, 0.2500711899457714, 0.2759637422016573, 0.10015798549381694, 0.2565374709206413, 0.21456342772099501, 0.23777873362252078, 0.2724185507386572, 0.24635885569354377, 0.20525835522730362, 0.2101079219658457, 0.19688324072026886, 0.21592254027054736, 0.18637902664946437, 0.1773954116610632, 0.17456396009071595, 0.18472462766116138, 0.20897206694636183, 0.1840324718336639, 0.18473412933696465, 0.1919894367497873, 0.19867620691998722, 0.18900695079126106, 0.12648023590653923, 0.18747897184112028, 0.9488434911622765, 0.20027310416845512, 0.9417365579860669, 0.94311360723303, 0.1690898176790594, 0.16795896106856922, 0.8928659930757424, 0.9057978452019095, 0.8030890250527006, 0.9097163716286301, 0.1541140956967625, 0.8667972246271815, 0.10512632549244405, 0.9057268857581624, 0.8658211424690794, 0.21356326302832962, 0.17489847904860267, 0.1758927451424963, 0.17742966347597489, 0.17813152031221413, 0.17259730788820904, 0.1823466185491307, 0.19086371145100733, 0.17338937655795583, 0.09611806056514594, 0.0836006883210284, 0.054328085219411126, 0.0841961922426222, 0.08898815338609234, 0.09953719151279183, 0.08282494894802861, 0.06710361627537387, 0.0772850923441023]}, "mutation_prompt": null}
{"id": "cb735c8c-71f0-4788-8f3d-bb7c1935a9a5", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 1.5 + 0.5 * np.cos(2 * np.pi * evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.2 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance dynamic adjustment of social coefficient and neighbor attraction to improve convergence.", "configspace": "", "generation": 33, "fitness": 0.35979707531887706, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.9033010035879571, 0.9147221126156638, 0.9085517704861225, 0.8711315965438436, 0.8856980810199815, 0.8943153883693832, 0.8861431640542214, 0.8935550879304746, 0.8960483506343219, 0.7529369654429607, 0.5912983536049023, 0.03998110772382424, 0.7254282589489827, 0.7476420893061468, 0.6557596903191086, 0.6655466775312027, 0.7035677583170976, 0.6637419703148495, 0.11191427803504872, 0.11761209275948736, 0.08224355511063675, 0.08726999537409552, 0.14342358187379467, 0.12259067366648979, 0.15602521893542798, 0.09142701762156957, 0.08499630504247524, 0.07945872181621927, 0.11190621556677727, 0.0795658171512772, 0.11027392903426825, 0.09433102706147767, 0.036656621531475864, 0.08118989308592794, 0.10802453288979652, 0.04398410368914374, 0.9153239779735859, 0.8905405529089239, 0.9095465872552937, 0.8881596189186787, 0.9030241705318264, 0.87601037676394, 0.9137852515693659, 0.9286984222311754, 0.8988288637976105, 0.7267455254209706, 0.7202230082713512, 0.7277582473875699, 0.6787742911771, 0.7515891472464449, 0.7237201355557045, 0.6605043876791871, 0.7211240746663221, 0.7385627134492097, 0.23058642832176424, 0.22826289806907707, 0.17050420275821143, 0.9381586730268663, 0.2795200898091579, 0.19567000369328358, 0.14970816877295423, 0.15311401988998607, 0.10671061820972483, 0.13499087389387188, 0.1355007539685772, 0.13029326884443182, 0.5351610771475168, 0.4422879784495046, 0.76580557775122, 0.32713283394751325, 0.13474663248169017, 0.7187989184054392, 0.6072700713402219, 0.6073877870769102, 0.39956225849024063, 0.5172398830004418, 0.5343292218746163, 0.2670767087631625, 0.6287986991684785, 0.3385834894248668, 0.5553702174089493, 0.09428607120574195, 0.09146817168565902, 0.1568123871458672, 0.08264553954989273, 0.13161332873123155, 0.052898010780146665, 0.3247940695009536, 0.08996302847013882, 0.18296145743710113, 0.23651541892005257, 0.1771493395508562, 0.2662547867132691, 0.25312002993293325, 0.1880271505259986, 0.07402148251216423, 0.29895561550934624, 0.3412364632176573, 0.16323712900861187, 0.3267735613370265, 0.14844175709394125, 0.1686862026406305, 0.11309084700896743, 0.3613492795687041, 0.19734290913344177, 0.21659639512509032, 0.1312969676608109, 0.1302110819433212, 0.19422116833078285, 0.24969878162252213, 0.18633536323045663, 0.25790523700182355, 0.33015392104892294, 0.23154016834911395, 0.126604534497623, 0.32272676095240727, 0.08357956706294845, 0.7465667758057928, 0.6493512883764503, 0.7320017542852948, 0.7215667720800765, 0.8343197232810303, 0.6993528866676346, 0.7542677369610434, 0.6475423193512857, 0.6187809198145345, 0.04311198634088942, 0.04150627126932527, 0.0684344121466598, 0.13167007663275831, 0.0960836507000562, 0.08688100946150479, 0.10001375801103896, 0.1308442412456392, 0.09337458346068839, 0.5957389045791156, 0.45362917865388286, 0.2622195074092931, 0.5499558221016099, 0.657704422053621, 0.5907599514352395, 0.21509342553513366, 0.5134121574765738, 0.27048174187876106, 0.14592489331765424, 0.21308059157181558, 0.17001093940237877, 0.204479042841481, 0.28079396706572557, 0.23685841764503657, 0.20186031909134272, 0.5652391623462008, 0.19380602595186147, 0.11773131176391705, 0.2872766370531932, 0.22057967199601225, 0.20226426808836018, 0.2678758949080803, 0.31796633515125405, 0.19851792505563215, 0.2850891553313948, 0.1276286210717632, 0.23622175766192355, 0.28113011061795057, 0.23644991482457534, 0.23415071577323288, 0.2263908545623452, 0.2107105068679943, 0.2164876929091849, 0.2170429762751015, 0.2068129248455044, 0.18604289604246615, 0.19054117463139086, 0.18484636029259605, 0.18615633199029835, 0.18285798884724236, 0.16879638821011378, 0.19695601756840164, 0.18361559931469384, 0.18022617948636033, 0.18762651836906052, 0.18792646503792243, 0.15212764157944259, 0.9362887020255368, 0.9241173792878921, 0.9189758932526785, 0.1668790741655526, 0.9208535046318259, 0.16775104350941217, 0.8016897557453044, 0.21259038877118297, 0.9316222108763272, 0.21042014599443826, 0.168161636891062, 0.9162791290736142, 0.10524022159328139, 0.16881876979032062, 0.8731852589675142, 0.18301266782063708, 0.17552020717344963, 0.1803183266369175, 0.20500701429207657, 0.18785616878575584, 0.1832507177347853, 0.1673249936635215, 0.1821996275701233, 0.1784825084806333, 0.08244579794500861, 0.10107541733119996, 0.09248178527588047, 0.07821729637201935, 0.09143966514212476, 0.0570340016787686, 0.08319385963711246, 0.07697311680369856, 0.062428811786408356]}, "mutation_prompt": null}
{"id": "12f995f4-47e1-4e7c-ac89-c65278360df0", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce an adaptive local leader selection to balance exploration and exploitation dynamically.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8809497434737135, 0.8848332269903204, 0.872570886152797, 0.8574847414003834, 0.8943101891275396, 0.9004349162091958, 0.896744504723235, 0.859318924743454, 0.8910728783455985, 0.6976644997820585, 0.7034925050625598, 0.6389937501857749, 0.7122688141106827, 0.6401840605585989, 0.6727944949237297, 0.620754983673673, 0.7050799553665797, 0.6437417304927942, 0.08274578663738452, 0.10963948921470201, 0.0815367569156712, 0.10776035599064948, 0.08495250439051072, 0.12346446672674716, 0.1169291124628864, 0.13478193962171647, 0.11779813200709521, 0.07623547359177063, 0.1297409415271703, 0.0824032568032873, 0.12463889413029372, 0.094135162256476, 0.0855220732007308, 0.10170895399132585, 0.05844743655340756, 0.09192462306985416, 0.9377510760811102, 0.921618427242608, 0.9177936328319375, 0.913665471356257, 0.9302835765887493, 0.9131270521291748, 0.9368924719640629, 0.9478177833888778, 0.9232378661492335, 0.6727237479396322, 0.6987442362984632, 0.7247685600397296, 0.6806227583639143, 0.5648616986035494, 0.15145380408941256, 0.6450057099369693, 0.6052321004889798, 0.7044000626455631, 0.23044721331802442, 0.16964139090986952, 0.13927183271189691, 0.9004580752617931, 0.9285975973659563, 0.8226775798501159, 0.1781666355579189, 0.17800621742133194, 0.8252753932477771, 0.13624036825833796, 0.1353845525030809, 0.48714621960466475, 0.5096279018867999, 0.5696215553117543, 0.13312279751510725, 0.6254578870082087, 0.13580335574730928, 0.49365406271152945, 0.5298432366329708, 0.49261611341194333, 0.6647619381648262, 0.7985558563147419, 0.45149035971807516, 0.526506902891405, 0.5849442047661323, 0.7397096820573418, 0.47629830571880427, 0.042377466545145626, 0.1636324730629356, 0.12508799583580565, 0.12402641385916591, 0.1621764645556235, 0.08911238308523184, 0.10076662998312913, 0.189208003713201, 0.15893777375211726, 0.20885306129919423, 0.17030023309021436, 0.3802276867202329, 0.10522995345995134, 0.1404972684137572, 0.05823525372078786, 0.32805666384394927, 0.25201720102270997, 0.2927162667231499, 0.23788000040070778, 0.1597959756597922, 0.3079686818968178, 0.20294124316617745, 0.13029006029245416, 0.12227188384059173, 0.2961978523482478, 0.20187541859633396, 0.08416728532963957, 0.35173160149797544, 0.19028591937232864, 0.30602468794390714, 0.19610587628311738, 0.31014172981407184, 0.03085110554564685, 0.2122741275632618, 0.3441964548064814, 0.1993732087911183, 0.7713205291127443, 0.7673015642526109, 0.7986960472086123, 0.7552337335266277, 0.6995376313764758, 0.7044866546025724, 0.7729051040417425, 0.7179080228847757, 0.6139284874848385, 0.08497953635498545, 0.08755735640430684, 0.05423252321693128, 0.1222361701556296, 0.10374194004374626, 0.09501757960587676, 0.14731283320902733, 0.10927225376148031, 0.09078449643111908, 0.5244735122184486, 0.3442786869316483, 0.24380342142467915, 0.2678081947040858, 0.3397566923557179, 0.19688621177407373, 0.5837310901929162, 0.6419303443959209, 0.19394013953094147, 0.4222855771735835, 0.32762929139233143, 0.23604275821827692, 0.5804332522640837, 0.3330940849229703, 0.5058902076698465, 0.2646842313465205, 0.5650338941287363, 0.11155272604611, 0.22675905289776244, 0.2759509768361721, 0.13081221794038866, 0.30324406124320635, 0.24398314454053438, 0.276061242312723, 0.18348145312739383, 0.1943200609520508, 0.10313968244742955, 0.21956806884219637, 0.23650136834743818, 0.19881426220703347, 0.2091248313503672, 0.21580885307423325, 0.19769715497234086, 0.2397124533072128, 0.2391218781423463, 0.23304704613836524, 0.1715422193452789, 0.2238357287221937, 0.19558084225504346, 0.24834411570209713, 0.22975403918301085, 0.18776826438065786, 0.18260475757420525, 0.25091205449711673, 0.19006775663112807, 0.937912975883904, 0.9307859681352824, 0.15327475410954416, 0.9268105661254882, 0.20009866355731787, 0.9182389619787827, 0.9349096359476443, 0.9250477611184039, 0.16857916856081434, 0.9045797367996744, 0.21189148912485967, 0.9317809996040731, 0.21056935925940123, 0.16799844324368618, 0.9163101293438725, 0.8338638889650257, 0.885091127828752, 0.10484137664798854, 0.1739185155214471, 0.17043136740878073, 0.1878546746999723, 0.17532969058733838, 0.18142977411394312, 0.19158268696331882, 0.17293738650435386, 0.18130906685759773, 0.17438158275597382, 0.09626954554301681, 0.08604934872892578, 0.08293293634573551, 0.09634276800579644, 0.09058804755314998, 0.11486727617171488, 0.08769516322488202, 0.07947718540116144, 0.09087311271922627]}, "mutation_prompt": null}
{"id": "104982d0-6805-473d-9974-77fb6b712f83", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.5 * np.exp(-evaluations / self.budget)  # Line changed: Enhanced dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.3 * (self.positions[b] - self.positions[c])  # Line changed\n                    mutant_vector += 0.1 * (global_best_position - self.positions[a])  # Line added: Global best influence\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhanced mutation strategy and social coefficient adaptation for improved convergence.", "configspace": "", "generation": 35, "fitness": 0.37675245485119185, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8456719991164299, 0.8701663232293922, 0.8699098261890119, 0.8516071723558768, 0.8674087070193398, 0.8539603678113731, 0.8550135846635103, 0.846745607105922, 0.8749204042717629, 0.6783037009757908, 0.5074495117309685, 0.6297747148240679, 0.6469310069051679, 0.6291514571829409, 0.5819254283917236, 0.5634231754009613, 0.607696130812287, 0.5014367928015315, 0.067786638100084, 0.11432902290368552, 0.08036105733956589, 0.0659927967491798, 0.11196156706778837, 0.10912614135569587, 0.12167706405498924, 0.1255398473680276, 0.11068455101456098, 0.09054170214446333, 0.11736019469662351, 0.06630180654040829, 0.12444360645722319, 0.11376667116503392, 0.10179996313354767, 0.10024479439405443, 0.0917983307335779, 0.10550370304791701, 0.9225089505164119, 0.9148310029913904, 0.9116142488664347, 0.9161474640058583, 0.9099967381614771, 0.933918949355901, 0.9091971161613971, 0.9507210970631631, 0.9346638665487571, 0.5742722526930628, 0.6109402967742328, 0.5686217160166407, 0.4624598829551768, 0.5075433275178831, 0.6063501745241955, 0.6512965735569662, 0.6106315011374002, 0.5260620081793694, 0.22985528374297792, 0.1349843688371879, 0.8555015882019346, 0.21034119124243866, 0.2804783574955858, 0.27537665873877726, 0.22796089587608281, 0.8947191756009663, 0.17747233757293013, 0.12949215869661945, 0.6898825023317567, 0.5280226740252774, 0.40957261801136413, 0.4514345379771987, 0.4125082890871766, 0.5756392815357034, 0.13377849654457585, 0.5810211405756696, 0.5351983399486562, 0.5489018202423461, 0.6930358431864045, 0.13499328291227064, 0.5546797920606702, 0.5318607100576089, 0.5460884472302461, 0.5868502570231988, 0.5428863618672976, 9.999999999998899e-05, 0.07076643493229551, 0.43835100162746143, 0.3025347469664361, 0.1805524823310528, 0.10256167875673017, 0.24879055932985517, 0.09562924347595547, 0.36563579088273734, 0.47150911065527223, 0.21750210696556416, 0.16964161447498005, 0.27514225925522284, 0.14788212669235035, 0.08031131659620439, 0.34112469742190066, 0.1471705622545132, 0.21170796494317623, 0.19366184808299625, 0.2247309474471222, 0.24525107575158112, 0.16378650635672765, 0.2682439527505035, 0.18360985396011187, 0.28043465410378143, 0.13569124739388794, 0.07254600800453359, 0.18376724146306855, 0.16780512867635167, 0.24495761622899737, 0.3208524563272205, 0.29633651233321245, 0.2787158431189337, 0.12422120179444351, 0.08193004778719604, 0.10387166262431324, 0.7516390386910163, 0.7132384006286476, 0.738655640257742, 0.7365352138820143, 0.7440816316521812, 0.7375706563478193, 0.7494343086418798, 0.688801979227083, 0.7783282637343402, 0.045098012848219016, 0.10287214693668034, 0.08992345355018572, 0.08789727952799731, 0.12040593183910497, 0.1596347932837754, 0.11557912495843337, 0.15187168792537398, 0.09352524277923291, 0.3040317182197114, 0.26953137687895545, 0.7037264320414006, 0.18810862584908228, 0.36166413918009244, 0.19746323686132117, 0.629931399685282, 0.22505064396563457, 0.20672758719020878, 0.2396829464188177, 0.26158814037753586, 0.23291548776787063, 0.44230506290765625, 0.27630379230477775, 0.2901084685608656, 0.1767113896112139, 0.5041255644333149, 0.15729095754850553, 0.23664656607485246, 0.3094160999465747, 0.19343966534263068, 0.2745784281834758, 0.49072580954745204, 0.2582501458966908, 0.19823323693325146, 0.2782586600138729, 0.09582193567625985, 0.21379314688775986, 0.2193270438011925, 0.21688327363601234, 0.20178361167149805, 0.23258411813372792, 0.21929450050163912, 0.24272458440328237, 0.21106868343677232, 0.24554580261608905, 0.18788203837304285, 0.21343484370643995, 0.19003107121663565, 0.24581429099366792, 0.21378592754293058, 0.1771209100521679, 0.22360187767656103, 0.2263436524669069, 0.18910318206323695, 0.9379295516135068, 0.9251085632766718, 0.10315623188266543, 0.940648896357845, 0.2001693118018657, 0.9217125142975605, 0.9198057185279818, 0.898602672871773, 0.16857443921922755, 0.900923070274909, 0.21279176661973187, 0.9067301064851445, 0.21173531568082704, 0.16757454127915772, 0.910972560303115, 0.8807114206239645, 0.8305812819184891, 0.8362275365233798, 0.18494966111975542, 0.18266455796089964, 0.16898927850816292, 0.178538648948823, 0.1750240764933173, 0.18569795374934006, 0.17097780470000767, 0.17805886893204714, 0.1817556575237843, 0.09108958945283507, 0.08545790305791057, 0.07881323615461588, 0.07812410239060885, 0.08070446047217994, 0.10749233619030585, 0.07942667923233127, 0.09187226899037837, 0.09472833264391467]}, "mutation_prompt": null}
{"id": "2eb55843-02b2-4ace-b3c6-68e819b1498f", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce an adaptive local leader selection to balance exploration and exploitation dynamically.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8809497434737135, 0.8848332269903204, 0.872570886152797, 0.8574847414003834, 0.8943101891275396, 0.9004349162091958, 0.896744504723235, 0.859318924743454, 0.8910728783455985, 0.6976644997820585, 0.7034925050625598, 0.6389937501857749, 0.7122688141106827, 0.6401840605585989, 0.6727944949237297, 0.620754983673673, 0.7050799553665797, 0.6437417304927942, 0.08274578663738452, 0.10963948921470201, 0.0815367569156712, 0.10776035599064948, 0.08495250439051072, 0.12346446672674716, 0.1169291124628864, 0.13478193962171647, 0.11779813200709521, 0.07623547359177063, 0.1297409415271703, 0.0824032568032873, 0.12463889413029372, 0.094135162256476, 0.0855220732007308, 0.10170895399132585, 0.05844743655340756, 0.09192462306985416, 0.9377510760811102, 0.921618427242608, 0.9177936328319375, 0.913665471356257, 0.9302835765887493, 0.9131270521291748, 0.9368924719640629, 0.9478177833888778, 0.9232378661492335, 0.6727237479396322, 0.6987442362984632, 0.7247685600397296, 0.6806227583639143, 0.5648616986035494, 0.15145380408941256, 0.6450057099369693, 0.6052321004889798, 0.7044000626455631, 0.23044721331802442, 0.16964139090986952, 0.13927183271189691, 0.9004580752617931, 0.9285975973659563, 0.8226775798501159, 0.1781666355579189, 0.17800621742133194, 0.8252753932477771, 0.13624036825833796, 0.1353845525030809, 0.48714621960466475, 0.5096279018867999, 0.5696215553117543, 0.13312279751510725, 0.6254578870082087, 0.13580335574730928, 0.49365406271152945, 0.5298432366329708, 0.49261611341194333, 0.6647619381648262, 0.7985558563147419, 0.45149035971807516, 0.526506902891405, 0.5849442047661323, 0.7397096820573418, 0.47629830571880427, 0.042377466545145626, 0.1636324730629356, 0.12508799583580565, 0.12402641385916591, 0.1621764645556235, 0.08911238308523184, 0.10076662998312913, 0.189208003713201, 0.15893777375211726, 0.20885306129919423, 0.17030023309021436, 0.3802276867202329, 0.10522995345995134, 0.1404972684137572, 0.05823525372078786, 0.32805666384394927, 0.25201720102270997, 0.2927162667231499, 0.23788000040070778, 0.1597959756597922, 0.3079686818968178, 0.20294124316617745, 0.13029006029245416, 0.12227188384059173, 0.2961978523482478, 0.20187541859633396, 0.08416728532963957, 0.35173160149797544, 0.19028591937232864, 0.30602468794390714, 0.19610587628311738, 0.31014172981407184, 0.03085110554564685, 0.2122741275632618, 0.3441964548064814, 0.1993732087911183, 0.7713205291127443, 0.7673015642526109, 0.7986960472086123, 0.7552337335266277, 0.6995376313764758, 0.7044866546025724, 0.7729051040417425, 0.7179080228847757, 0.6139284874848385, 0.08497953635498545, 0.08755735640430684, 0.05423252321693128, 0.1222361701556296, 0.10374194004374626, 0.09501757960587676, 0.14731283320902733, 0.10927225376148031, 0.09078449643111908, 0.5244735122184486, 0.3442786869316483, 0.24380342142467915, 0.2678081947040858, 0.3397566923557179, 0.19688621177407373, 0.5837310901929162, 0.6419303443959209, 0.19394013953094147, 0.4222855771735835, 0.32762929139233143, 0.23604275821827692, 0.5804332522640837, 0.3330940849229703, 0.5058902076698465, 0.2646842313465205, 0.5650338941287363, 0.11155272604611, 0.22675905289776244, 0.2759509768361721, 0.13081221794038866, 0.30324406124320635, 0.24398314454053438, 0.276061242312723, 0.18348145312739383, 0.1943200609520508, 0.10313968244742955, 0.21956806884219637, 0.23650136834743818, 0.19881426220703347, 0.2091248313503672, 0.21580885307423325, 0.19769715497234086, 0.2397124533072128, 0.2391218781423463, 0.23304704613836524, 0.1715422193452789, 0.2238357287221937, 0.19558084225504346, 0.24834411570209713, 0.22975403918301085, 0.18776826438065786, 0.18260475757420525, 0.25091205449711673, 0.19006775663112807, 0.937912975883904, 0.9307859681352824, 0.15327475410954416, 0.9268105661254882, 0.20009866355731787, 0.9182389619787827, 0.9349096359476443, 0.9250477611184039, 0.16857916856081434, 0.9045797367996744, 0.21189148912485967, 0.9317809996040731, 0.21056935925940123, 0.16799844324368618, 0.9163101293438725, 0.8338638889650257, 0.885091127828752, 0.10484137664798854, 0.1739185155214471, 0.17043136740878073, 0.1878546746999723, 0.17532969058733838, 0.18142977411394312, 0.19158268696331882, 0.17293738650435386, 0.18130906685759773, 0.17438158275597382, 0.09626954554301681, 0.08604934872892578, 0.08293293634573551, 0.09634276800579644, 0.09058804755314998, 0.11486727617171488, 0.08769516322488202, 0.07947718540116144, 0.09087311271922627]}, "mutation_prompt": null}
{"id": "2ae882c8-fbd3-4b21-92a7-aefc780161f8", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                adaptive_vel_clamp = (0.5 + evaluations / (2 * self.budget)) * np.array(self.vel_clamp)  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], adaptive_vel_clamp[0], adaptive_vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Incorporate an adaptive velocity clamp mechanism to enhance convergence by dynamically adjusting velocity constraints.", "configspace": "", "generation": 37, "fitness": 0.3588460572445986, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8719492216659344, 0.88995109705597, 0.8965125042186757, 0.8577767450901133, 0.8823446596747453, 0.8880534723538833, 0.8620303215904599, 0.8730403747311307, 0.855378854697395, 0.7333972137213649, 0.6387349718774946, 0.6301223313805075, 0.6919844341178358, 0.7154969654809958, 0.5433962509302319, 0.6713143378721556, 0.6886114916622107, 0.6958551599519202, 0.0640703173342223, 0.09628216317499172, 0.08877856527516836, 0.10139996353134739, 0.1249671223191895, 0.09360270113945646, 0.101866509922799, 0.1145196207761946, 0.1093887407164551, 0.06913656250268163, 0.07143052020487306, 0.05158600326978269, 0.11222832612354483, 0.09232549304847981, 0.0626296389078741, 0.06268617494198292, 0.10572647373305533, 0.05195924290162168, 0.9138188889813291, 0.8894236825593096, 0.8823331711455812, 0.8971914249274678, 0.8856628032220845, 0.8532990574665114, 0.8770042801565952, 0.8762471249746344, 0.8454066083100744, 0.600262958246403, 0.6440615626898549, 0.5390069594657951, 0.7053469662258471, 0.7037382784727403, 0.603017538924653, 0.676444702232829, 0.6178214860163174, 0.7084661564180912, 0.22863192660223075, 0.1409350539303429, 0.13342022005979348, 0.2806209122529313, 0.27759452458833944, 0.21875685958594138, 0.17780140741511985, 0.1508441055689682, 0.15098763225145106, 0.1332109217998665, 0.6788816170557466, 0.4929110301418246, 0.3633968654082561, 0.5138444118522657, 0.467103699208373, 0.6894885240366695, 0.13312104415749215, 0.4899046171667413, 0.6094909411794003, 0.5968807504412813, 0.13203554775332416, 0.6725609535390369, 0.6317918577596049, 0.5495505851275808, 0.7156663230031455, 0.560159830454164, 0.5114736229138362, 0.13406374776641716, 0.13036897537578584, 0.22276792275460344, 0.3366368991900326, 0.111314740388603, 0.04869701691609174, 0.24968746345189663, 0.10091083183010763, 0.2753678674331125, 0.1723800842432469, 0.15057345053840054, 0.3590940589960968, 0.20731223641223073, 0.14825147704849428, 0.09449133460353754, 0.23823207348718767, 0.28646691910026734, 0.355446389015202, 0.1529871035761744, 0.2855576313773217, 0.20616686126371941, 0.21848585941216536, 0.24372766282708203, 0.208623952906955, 0.15505135083034616, 0.1578722328644201, 0.07048702756283787, 0.20321124783378897, 0.23802838525709247, 0.2619126853494804, 0.19211644414273965, 0.22163650316028138, 0.196151036371654, 0.08166586814629806, 0.2616274463126993, 0.08320629055102036, 0.8367915374263256, 0.7233032573417189, 0.7294591283393617, 0.6707022928461367, 0.6394423248491043, 0.635644876940646, 0.7103212896826194, 0.7383231393642125, 0.6613345523423173, 0.03333313649072933, 0.05000710473508441, 0.03438388967316819, 0.09625083912803634, 0.14362347435381217, 0.14653159972376273, 0.16088336293097893, 0.13274214862329958, 0.07676883101087462, 0.6293713819202964, 0.4099559963884346, 0.4908287934834755, 0.602109148862114, 0.40812203603096664, 0.19122002090911394, 0.1913972687275598, 0.20526286913549652, 0.6896661313504948, 0.17443545282578143, 0.2648627206089562, 0.16156035412360092, 0.20724339661672142, 0.2760892468486873, 0.2545670208990032, 0.16077299170619375, 0.535815276922933, 0.12246757095468253, 0.13286106563702893, 0.3115308744535198, 0.2070505333947361, 0.19480154887713008, 0.27856493875812305, 0.19511687839293979, 0.1263923899713847, 0.2698809529450933, 0.08485238180563393, 0.22437912742231514, 0.25517468846821034, 0.21546943864752277, 0.23242767637864126, 0.2031503648782914, 0.18264912918565723, 0.2437574970434887, 0.21200802464999247, 0.20721704812988218, 0.18967530788533415, 0.18982916024456864, 0.1633686955532021, 0.1826554098087646, 0.17313151263217919, 0.17797879106411507, 0.2123301033815077, 0.1836915398876643, 0.16631201324166722, 0.9144281514118535, 0.914234958981365, 0.1111928313322833, 0.1978285847458775, 0.19818621771428746, 0.9156597786330148, 0.15281770281269913, 0.8927758182407116, 0.16794897971068712, 0.8655027371023784, 0.21209294865634654, 0.9137609509979484, 0.2072807540722892, 0.16689423499011957, 0.8454466733513875, 0.8780841956287089, 0.16787951114416533, 0.8065271914116703, 0.17353273184877038, 0.18764272364861345, 0.17788264907216567, 0.17631796114455467, 0.1802364263220837, 0.18403575259160665, 0.185082449712342, 0.18692801114069701, 0.18436614706533017, 0.09231738224391628, 0.08935359893008832, 0.07502386038665099, 0.07952515003340155, 0.09052410686306722, 0.10040306958260392, 0.09164454119816379, 0.09322700699570707, 0.08157795637646337]}, "mutation_prompt": null}
{"id": "62278ae4-0fc4-4991-9842-d519535675e1", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.4 + 0.3 * (1 - evaluations / self.budget)  # Time-varying inertia\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)\n            \n            if evaluations % 5 == 0:  # More frequent local leader selection\n                local_leader_idx = np.argmin(self.personal_best_scores)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce time-varying inertia and strategic local leader selection to enhance convergence.", "configspace": "", "generation": 38, "fitness": 0.3765005838379371, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8587729616017405, 0.8432945074703211, 0.8234143757487751, 0.8042437020719597, 0.823699235988241, 0.8270196332533258, 0.813396116930321, 0.8368986736690875, 0.8177053801068561, 0.5600860939325547, 0.5841701041767098, 0.5807234113937079, 0.6082270463048824, 0.5275101343500039, 0.5773722261836092, 0.5533111330476161, 0.599901597031148, 0.5770514580072554, 0.10713018141454633, 0.11242852617791144, 0.1002954480225231, 0.1049943742940117, 0.13666170305721947, 0.1070475385473485, 0.09193198447212458, 0.4002126474984148, 0.15466291882823857, 0.11097057131226029, 0.1512341540111658, 0.11960480123431538, 0.10939878580555829, 0.10871474194766584, 0.10151898224535694, 0.12115325046814485, 0.11667984571537926, 0.09548454768267856, 0.9477927601660389, 0.9133645650308566, 0.9377348522700462, 0.9114903310500283, 0.9326365061081157, 0.9334823469705591, 0.9235692999006921, 0.9517576852892367, 0.9023626932060146, 0.6113005603053925, 0.5612433611006263, 0.5979810574892013, 0.5488148409408421, 0.6091195684372481, 0.4746734289588421, 0.6018533801620095, 0.5979935844500621, 0.6005342990901659, 0.8744432494504762, 0.2193817468543181, 0.17161111339445978, 0.8079760268469398, 0.27840906738666404, 0.2775136509958236, 0.7016507112071875, 0.3517158677761424, 0.7594872122647247, 0.5651329723391794, 0.131216775734459, 0.5124105808822066, 0.4666371204829214, 0.5690568002096026, 0.5132749616844704, 0.703982673615803, 0.13250852104968436, 0.48990619355579146, 0.5327453900263526, 0.5106519940574257, 0.569209983979341, 0.5518685253411469, 0.6296762320139637, 0.6070549676714759, 0.5420458877213378, 0.6764728913574012, 0.5520722418704264, 0.05819656280282581, 0.07885240154739281, 0.02742717574812481, 0.08737119101396251, 0.005798634259705615, 0.01781778364113995, 0.07788311528659309, 0.23304078288051755, 0.27067462781887575, 0.26837925406669916, 0.18522352935023068, 0.2495003925503655, 0.10011861873013184, 0.13756621961290638, 0.08325562822395238, 0.21262385224077607, 0.2455684987828448, 0.2916296921693724, 0.2880579347165174, 0.11190247981895429, 0.12116819246246302, 0.2384308834242228, 0.07112246731791716, 0.09929541415842524, 0.20007512303348673, 0.07902314918264819, 0.06588229486090491, 0.28626215290452395, 0.269520457992641, 0.1834516476071002, 0.2730121256547966, 0.28657195652249634, 0.32757726778208385, 0.2948120343473718, 0.22329006971751275, 0.2766178415122318, 0.6432822790662687, 0.7486942219121111, 0.7187397381097891, 0.6148411423612283, 0.6421672418423849, 0.6208805372385402, 0.6589762760584166, 0.7290441972784902, 0.6545212018191559, 0.09961563915279514, 0.09082406306112678, 0.13630473227506645, 0.13091964551806845, 0.13856239257991765, 0.13642169651556146, 0.1303843584151071, 0.13477406785657764, 0.14117427374602043, 0.5110755107910192, 0.21498832833446135, 0.34086911637191986, 0.23132060532196352, 0.5991057608307359, 0.4987997722937968, 0.20844825460997196, 0.35779672579039434, 0.33594406154869505, 0.30194709585121915, 0.3163976303210807, 0.18363518199684536, 0.4253117249488968, 0.27512157429911643, 0.4354067544828478, 0.5162472343196062, 0.4856518594975838, 0.28197829127222984, 0.21107951810974235, 0.3697097760255148, 0.19551715316745666, 0.3628523220145542, 0.27577202475981644, 0.27071055180748493, 0.3284042197925493, 0.45746859465028034, 0.2258816556512927, 0.19716486793082866, 0.20688295454890104, 0.22959518579922655, 0.21366922184417558, 0.20348357160621, 0.2012817415733753, 0.19573456786262133, 0.2244905246890626, 0.24156943429384048, 0.2084364315280569, 0.24488154098152226, 0.20597045331105834, 0.23425256784605164, 0.18690124543001796, 0.19542471183067467, 0.20719830788337001, 0.19267102845995132, 0.20551641123522713, 0.8767163336511523, 0.18855628534528102, 0.15350362892535252, 0.11497127187506118, 0.1997032316801688, 0.8869707605868081, 0.895131259870628, 0.9140940288209886, 0.16771366817580624, 0.8756847033416111, 0.2128567401816308, 0.895696583329463, 0.20943380468416795, 0.16759166925374924, 0.8557502937975107, 0.8557144792002378, 0.8558822184622653, 0.887196012272856, 0.18369808535311338, 0.17674395782772612, 0.175243737089822, 0.16974597431166172, 0.17463944652801822, 0.1874026672498833, 0.17296515104981447, 0.1778103627624945, 0.1701275200708371, 0.09319991679894524, 0.08813779354881468, 0.07545330484556911, 0.08144138878585216, 0.09657331108265932, 0.09639591098590394, 0.07720378182077547, 0.09524730980044338, 0.08649301486406835]}, "mutation_prompt": null}
{"id": "58c78945-cf2b-44e9-994b-b955eddae069", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * evaluations / self.budget, 1.0 - 0.5 * evaluations / self.budget)  # Updated line\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n# Updated line below\n                    if func(trial_vector) < func(self.positions[i]): \n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce an adaptive velocity clamping mechanism to enhance convergence stability and control particle exploration.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'trial_vector' is not defined\").", "error": "NameError(\"name 'trial_vector' is not defined\")", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {}, "mutation_prompt": null}
{"id": "c930993a-8007-42c8-b8f8-85527c4a272b", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce an adaptive local leader selection to balance exploration and exploitation dynamically.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8809497434737135, 0.8848332269903204, 0.872570886152797, 0.8574847414003834, 0.8943101891275396, 0.9004349162091958, 0.896744504723235, 0.859318924743454, 0.8910728783455985, 0.6976644997820585, 0.7034925050625598, 0.6389937501857749, 0.7122688141106827, 0.6401840605585989, 0.6727944949237297, 0.620754983673673, 0.7050799553665797, 0.6437417304927942, 0.08274578663738452, 0.10963948921470201, 0.0815367569156712, 0.10776035599064948, 0.08495250439051072, 0.12346446672674716, 0.1169291124628864, 0.13478193962171647, 0.11779813200709521, 0.07623547359177063, 0.1297409415271703, 0.0824032568032873, 0.12463889413029372, 0.094135162256476, 0.0855220732007308, 0.10170895399132585, 0.05844743655340756, 0.09192462306985416, 0.9377510760811102, 0.921618427242608, 0.9177936328319375, 0.913665471356257, 0.9302835765887493, 0.9131270521291748, 0.9368924719640629, 0.9478177833888778, 0.9232378661492335, 0.6727237479396322, 0.6987442362984632, 0.7247685600397296, 0.6806227583639143, 0.5648616986035494, 0.15145380408941256, 0.6450057099369693, 0.6052321004889798, 0.7044000626455631, 0.23044721331802442, 0.16964139090986952, 0.13927183271189691, 0.9004580752617931, 0.9285975973659563, 0.8226775798501159, 0.1781666355579189, 0.17800621742133194, 0.8252753932477771, 0.13624036825833796, 0.1353845525030809, 0.48714621960466475, 0.5096279018867999, 0.5696215553117543, 0.13312279751510725, 0.6254578870082087, 0.13580335574730928, 0.49365406271152945, 0.5298432366329708, 0.49261611341194333, 0.6647619381648262, 0.7985558563147419, 0.45149035971807516, 0.526506902891405, 0.5849442047661323, 0.7397096820573418, 0.47629830571880427, 0.042377466545145626, 0.1636324730629356, 0.12508799583580565, 0.12402641385916591, 0.1621764645556235, 0.08911238308523184, 0.10076662998312913, 0.189208003713201, 0.15893777375211726, 0.20885306129919423, 0.17030023309021436, 0.3802276867202329, 0.10522995345995134, 0.1404972684137572, 0.05823525372078786, 0.32805666384394927, 0.25201720102270997, 0.2927162667231499, 0.23788000040070778, 0.1597959756597922, 0.3079686818968178, 0.20294124316617745, 0.13029006029245416, 0.12227188384059173, 0.2961978523482478, 0.20187541859633396, 0.08416728532963957, 0.35173160149797544, 0.19028591937232864, 0.30602468794390714, 0.19610587628311738, 0.31014172981407184, 0.03085110554564685, 0.2122741275632618, 0.3441964548064814, 0.1993732087911183, 0.7713205291127443, 0.7673015642526109, 0.7986960472086123, 0.7552337335266277, 0.6995376313764758, 0.7044866546025724, 0.7729051040417425, 0.7179080228847757, 0.6139284874848385, 0.08497953635498545, 0.08755735640430684, 0.05423252321693128, 0.1222361701556296, 0.10374194004374626, 0.09501757960587676, 0.14731283320902733, 0.10927225376148031, 0.09078449643111908, 0.5244735122184486, 0.3442786869316483, 0.24380342142467915, 0.2678081947040858, 0.3397566923557179, 0.19688621177407373, 0.5837310901929162, 0.6419303443959209, 0.19394013953094147, 0.4222855771735835, 0.32762929139233143, 0.23604275821827692, 0.5804332522640837, 0.3330940849229703, 0.5058902076698465, 0.2646842313465205, 0.5650338941287363, 0.11155272604611, 0.22675905289776244, 0.2759509768361721, 0.13081221794038866, 0.30324406124320635, 0.24398314454053438, 0.276061242312723, 0.18348145312739383, 0.1943200609520508, 0.10313968244742955, 0.21956806884219637, 0.23650136834743818, 0.19881426220703347, 0.2091248313503672, 0.21580885307423325, 0.19769715497234086, 0.2397124533072128, 0.2391218781423463, 0.23304704613836524, 0.1715422193452789, 0.2238357287221937, 0.19558084225504346, 0.24834411570209713, 0.22975403918301085, 0.18776826438065786, 0.18260475757420525, 0.25091205449711673, 0.19006775663112807, 0.937912975883904, 0.9307859681352824, 0.15327475410954416, 0.9268105661254882, 0.20009866355731787, 0.9182389619787827, 0.9349096359476443, 0.9250477611184039, 0.16857916856081434, 0.9045797367996744, 0.21189148912485967, 0.9317809996040731, 0.21056935925940123, 0.16799844324368618, 0.9163101293438725, 0.8338638889650257, 0.885091127828752, 0.10484137664798854, 0.1739185155214471, 0.17043136740878073, 0.1878546746999723, 0.17532969058733838, 0.18142977411394312, 0.19158268696331882, 0.17293738650435386, 0.18130906685759773, 0.17438158275597382, 0.09626954554301681, 0.08604934872892578, 0.08293293634573551, 0.09634276800579644, 0.09058804755314998, 0.11486727617171488, 0.08769516322488202, 0.07947718540116144, 0.09087311271922627]}, "mutation_prompt": null}
{"id": "66a31449-85ad-492d-bdbf-5518828c000d", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce an adaptive local leader selection to balance exploration and exploitation dynamically.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8809497434737135, 0.8848332269903204, 0.872570886152797, 0.8574847414003834, 0.8943101891275396, 0.9004349162091958, 0.896744504723235, 0.859318924743454, 0.8910728783455985, 0.6976644997820585, 0.7034925050625598, 0.6389937501857749, 0.7122688141106827, 0.6401840605585989, 0.6727944949237297, 0.620754983673673, 0.7050799553665797, 0.6437417304927942, 0.08274578663738452, 0.10963948921470201, 0.0815367569156712, 0.10776035599064948, 0.08495250439051072, 0.12346446672674716, 0.1169291124628864, 0.13478193962171647, 0.11779813200709521, 0.07623547359177063, 0.1297409415271703, 0.0824032568032873, 0.12463889413029372, 0.094135162256476, 0.0855220732007308, 0.10170895399132585, 0.05844743655340756, 0.09192462306985416, 0.9377510760811102, 0.921618427242608, 0.9177936328319375, 0.913665471356257, 0.9302835765887493, 0.9131270521291748, 0.9368924719640629, 0.9478177833888778, 0.9232378661492335, 0.6727237479396322, 0.6987442362984632, 0.7247685600397296, 0.6806227583639143, 0.5648616986035494, 0.15145380408941256, 0.6450057099369693, 0.6052321004889798, 0.7044000626455631, 0.23044721331802442, 0.16964139090986952, 0.13927183271189691, 0.9004580752617931, 0.9285975973659563, 0.8226775798501159, 0.1781666355579189, 0.17800621742133194, 0.8252753932477771, 0.13624036825833796, 0.1353845525030809, 0.48714621960466475, 0.5096279018867999, 0.5696215553117543, 0.13312279751510725, 0.6254578870082087, 0.13580335574730928, 0.49365406271152945, 0.5298432366329708, 0.49261611341194333, 0.6647619381648262, 0.7985558563147419, 0.45149035971807516, 0.526506902891405, 0.5849442047661323, 0.7397096820573418, 0.47629830571880427, 0.042377466545145626, 0.1636324730629356, 0.12508799583580565, 0.12402641385916591, 0.1621764645556235, 0.08911238308523184, 0.10076662998312913, 0.189208003713201, 0.15893777375211726, 0.20885306129919423, 0.17030023309021436, 0.3802276867202329, 0.10522995345995134, 0.1404972684137572, 0.05823525372078786, 0.32805666384394927, 0.25201720102270997, 0.2927162667231499, 0.23788000040070778, 0.1597959756597922, 0.3079686818968178, 0.20294124316617745, 0.13029006029245416, 0.12227188384059173, 0.2961978523482478, 0.20187541859633396, 0.08416728532963957, 0.35173160149797544, 0.19028591937232864, 0.30602468794390714, 0.19610587628311738, 0.31014172981407184, 0.03085110554564685, 0.2122741275632618, 0.3441964548064814, 0.1993732087911183, 0.7713205291127443, 0.7673015642526109, 0.7986960472086123, 0.7552337335266277, 0.6995376313764758, 0.7044866546025724, 0.7729051040417425, 0.7179080228847757, 0.6139284874848385, 0.08497953635498545, 0.08755735640430684, 0.05423252321693128, 0.1222361701556296, 0.10374194004374626, 0.09501757960587676, 0.14731283320902733, 0.10927225376148031, 0.09078449643111908, 0.5244735122184486, 0.3442786869316483, 0.24380342142467915, 0.2678081947040858, 0.3397566923557179, 0.19688621177407373, 0.5837310901929162, 0.6419303443959209, 0.19394013953094147, 0.4222855771735835, 0.32762929139233143, 0.23604275821827692, 0.5804332522640837, 0.3330940849229703, 0.5058902076698465, 0.2646842313465205, 0.5650338941287363, 0.11155272604611, 0.22675905289776244, 0.2759509768361721, 0.13081221794038866, 0.30324406124320635, 0.24398314454053438, 0.276061242312723, 0.18348145312739383, 0.1943200609520508, 0.10313968244742955, 0.21956806884219637, 0.23650136834743818, 0.19881426220703347, 0.2091248313503672, 0.21580885307423325, 0.19769715497234086, 0.2397124533072128, 0.2391218781423463, 0.23304704613836524, 0.1715422193452789, 0.2238357287221937, 0.19558084225504346, 0.24834411570209713, 0.22975403918301085, 0.18776826438065786, 0.18260475757420525, 0.25091205449711673, 0.19006775663112807, 0.937912975883904, 0.9307859681352824, 0.15327475410954416, 0.9268105661254882, 0.20009866355731787, 0.9182389619787827, 0.9349096359476443, 0.9250477611184039, 0.16857916856081434, 0.9045797367996744, 0.21189148912485967, 0.9317809996040731, 0.21056935925940123, 0.16799844324368618, 0.9163101293438725, 0.8338638889650257, 0.885091127828752, 0.10484137664798854, 0.1739185155214471, 0.17043136740878073, 0.1878546746999723, 0.17532969058733838, 0.18142977411394312, 0.19158268696331882, 0.17293738650435386, 0.18130906685759773, 0.17438158275597382, 0.09626954554301681, 0.08604934872892578, 0.08293293634573551, 0.09634276800579644, 0.09058804755314998, 0.11486727617171488, 0.08769516322488202, 0.07947718540116144, 0.09087311271922627]}, "mutation_prompt": null}
{"id": "40e01dd9-592d-4da0-b166-785c297e52bb", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    dynamic_factor = 0.3 + 0.4 * (evaluations / self.budget)  # Change 1\n                    mutant_vector = self.positions[a] + dynamic_factor * (self.positions[b] - self.positions[c])  # Change 2\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance adaptive mutation by incorporating dynamic components influenced by evaluation progress.", "configspace": "", "generation": 42, "fitness": 0.36466790461653376, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8961240007350835, 0.9024931760780462, 0.9031198119768773, 0.881342800285186, 0.8856652703300625, 0.8931522885062819, 0.8892806796308208, 0.8673166928896574, 0.8681297746232943, 0.7365004574996887, 0.6670658418137941, 0.703746147098095, 0.6526797610796216, 0.6756862585064269, 0.6610472177692301, 0.6634340634467474, 0.6721628749844579, 0.660250639856734, 0.08930381314886637, 0.10112890321755807, 0.07190014931742739, 0.0957656509176209, 0.11142321722438542, 0.07301967146626631, 0.10440666958769185, 0.13362073148754083, 0.10330187422378911, 0.07140136563739252, 0.07262732686270468, 0.06640430284769905, 0.09109181790479093, 0.11509434620125836, 0.07890783748827779, 0.09123341251113559, 0.12530480299006908, 0.06755137065091077, 0.9346859568639122, 0.9268672358549127, 0.9150150005886157, 0.9293719413549516, 0.9226868528314828, 0.9134747378216074, 0.9201260054483418, 0.9454573937023195, 0.9326143659139363, 0.6214349776734807, 0.6292730768866228, 0.7288018834093181, 0.5394180347334829, 0.5496399366904039, 0.6413727284204416, 0.6244815869204852, 0.6821741392012994, 0.627423499140801, 0.2471467127661311, 0.13952791675153187, 0.20780299823253956, 0.2693141702466423, 0.3766485264373264, 0.24093770336034315, 0.12856481480341886, 0.13099121613068132, 0.22016515017415905, 0.13294045455260672, 0.13574964872619644, 0.3701641015719702, 0.5566664594455135, 0.6870292464328033, 0.41022802795297253, 0.5287386697435019, 0.13502248843714115, 0.5971095237496735, 0.46757855196888054, 0.5751807669092783, 0.1358566282407766, 0.13622193461327037, 0.49304911808907015, 0.13459851412982493, 0.7125011997850597, 0.5844188020846959, 0.55554061096438, 0.24918191401607792, 0.0029770359588308093, 0.25914884430493024, 0.07118372711921417, 0.2732260881532308, 0.14443313905303135, 0.09718037691267423, 0.11116482871569566, 0.07132113604021428, 0.20943082278196112, 0.4163030892651788, 0.22945924854453903, 0.1384770582930248, 0.08065505261290762, 0.045231870404248364, 0.2903465136849698, 0.14893137533658207, 0.19267993615439505, 0.29167195867176265, 0.19609582711387485, 0.20850730944570373, 0.1690227915937399, 0.20291561247866907, 0.25142716147347843, 0.2674350729364714, 0.18888834311114278, 0.07165887733100285, 0.25525143458255917, 0.2910856822136557, 0.478897489863213, 0.18865738267145493, 0.26082150708779284, 0.1882960921912189, 0.08182718398849975, 0.20705464565723664, 0.08370152456169977, 0.60120196378482, 0.7331455655934243, 0.7764825341214376, 0.6885511384840333, 0.7163533956182755, 0.785787255951817, 0.7340777007030256, 0.7764507234577313, 0.7344453693511674, 0.058502909835874584, 0.054496576693930376, 0.08263947388893156, 0.1181882997278586, 0.10923691158781401, 0.12141583266471678, 0.14598137716178317, 0.1155163674922558, 0.11571822357952755, 0.27139552313449256, 0.19917718173484777, 0.2701571927668429, 0.17049411016069171, 0.5852050592259725, 0.7163212668676289, 0.6521882809135895, 0.20732181163636754, 0.21841235634088718, 0.2744774281672233, 0.31093155623013824, 0.23568286040682107, 0.5168856316275949, 0.3322768830708177, 0.1988440338581019, 0.18555359916928715, 0.2578502346298537, 0.19814986782742727, 0.12052100134267385, 0.2035285508726401, 0.19868441121271985, 0.21570111735813802, 0.24393770704982676, 0.18388869794076468, 0.20919852159554753, 0.194168933409553, 0.09378561138530239, 0.23343196124371013, 0.23780357485456727, 0.2135467496032688, 0.24437317882851073, 0.22050424931123147, 0.177400993843574, 0.21920042191558553, 0.24875230703815499, 0.22095776905565379, 0.20354867226758655, 0.20044431370072957, 0.17767769786461363, 0.1857174309895051, 0.20998110851880314, 0.17411938224248258, 0.1646927350633397, 0.20761495863128, 0.1803695191409066, 0.9366758297362404, 0.1878945325101361, 0.15279768800157179, 0.9321644954321616, 0.1993923927132314, 0.9286024449813334, 0.9258723858846124, 0.9200176686163497, 0.16883287157602123, 0.8729219069556816, 0.21341423499893608, 0.8627545999582582, 0.8643013637246728, 0.1674749159544523, 0.8432055446794533, 0.8533125641224779, 0.8752633849635661, 0.7855066995268225, 0.18408932886848872, 0.1800354400681572, 0.1835230064802753, 0.1930093919475484, 0.1784866006790915, 0.17273147638988795, 0.17409425316023774, 0.18937942679225028, 0.18877616640371064, 0.09820247892759248, 0.1359112891562665, 0.07411244676532136, 0.08522004591779309, 0.08044310737198868, 0.10807355829447751, 0.08868331938513474, 0.08665056913405311, 0.0721256084681765]}, "mutation_prompt": null}
{"id": "0c47642e-af6c-4dcb-8071-f1bb00b79724", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.6 + 0.4 * np.sin(2 * np.pi * evaluations / self.budget)  # Periodically evolving mutation rate\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Integrate a periodically evolving mutation rate for enhanced exploration.", "configspace": "", "generation": 43, "fitness": 0.35778865343699, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.9064229023342618, 0.9099458640250361, 0.8796222892281816, 0.8873796055290935, 0.8998288369620779, 0.8981064114562596, 0.875427259021051, 0.8981330709909279, 0.8782770286451413, 0.7036543397058872, 0.7089328856421527, 0.7273991567502809, 0.702021281968113, 0.6736466634226269, 0.5663693085059536, 0.6452963718398821, 0.701515474365207, 0.6336572031936378, 0.07361737452186956, 0.07823350711042765, 0.03736508102035918, 0.10791501218760846, 0.11237662709120655, 0.12395932622811523, 0.10843708581796418, 0.07679586578376696, 0.12181757124205728, 0.06302528577504929, 0.11578345014642677, 0.07033973375095515, 0.09778946419924817, 0.08829146102447627, 0.09128012911522021, 0.06752497984360195, 0.09260921587933424, 0.10666048279717721, 0.9379813697388275, 0.9296489557662637, 0.9351745296314842, 0.9337233064616033, 0.8894212394084788, 0.9405634021100677, 0.9127569891704015, 0.8829022142165803, 0.8979479897214416, 0.7537336632483264, 0.4645975918402251, 0.743092995095064, 0.6486079439638839, 0.6153735547509303, 0.5543952408217236, 0.6421482718705318, 0.5781536706793093, 0.6775907128046763, 0.23011973869739977, 0.16773702050812367, 0.16552676645878495, 0.2774672742294755, 0.21412134322932574, 0.28168592175983154, 0.1760546830495967, 0.12853055945824277, 0.17875370181815142, 0.6106271985841178, 0.5729270028547164, 0.43865754512479094, 0.6943269769710246, 0.44483432238, 0.6415662193960536, 0.6758461631758348, 0.1352215411754758, 0.7146030101179699, 0.5562256153473779, 0.593715038895228, 0.6657106941800286, 0.5913079431455075, 0.5796365235530752, 0.5513737657956012, 0.7189538166404896, 0.5285557687247197, 0.5549506696623101, 0.08319459098959536, 0.14915698939272648, 0.13683101347414428, 0.128702800638679, 0.09795176948431017, 0.11793575625375052, 0.10945913647353522, 0.0917912562710238, 0.19056610188392664, 0.2832844135772238, 0.1581134571601135, 0.13294180295005176, 0.19383583602644494, 0.09499365024137918, 0.062301407508108975, 0.1802856914663924, 0.48385464492258157, 0.21179133278273443, 0.23072266566622257, 0.1716159643469295, 0.29019369594321076, 0.08370959730186955, 0.20433627471851534, 0.22721212711931282, 0.19922660169383277, 0.15416934918783443, 0.08697920072608545, 0.21030888737877962, 0.2538626971925848, 0.2882476567744534, 0.22061907421411842, 0.2076683404229066, 0.347092277252374, 0.19316405342591048, 0.24419578700621136, 0.21025386550493774, 0.7963994579461482, 0.7244726891059079, 0.7702573563904598, 0.6641540214766545, 0.6481946017412472, 0.7278211974902544, 0.7579035990418327, 0.7456116515548259, 0.755385388146252, 0.06578858650318997, 0.08068655963509497, 0.10164499359368184, 0.0920137721575719, 0.05896221764949072, 0.10062481042922533, 0.12350325230260917, 0.12277571703106294, 0.08318897617692567, 0.2797330182403901, 0.2573109424294272, 0.2314300527612041, 0.49429218879209025, 0.49311509080766136, 0.18030218331112935, 0.1746181647475934, 0.3322165814068738, 0.421126616241729, 0.2101521617894866, 0.22479244475792493, 0.18654624716715518, 0.1979404874893982, 0.3163457942821446, 0.4560832107842242, 0.1675756634518153, 0.3305633726920403, 0.16011437578914012, 0.2273600845335747, 0.25582143456456274, 0.2238056290071161, 0.25716280186887597, 0.2975831008001494, 0.17265587705405527, 0.1937811489068647, 0.2640216329876103, 0.09060114611451009, 0.2162894644781912, 0.22342550321885302, 0.20806765889033618, 0.20624830963439333, 0.21186709560825046, 0.2175701454792074, 0.20309009612022966, 0.24166442614291583, 0.2102591279808549, 0.17991514904971173, 0.20128388231388172, 0.1895077755620701, 0.19075471431255708, 0.1976466157433181, 0.1839670030602938, 0.1902645338907608, 0.19482717518159431, 0.18551121389898817, 0.1881093408363237, 0.18874317849896471, 0.18821842543320677, 0.17264552996104487, 0.20131424578043966, 0.9434156293587103, 0.12311338497528701, 0.16981736338673292, 0.16620842187566653, 0.882145879165022, 0.21142102462054901, 0.8650687700987425, 0.2117296309591984, 0.1554301479819391, 0.9403501936182843, 0.7705356955032128, 0.9040593780790305, 0.8874405545368667, 0.18683395923430446, 0.19272835899175156, 0.17622499067209696, 0.16899129025404147, 0.18272603062262016, 0.17895055828189288, 0.16951867015556144, 0.17446538494800023, 0.17995505370506293, 0.10294372401727792, 0.1130657740420582, 0.08788416651758102, 0.08871393060947141, 0.09221203203189166, 0.12029667338684935, 0.08276186783076223, 0.07545198300183642, 0.083379866973457]}, "mutation_prompt": null}
{"id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 44, "fitness": 0.3911387669865817, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.29.", "error": "", "parent_id": "a3c67dcc-11fe-4a21-bbf3-99887c4be5c7", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "0abcc88d-b0bd-461f-b5b8-5cb91bf37d3d", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "d3314e6b-286b-43cf-ada1-c6f8b76a4409", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "2c5400cd-2990-4f4b-b327-0e931243e198", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # New line to adjust local leader attraction\n                leader_attraction = 0.05 * np.random.rand() * (local_best_position - self.positions[i])\n                self.positions[i] += leader_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic local leader attraction mechanism to improve exploration and convergence efficiency.", "configspace": "", "generation": 47, "fitness": 0.36312278010919186, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9090195164238678, 0.8828911650973187, 0.8935250169507051, 0.8630276549148672, 0.866198568298598, 0.9082777051273391, 0.8792692295640383, 0.8717881660905726, 0.8654509477234579, 0.7063658253652274, 0.7694349103325423, 0.7436763131816974, 0.697293350217605, 0.6020624943324555, 0.7245668678983135, 0.7115368025380778, 0.7008499011121482, 0.7229207898257523, 0.10467767279995877, 0.09983172029768317, 0.14343774505939633, 0.09725633796445687, 0.09171429392975494, 0.10938749274122406, 0.11116798600239142, 0.10365526714307105, 0.15938434392038747, 0.07946832621275657, 0.12029709371897657, 0.07861521799346427, 0.11912176447800449, 0.09575601752351126, 0.09062175335265199, 0.09254383606747141, 0.04931622576008177, 0.08219460982502647, 0.9281294203797242, 0.8970807940415402, 0.9315369081874478, 0.9127432322374829, 0.8970976364262763, 0.9044238760656156, 0.9235784624100498, 0.9092591135749079, 0.9115811432459436, 0.7122845230331913, 0.6456025582689913, 0.7158680928180288, 0.735027664242681, 0.6978771935426562, 0.6713546784721133, 0.7053018054318434, 0.6662856011947628, 0.7331160713787951, 0.21152897935076842, 0.14107434370320315, 0.17150707465317683, 0.35708013563101826, 0.13722351421959844, 0.27672483581353213, 0.15941106055903387, 0.15223066455583412, 0.2357512791034424, 0.13302106415207693, 0.6555552131757668, 0.5858257127731981, 0.4592312475224245, 0.29597505082954956, 0.6592022160053042, 0.5077232650067209, 0.442533525729531, 0.6947776914067234, 0.13616199340883173, 0.5492078297638749, 0.13455742119209502, 0.5608763003973392, 0.5867199550926316, 0.5123190179171264, 0.5610766865510279, 0.12909870559742775, 0.5268144309047722, 0.24889012262763976, 0.2114208010196552, 0.22440578716672532, 0.22412241435642477, 0.3079704279422364, 0.13103986382606525, 0.11020014619321805, 0.1351063554889964, 0.14359705224046904, 0.3072114889523616, 0.2969196080656731, 0.24603215145156676, 0.2587776445058887, 0.1241710989161755, 0.09783906808370646, 0.4513404734331271, 0.23819242392700035, 0.23286690047077718, 0.09898931791297805, 0.1688272174541222, 0.1119245429253104, 0.13729859213722606, 0.19544847265638432, 0.16850689075801673, 0.14350508974744058, 0.1418242814085252, 0.15833846872750568, 0.2611538510407976, 0.13377433588349763, 0.18575395963050556, 0.24066098589810636, 0.34862555587422306, 0.21297981477702055, 0.2624490447809833, 0.05641313143949833, 0.25251481511655116, 0.7157144913010629, 0.7197767207088902, 0.7200727263390878, 0.6964711304245812, 0.6154332268736702, 0.6399599983248159, 0.6578440576059899, 0.7327372435168613, 0.6970752608470324, 0.1115580281148304, 0.06829261376094187, 0.12187107916599127, 0.08604676380607867, 0.10831020212783182, 0.08418401955046995, 0.09267542183664812, 0.11577762028324923, 0.11217701006623415, 0.5537142549747145, 0.3971134970100776, 0.2210308429461325, 0.31433345216796493, 0.5780040882136649, 0.20033915830689142, 0.20727117198650724, 0.21693124419802967, 0.2005709550016681, 0.32921524734102814, 0.31491037570616587, 0.19008529720225076, 0.44802159223163207, 0.49491985832601804, 0.32874292336845956, 0.26866538980037713, 0.5253396979834557, 0.11196143216530252, 0.156375445022768, 0.40421710138301536, 0.24698145069193023, 0.2848943569411819, 0.4804496789524674, 0.21561015345225565, 0.22146814291439176, 0.24510143745013702, 0.2575678507106556, 0.22327051102055007, 0.21128221971597905, 0.22300411325196323, 0.2443275048870207, 0.24367104330439537, 0.2353066826131519, 0.23579604631388518, 0.26333224095414887, 0.21089579601963837, 0.1819956454221826, 0.17547058165594787, 0.22588157302151102, 0.8299719566115816, 0.19781015926283352, 0.19100620474162477, 0.19385428769493218, 0.1694556629132108, 0.18425325001434045, 0.1791432196030761, 0.18860948211777018, 0.1532818735572018, 0.17292306188237383, 0.2010327131874161, 0.9160031531761924, 0.12234738883393748, 0.9007116931448633, 0.8655346252514318, 0.9137936752900594, 0.21252967606029094, 0.8570377833095122, 0.21060812683420416, 0.21375144673632251, 0.20950326552830834, 0.8380957005421903, 0.1657246657469672, 0.8721640812336138, 0.17710464473553256, 0.19303842850581998, 0.17322638684601788, 0.1985299281849856, 0.17396160322598098, 0.1735377974516743, 0.18545400176605753, 0.1728174019546601, 0.17956610501720083, 0.08750066373841492, 0.08387474878228163, 0.08725908041123054, 0.08767774854038812, 0.08391706236926877, 0.09723879022880755, 0.08529399248654534, 0.09182567775019435, 0.07244850244301393]}, "mutation_prompt": null}
{"id": "9731e7e1-3695-4d16-8c49-e9d340f51ccb", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "e4140759-c875-47ce-b467-1f8b62c427f6", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.memory = []\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n\n                if evaluations % 50 == 0:  # Reinitialize based on memory every 50 evaluations\n                    if len(self.memory) > 0:\n                        memory_idx = np.random.choice(len(self.memory))\n                        self.positions[i] = self.memory[memory_idx]\n                    else:\n                        self.memory.append(self.positions[i])\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a memory-based reinitialization strategy to diversify the search process and avoid local optima.", "configspace": "", "generation": 49, "fitness": 0.33237882285109344, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8823305776185839, 0.8792643768357713, 0.8813233004045967, 0.8669124005960255, 0.838714696178765, 0.9054033421915302, 0.8486555815407546, 0.8672106699408598, 0.8489237150586775, 0.5664804392624506, 0.6257299848333715, 0.4031337549045577, 0.6769129792131668, 0.7257225394788401, 0.5273962498838478, 0.48460614909703503, 0.6976166224695015, 0.6058344483016724, 0.06413629969767831, 0.12043024818033266, 0.07031754420310332, 0.09568952505705897, 0.11171787919775611, 0.12279276702673037, 0.16082879943716544, 0.14388645013841073, 0.11855976356718678, 0.09326979967649351, 0.09696431345757062, 0.07574826538904877, 0.11131499478267692, 0.09950273155450051, 0.04892700527416982, 0.10725173924202025, 0.08412563571497955, 0.07219476022299898, 0.8857306019270286, 0.9150083474924494, 0.9058983751137805, 0.8626628819505314, 0.9138304884877261, 0.8883925728727119, 0.9124730357604451, 0.926633328324764, 0.88718823357028, 0.6584129680216975, 0.5422470878881012, 0.6358959327057752, 0.665298614639205, 0.6311212968685145, 0.5803573056197661, 0.7457081501791848, 0.6458936106977025, 0.460246215705586, 0.23107432647928994, 0.13174026343002787, 0.12837112454047162, 0.9383552923497105, 0.37712020009006386, 0.40630372505486734, 0.15077822779956473, 0.15129610811837757, 0.21479701351837477, 0.13565567000096146, 0.1357895099145957, 0.16235471615190145, 0.17172071037258196, 0.2113506267465186, 0.502213377372347, 0.6588111514149553, 0.38646529355034787, 0.46147264221104345, 0.2849402423127336, 0.3314683349180184, 0.6190052313597982, 0.3325888749116318, 0.5068359880773436, 0.2845599332195081, 0.28986021956134944, 0.6538931338941812, 0.20135941985869044, 0.07384833690543147, 0.0701441891236847, 0.09135470593291561, 0.07029468683557294, 0.04266164473382361, 9.999999999998899e-05, 0.0954168360284613, 0.08984869033140896, 0.060870978037357415, 0.15996243287799206, 0.16296483821315655, 0.3734829233519421, 0.1060914153275313, 0.1126139513997707, 0.04522155077139489, 0.2557689346101357, 0.18078395626987853, 0.1054572594601807, 0.04739795710722794, 0.12224816739280009, 0.30481569517855855, 0.11234366063998258, 0.07355632513134258, 0.0795794572948223, 0.23749353179435406, 0.3433019737638837, 0.0834735839676467, 0.10710677468898577, 0.15969174012012577, 0.1890326684771637, 0.20917274428456878, 0.25038282695338854, 0.006062986482831545, 0.12148461271943867, 0.19962818165160756, 0.08421346688300979, 0.5655953140913501, 0.726711477971858, 0.6820386591032198, 0.5801812732967051, 0.5963056610365165, 0.5566696855310885, 0.6027649886003501, 0.5518032023555363, 0.6161749425829759, 0.0422792645165988, 0.039364134642405735, 0.021997923990354495, 0.10771692698669633, 0.07274810873920412, 0.08269786612327623, 0.16131676523110106, 0.12023123853927065, 0.10056998811268714, 0.19338977339685337, 0.3342410316272595, 0.26469871649576293, 0.3674231591204681, 0.12843038634524107, 0.16892604690203772, 0.3382653564764505, 0.1890177314758439, 0.22346566029795467, 0.3230869722789941, 0.26604598676389835, 0.22135901761798404, 0.46115960726580474, 0.27221241719092826, 0.23402352155869954, 0.28031800419037034, 0.23728871945308194, 0.14520176338234192, 0.32738731369619334, 0.21015210054105793, 0.21260810465551727, 0.19444791567004371, 0.2571045100365231, 0.2729474293750125, 0.15944062681585947, 0.1937879289909069, 0.19195059795500147, 0.22447754214554694, 0.28063757734694794, 0.21745982339783154, 0.2253386251455891, 0.21616442568624794, 0.2206899019888351, 0.22022737316731889, 0.21750411213913634, 0.20981691042368544, 0.1794995459728319, 0.22602810741802315, 0.18789016446285467, 0.20070413926668973, 0.22599557425086136, 0.18262336874189533, 0.17885256492592327, 0.20241654394381892, 0.189676192108448, 0.9294822219959027, 0.8812281694143768, 0.14758105093673513, 0.9373449819242186, 0.19678515377246153, 0.9233967010209454, 0.8816809664598525, 0.8854697108662012, 0.16839696150223937, 0.834985950337246, 0.21200042868305025, 0.6224292171120902, 0.21050658924184706, 0.16775686399062084, 0.8287059545328901, 0.6215871054353084, 0.6883869838358849, 0.10486340693381657, 0.1762763319400409, 0.17485074445228943, 0.17123430646457927, 0.17729655246907572, 0.18633019305256793, 0.17075039180693252, 0.17172375064864265, 0.18579471379913626, 0.17014647033696895, 0.07841485348483279, 0.09366992391186979, 0.07702487103358557, 0.0749919473195454, 0.08871549305563131, 0.12068752872539212, 0.08843562810692618, 0.08094861402300901, 0.08151025022292213]}, "mutation_prompt": null}
{"id": "1f6db36d-4ece-4c71-8371-44a5108bc26c", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "384c91da-8f56-40fe-8094-1af1df8fa140", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.3 * np.random.rand()  # Stochastic inertia adjustment\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce stochastic inertia adjustment and enhanced local exploration by adapting velocity dynamically based on personal-best performance.", "configspace": "", "generation": 51, "fitness": 0.3766092957485907, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8329012623132706, 0.8557821389831174, 0.8116372403714356, 0.8129135881173031, 0.8601499353724733, 0.8053440088824703, 0.8469834919785431, 0.8540584601462047, 0.8332259176180083, 0.6639934970810668, 0.5951018513866794, 0.5727219370744989, 0.6709982750736743, 0.6317959010587184, 0.6242494564260743, 0.6639919251438442, 0.553719751168839, 0.6050505358369995, 0.08610222694513736, 0.12275654697839344, 0.12211817939747494, 0.12894765920261375, 0.11503651395752645, 0.12780877210936992, 0.11516991120537057, 0.1286253346938918, 0.15171272847836803, 0.08326197905507782, 0.11448239178104991, 0.08676093308016586, 0.09189562507743865, 0.11737731860261935, 0.10289881852632243, 0.10051567026113295, 0.11511743668011643, 0.08664411116685988, 0.9432221014018447, 0.9485032168640203, 0.9464543462570257, 0.915554525688978, 0.9368924131548636, 0.9245472425453922, 0.9476504371333212, 0.9515584299681894, 0.9138916000104154, 0.6415190867239429, 0.7084842431468186, 0.6429336500235174, 0.654774301339712, 0.6446446052064364, 0.6441977151503834, 0.6574680792579727, 0.6789213511807222, 0.6337108781831173, 0.912555684437694, 0.2186902688696295, 0.1684708175829177, 0.8501789077571598, 0.2744713477385421, 0.2129076534899037, 0.17227501483177654, 0.17870945248204584, 0.1769207295432731, 0.6193391854264154, 0.5110831761817096, 0.48491614931735816, 0.5133077325769809, 0.5166187074181237, 0.12571080320905514, 0.5860043753647968, 0.13106134668093672, 0.5973551486962234, 0.13464651217684964, 0.6279115711635266, 0.13616171156798829, 0.6308581990199942, 0.4613597514385249, 0.603924240422191, 0.6393264990921061, 0.6575801413466449, 0.4499633889504937, 0.20971226729331083, 0.06541841775978174, 0.06666392764588813, 0.04969879866282789, 0.18774146778845802, 0.2915157830171654, 0.2011271177686429, 0.14591245653617402, 0.1052849914731121, 0.30260880076225594, 0.2751696829758453, 0.27098921529123576, 0.1228289884328666, 0.11826650625130408, 0.1304069269286936, 0.41061294448635777, 0.428782676620045, 0.37429054891867153, 0.26871614939279964, 0.1563804432705962, 0.30796322017188804, 0.15295339366032257, 0.07830986453148947, 0.07390690266280886, 0.31626939924508213, 0.259256168611836, 0.0680822866561801, 0.3892910202752974, 0.37335339856793626, 0.3728790533271251, 0.2868105754942776, 0.3317532736816101, 0.3455227028495329, 0.2807360371242169, 0.08389504116677216, 0.16501970732628435, 0.7779384143213371, 0.655981472910588, 0.6912472475841345, 0.7283697627728423, 0.6193671219855519, 0.6625395764626348, 0.6538763727146777, 0.6609021674040834, 0.6574332406219976, 0.07832113548080155, 0.09048103378260053, 0.12427182836717987, 0.12399382680405358, 0.08861540537780843, 0.1335784743259537, 0.15281462570023796, 0.13691641296659707, 0.09941411119423194, 0.33839529169172455, 0.7053428481096403, 0.3059661451609662, 0.4597828627563858, 0.44981119844835216, 0.2083589762225766, 0.2452685113957347, 0.2497240391964789, 0.42198256535460843, 0.5100794129669339, 0.31100157669501927, 0.23098693373788237, 0.46280563566150135, 0.28665523883223054, 0.3776101024707519, 0.2861837501729052, 0.5338064536101641, 0.3459343338077773, 0.2663611198296799, 0.2985493904551958, 0.19990811254937846, 0.3429999328974531, 0.23951869292120131, 0.28981661158346506, 0.19797200452780261, 0.22755012977565658, 0.10888857771190741, 0.2251845571655836, 0.24693201979132784, 0.224066385707397, 0.25378992131829214, 0.22687041453259138, 0.23018963945469562, 0.2541220523418918, 0.22572498589946932, 0.24045622715683046, 0.20475491500738374, 0.6797135410367348, 0.2029872032011698, 0.21281113308835087, 0.2098162646669578, 0.18302425732931904, 0.18011789124391597, 0.20405817694797557, 0.19371926001895368, 0.9035485365367933, 0.8908395057747943, 0.15247245137539434, 0.17328534673866158, 0.8526079887279385, 0.9235048584151997, 0.15391120313741125, 0.8282203487961828, 0.16866957876677002, 0.8793173685190021, 0.2132256359412098, 0.8494745388786383, 0.20909031588488647, 0.16864238754142102, 0.8876460017366405, 0.8417172486112738, 0.16782261026624423, 0.10392402687626379, 0.19715370063748983, 0.1895641401080883, 0.1722456309291177, 0.18446296739726764, 0.18064187820953614, 0.17012474254508103, 0.18398929693065702, 0.19166902526168317, 0.17040257019816218, 0.09317874212054955, 0.08975714797447087, 0.08481439292991311, 0.07913648534863293, 0.10034425466894115, 0.09524960621951317, 0.08943395781404251, 0.08562883928490284, 0.0990107974829123]}, "mutation_prompt": null}
{"id": "6494c30c-23ae-4418-b2d9-65530ed923d5", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                local_component = 0.5 * r3 * (local_best_position - self.positions[i])  # Added local neighborhood best\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + local_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce local neighborhood best to enhance diversity and convergence speed.", "configspace": "", "generation": 52, "fitness": 0.36852900685411466, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8482570632994454, 0.8802788581474817, 0.8937042408170633, 0.8726231496901622, 0.8200452934671787, 0.8507415610131103, 0.850860748373049, 0.8731850237362266, 0.8552694515303396, 0.6311476720247142, 0.6454461580373032, 0.5716989052241372, 0.6766020125559651, 0.6801083552112326, 0.6716913455104467, 0.6274246795863834, 0.6389952408775819, 0.6462364533796383, 0.09314198683152608, 0.10468963903259987, 0.058671802382399996, 0.10820011487607684, 0.1126614675279034, 0.0832171240532743, 0.09082101375278251, 0.11493659680775559, 0.08880896438096952, 0.10347454665221234, 0.10789055134021652, 0.05082228834714719, 0.11612818439994532, 0.08032707041400367, 0.09419057792635976, 0.083110072798954, 0.11937346435203366, 0.11221088936129531, 0.9304253145175052, 0.9158201765855472, 0.9134672810381729, 0.9192376616778812, 0.9203746202250602, 0.9066529091382998, 0.9223164622847274, 0.9147249664644723, 0.912648989206757, 0.6268774857604069, 0.6351650513914257, 0.527187363126084, 0.6486932589945692, 0.6464063533192035, 0.6277912436218703, 0.6298735311481439, 0.5669843288747427, 0.5845187556941014, 0.23004934188454196, 0.16361963171975347, 0.1710864140892301, 0.27819484414336115, 0.8795099373938051, 0.20651019079257737, 0.14924419783710874, 0.17884097466857152, 0.23253473404058433, 0.6032330644545768, 0.43739848284138283, 0.4219582681525994, 0.4158426379344473, 0.6483468676832274, 0.43618420274299263, 0.5758614491461804, 0.5332773303542464, 0.5082979442423341, 0.45877723843472806, 0.5481952483653914, 0.13399439281428438, 0.5108800518443007, 0.5491946306701112, 0.5188269682405744, 0.4875067165653735, 0.460389595343091, 0.5833392141371572, 0.16681826400108202, 0.059868801402158, 0.08500799605491116, 0.22224500133863212, 0.14996757202020472, 0.1528110240347178, 0.1127962257120424, 0.04643997902988106, 0.279840719724577, 0.2164331731749951, 0.14832840062317387, 0.3892813057737159, 0.08765166763680043, 0.08156699151321445, 0.12273289987535685, 0.2568145847408406, 0.28734161245406, 0.34184744980098114, 0.25098730277151926, 0.36339603650502195, 0.2763860377235474, 0.07626143296541954, 0.13119976644899312, 0.1437712713867093, 0.17367366885080626, 0.2514558226300284, 0.09340386734057249, 0.37298499054124323, 0.2700149984833554, 0.24617927132452, 0.24910224346450338, 0.22406662554397938, 0.28171509864413324, 0.20512781353439813, 0.20734046608794066, 0.08065918831328567, 0.7175262353320486, 0.78598841984813, 0.6830489164169053, 0.7170969138672807, 0.825149688116648, 0.6806237917697785, 0.733942886519396, 0.7843901338961322, 0.6912790331302686, 0.09584592896651412, 0.09130531313829904, 0.08784100844687182, 0.07514178295319618, 0.11247691935632087, 0.09251048518837945, 0.08526664729669153, 0.12019274007533709, 0.08819293682992702, 0.6564154978831609, 0.6116179903529848, 0.455084368141468, 0.5914135501219908, 0.1486169839456466, 0.2151732066950588, 0.5584151870714904, 0.11767308434949342, 0.2101057657882408, 0.3016832951099968, 0.42294904684225887, 0.18484206303193051, 0.4194468313567229, 0.5201946159501961, 0.26936645391958935, 0.23400168344590488, 0.5524906022227858, 0.25086889991226125, 0.11229243847652215, 0.23470802178688654, 0.40634821978084357, 0.25281416253323163, 0.3749823864841646, 0.1684061451947011, 0.23069595985521552, 0.40241726605483774, 0.09943844049177952, 0.2576870237027943, 0.2569797108089803, 0.2726012665239448, 0.21297045421945193, 0.22862413377374102, 0.2217451613212298, 0.23085524714895478, 0.24373877827673063, 0.23393058188720817, 0.1927155929490867, 0.18317888318965558, 0.17636008046592577, 0.18687697655205027, 0.20095681305313517, 0.20683704556652305, 0.22372518268228125, 0.18518141229619334, 0.18969783883128877, 0.17719351039846076, 0.18844411517046078, 0.18890224964284275, 0.9076507679408738, 0.19988383169135227, 0.8520238678483509, 0.12147572726337275, 0.8466163035582589, 0.16715795746730489, 0.899152403097509, 0.8416035647215934, 0.85798326762977, 0.20891489816566677, 0.16866968771677926, 0.15401866308797996, 0.8868840982438229, 0.876411541442516, 0.7911264495792318, 0.169101295896251, 0.18879168965258852, 0.1748167915142751, 0.17967038340758668, 0.17912136223332986, 0.22162965110451638, 0.18287713208887468, 0.17288384162646397, 0.19013394912310444, 0.0952910569672043, 0.09360260729068126, 0.08152220603704519, 0.08169551239542527, 0.08602637996122064, 0.11308384707068486, 0.08358338092259365, 0.0880503547988436, 0.07855453973953663]}, "mutation_prompt": null}
{"id": "b08f9820-9f93-4244-b68b-c6da436b513e", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "8488c114-59b2-4d35-ae0a-2d158646f8cd", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n            if evaluations % 50 == 0:  # Elite selection mechanism every 50 evaluations\n                worst_idx = np.argmax(self.personal_best_scores)\n                best_idx = np.argmin(self.personal_best_scores)\n                self.positions[worst_idx] = self.personal_best_positions[best_idx]\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce an elite selection mechanism to improve convergence robustness by periodically replacing the worst-performing particles with the best ones.", "configspace": "", "generation": 54, "fitness": 0.37967755936757797, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8808136340102866, 0.8952342838242536, 0.8912038807569101, 0.8831308730855227, 0.8843023204421046, 0.8817617113136597, 0.8670166544911581, 0.8824589707703014, 0.874480300628776, 0.7460824198301732, 0.7305559540760385, 0.6379162285129123, 0.6874736766301051, 0.6571690270804249, 0.5849825542254883, 0.6900224447593406, 0.7254337562922625, 0.6835900390296703, 0.08297939992575698, 0.12339585051813595, 0.05638468458045276, 0.0947432539850046, 0.14032712098834776, 0.11784525096648468, 0.14565336259143047, 0.1576007650959742, 0.1185054768790833, 0.08316778600191532, 0.10571591235903122, 0.054451390443214454, 0.14360991773477672, 0.11086434854935634, 0.07450008312680167, 0.11711573092674266, 0.09399812024707677, 0.07572422647348975, 0.9324700187280885, 0.935775732993299, 0.9127924295198493, 0.8921638900432888, 0.9356509382535887, 0.9328562903983667, 0.9522372277860259, 0.945832595753633, 0.9284682620832772, 0.6744245719002182, 0.7409297567876569, 0.6970746362009669, 0.6867259559094516, 0.7100026110048936, 0.1507022300507086, 0.7136982904530691, 0.662506194393991, 0.7280913782837695, 0.23075490278933808, 0.22189845389366913, 0.22487045185407473, 0.9577551299385885, 0.3846717784257505, 0.2800061089034792, 0.15204645285828267, 0.17786733415765388, 0.17684737162487052, 0.13577564054098512, 0.1361477023547717, 0.5113927353264893, 0.5207176577305361, 0.13479476233660348, 0.4990375001355407, 0.6967207580478725, 0.13429246320187704, 0.6167305910756595, 0.48593941537387786, 0.5284156900045323, 0.6626451937672087, 0.6900515877936948, 0.6464596042503743, 0.5228653108121074, 0.5881803977407298, 0.6736477403928902, 0.5515282878168496, 0.30060225637347004, 0.058835873221202206, 0.20777958215049153, 0.07352151421032338, 0.14867916284074467, 0.07988616185202269, 0.33173810527425873, 0.05778118217991601, 0.12646336845480144, 0.4177224783061114, 0.13957201448565137, 0.41618775550523057, 0.19703297263062225, 0.15122546717062013, 0.08522103643632839, 0.5349385253123927, 0.22280439922769268, 0.1239973445281154, 0.12076239215803375, 0.2449698952638374, 0.18306914220176473, 0.16857452835838393, 0.08307307220184523, 0.10789537250348735, 0.4470600997499714, 0.20534465832459692, 0.08106501698998525, 0.1514512577271715, 0.24283883941609652, 0.23485216700817535, 0.22202779710204945, 0.41936186706500234, 0.08564224678945698, 0.14320027449877215, 0.24347792308396687, 0.23150266526045737, 0.7950798124182258, 0.7197955495269373, 0.6366558517957333, 0.6049566593590691, 0.6906629761424521, 0.6615201704086393, 0.679050673725557, 0.6248847112988567, 0.6663680727550225, 0.06539517140721585, 0.09547967281707448, 0.03306632859458336, 0.109129243405651, 0.08991435920373547, 0.11448931639345139, 0.7358703314044388, 0.09722053598071412, 0.09180432630822455, 0.14605360712515558, 0.22740892939474744, 0.4255957337905979, 0.23866261706064607, 0.3415127710017982, 0.3327385572990055, 0.19908049685001694, 0.672262307757961, 0.23151204674585024, 0.30596253596332923, 0.2644533083761176, 0.20138390425153552, 0.49043135762618983, 0.28083609660111775, 0.6086785520339033, 0.25304820086396285, 0.3160682201257058, 0.1459511065405753, 0.31644019336737306, 0.25928641628758875, 0.23505357965402207, 0.27099483880548814, 0.27566060566859896, 0.2536207951663515, 0.23101502535003016, 0.17409436506923393, 0.09963564300900829, 0.2575843875252455, 0.26194153655112895, 0.18941566138766652, 0.25053409746503597, 0.22366963615580848, 0.2269287378536502, 0.18022111045023215, 0.2262118281649016, 0.20525240893019414, 0.18203235467939172, 0.19950371888118434, 0.1709936015850766, 0.19964308263795671, 0.23007055225117612, 0.19820663279892803, 0.16903828891071881, 0.18223450255339135, 0.1819315728724693, 0.9439639344128737, 0.9182940808635158, 0.1532845061267768, 0.9316328918478879, 0.20028293475825143, 0.9297324962022304, 0.916251538527851, 0.9210631751503506, 0.16858961487645574, 0.8879786279238633, 0.21273453041940293, 0.9359954564707211, 0.21055972364373676, 0.16768662671145662, 0.9082888247726131, 0.8860758161864816, 0.8994707768414938, 0.10485625198522408, 0.22293531732018013, 0.23719718747465213, 0.24199700577853644, 0.2055511980455611, 0.19887648138556724, 0.1856788941882448, 0.21580983935093034, 0.1894042405406603, 0.21009015454583835, 0.08298038840518296, 0.10412451004907775, 0.08102751650101547, 0.08017304596631514, 0.1105789911877122, 0.10541293305258681, 0.09205073027258281, 0.08773876586110652, 0.07295066865628963]}, "mutation_prompt": null}
{"id": "bc9ca80a-9196-4683-9bf6-f4c4a285f9f1", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n                \n                # Periodic re-evaluation of personal best every 20 evaluations\n                if evaluations % 20 == 0 and func(self.personal_best_positions[i]) < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = func(self.personal_best_positions[i])\n\n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a periodic personal best re-evaluation to enable better convergence towards global optima.", "configspace": "", "generation": 55, "fitness": 0.35114683418277104, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8290573092628023, 0.8501216434436076, 0.8693541235549772, 0.808475385984784, 0.8352482719121221, 0.8451971894913172, 0.815338121699148, 0.8604796452185415, 0.8551364984807178, 0.5818366146306475, 0.5983478247215079, 0.487702959598447, 0.5723648113791747, 0.6158148786731922, 0.5154464501822532, 0.5757952038608486, 0.6357295647409962, 0.5488271324348992, 0.10493165215805889, 0.1639034300764941, 0.06974484266999648, 0.09132419375576883, 0.15026888858112197, 0.12508738935854813, 0.11434000198780303, 0.11950626254331254, 0.12022200279415596, 0.08552472751387541, 0.10926431919618884, 0.0562098411085743, 0.10898517378052641, 0.09386054362502405, 0.06767418645399981, 0.1018938149759222, 0.08860098035153552, 0.0744198325191443, 0.9110783358153948, 0.909844526843549, 0.8884497959563779, 0.8708300511824949, 0.9098643687182963, 0.9103170548817971, 0.922854809036831, 0.9244374115674094, 0.8898165097529076, 0.5449101753989906, 0.5987602245605222, 0.5156092588861159, 0.6023104949098466, 0.5983688801226501, 0.1495175384689399, 0.5436226930828896, 0.4306018552380684, 0.5324215695726622, 0.22924970327765393, 0.16744676506585165, 0.13379411290245335, 0.9072766539115499, 0.3743724583166079, 0.2771026023586498, 0.17672190192542092, 0.1513440912941909, 0.8508327897498368, 0.13435568352390892, 0.13342832420059514, 0.40113984442495865, 0.2791805049947703, 0.292446278781612, 0.3865168516666143, 0.6964623480658734, 0.13275576142853496, 0.41440731307601175, 0.3851592375512719, 0.3737712864583783, 0.6601484700201886, 0.6571915017693462, 0.42157782959189627, 0.44125375330558003, 0.4043280232503156, 0.47809000049239025, 0.3293896622609356, 0.013600707925665145, 0.046633666504735216, 0.2404421792782967, 0.05800405123064045, 0.17245260813689478, 0.08635426081373787, 0.20870410573512066, 0.1540886596063692, 0.24351395811350096, 0.1842397266853939, 0.11714619020747563, 0.6293467616478043, 0.18126964799873213, 0.07527932640904511, 0.05692729547440778, 0.30731899554004294, 0.17037561743511687, 0.12274443943250901, 0.09933939253914159, 0.18983202795091048, 0.15419406505973365, 0.155161511352778, 0.08050842697288896, 0.08822042226962878, 0.35351501102227534, 0.2435596334794773, 0.0669476609566998, 0.21658720900576922, 0.2644357318572991, 0.19908253835875178, 0.2582384287911714, 0.22364595942985854, 0.12249391105355933, 0.09127709991953104, 0.3415212596281566, 0.09146962109895762, 0.7080749845128046, 0.7309490196191044, 0.6028390655712641, 0.6537609638936316, 0.7269626278544875, 0.7630371035265057, 0.6160201350312965, 0.6594659298969292, 0.6966350356185609, 0.06420361485683101, 0.05579021859249356, 0.0608898037029012, 0.14564473348276408, 0.11919747204469366, 0.1303933999849871, 0.5457711713017845, 0.1004130104834241, 0.08497426795537266, 0.3068793334408564, 0.35356144960904845, 0.2859975071600156, 0.16668445923961972, 0.21531625454947967, 0.32743032119867443, 0.3555256001750552, 0.3892382284937437, 0.2626275274494909, 0.336055932148693, 0.28879488882048576, 0.23825488425524344, 0.4666725389984945, 0.264817912475256, 0.34063414261532476, 0.345112039156263, 0.27031742712039264, 0.11671148319450253, 0.25249422169458846, 0.2958313523397519, 0.21760795779340536, 0.273329424520633, 0.3203812956441596, 0.2662812855430603, 0.231276220473691, 0.24699162172767364, 0.19391381462967983, 0.24451039183582168, 0.2205814530931025, 0.1941092842202049, 0.21821850590196934, 0.22883540456676765, 0.22003042821033714, 0.21423790303413903, 0.270869417927766, 0.2296794558320766, 0.17841784611560962, 0.22344961511145878, 0.17015220590295954, 0.20731826230194306, 0.2285637914332772, 0.1838906148337256, 0.1717674783131855, 0.20674002153534654, 0.1900047368197666, 0.9149549791311076, 0.854554165890728, 0.15240899493176496, 0.9114274868301039, 0.19952572925402523, 0.9109723634180489, 0.8730864558369923, 0.8727582302643553, 0.16810788474228489, 0.8627204084210789, 0.2109388992525637, 0.8979014857756584, 0.20874567556182744, 0.16657020291900682, 0.8641267619101562, 0.8230400304608725, 0.8249503859654542, 0.10447372262202603, 0.1760436223217361, 0.17968847280043687, 0.17207293141519786, 0.1684298794828708, 0.17037678485852825, 0.1705969581618083, 0.16927642911851104, 0.17318106039658598, 0.17206794594868702, 0.08192599370501685, 0.09311181001484092, 0.07994252471613839, 0.07935561801219904, 0.10485516871139244, 0.10714414708647269, 0.08167585033542546, 0.07663980418218941, 0.07706169033261501]}, "mutation_prompt": null}
{"id": "6dd8eb81-8e14-4d3f-a18e-e9ab872ee40c", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "43f2fa39-7d45-4738-8116-cb267f04e5f0", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "f2fe58b4-dbab-425d-8448-dbe60b01f61b", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.3 * np.sin(2 * np.pi * evaluations / self.budget)  # Adjusted line\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.3 + 0.1 * np.random.rand()  # Adjusted line\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce enhanced local exploitation by incorporating a sinusoidal inertia weight dynamic and additional adaptive neighbor attraction.", "configspace": "", "generation": 58, "fitness": 0.3257094657322582, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.916170012266693, 0.9004735354797736, 0.9260051583536923, 0.8976700954583637, 0.8899682810189544, 0.9025317387533398, 0.8855557522616845, 0.8819195775805281, 0.859037060149444, 0.7348523102353646, 0.038614672744466394, 0.29355782896423677, 0.5545501314713519, 0.7811030899288749, 0.6475995170108125, 0.6316693300611891, 0.44488041460391614, 0.5002660648841177, 0.10044374584322524, 0.14267841174975116, 0.06972834592036414, 0.08555961644367649, 0.09724956260115702, 0.10942601802942442, 0.14251301603370015, 0.10993273881603216, 0.15889983505222427, 0.08444043042660743, 0.08601327842719797, 0.0794967307433071, 0.11265662438271173, 0.06944571197545613, 0.07661432342442043, 0.1102122567004562, 0.05673625473221633, 0.050755281390210794, 0.8952505117861841, 0.872308832094144, 0.8255926700826505, 0.8174612316923167, 0.8389234955601372, 0.7174378035740727, 0.8606461436385147, 0.9189874892477753, 0.8891222818609245, 0.7123523200147883, 0.515014944320735, 0.724007579479544, 0.524094920670596, 0.6512927566599744, 0.7673783551766113, 0.7486339464961937, 0.7706201385188327, 0.6900097669837674, 0.22836256539084177, 0.14154058923836288, 0.10836873112254164, 0.18086205849741022, 0.38619108610319686, 0.2779176414674188, 0.10722859542167784, 0.19016963489574723, 0.1736302901246627, 0.6272524664857417, 0.647831816643817, 0.6111206329193709, 0.6758120147399176, 0.1322616890233228, 0.12587990566784013, 0.13631866313310914, 0.17603194597466276, 0.5291625727069702, 0.2481644029073683, 0.24765495452134267, 0.13208887861364604, 0.7727775658488341, 0.3322822205353301, 0.2539931178350323, 0.498877652751059, 0.7655203292989101, 0.43798340354299004, 0.07765957181245009, 0.04878428261352341, 0.1283582585850902, 0.05793015297289117, 0.08025505780357767, 0.07891981824250238, 0.10408707042918519, 0.10225635775305708, 0.07581738111026282, 0.3392086924492046, 0.10183031556325317, 0.1448695180861863, 0.15250664230327549, 0.08244241479578285, 0.04762139180741909, 0.23065064963395498, 0.19159964843394084, 0.11499302141386236, 0.2454010222969476, 0.20685613108706202, 0.2701434721506436, 0.08723927972733547, 0.10430884969828369, 0.27426209724187656, 0.2094144415706387, 0.10692463263447538, 0.07745791348546005, 0.23798573896808817, 0.15831242557830316, 0.22627737723029995, 0.16140239798754374, 0.15313322538723728, 0.1555469826236262, 0.08271714297903421, 0.26523653141941117, 0.08125018494515046, 0.872686449660152, 0.6147687479477109, 0.6480151845740456, 0.548309002488897, 0.7365926391931213, 0.5558727792690956, 0.771950230201035, 0.5934910759692398, 0.7229229623688583, 0.020164088141488512, 0.08094212379211263, 0.0605883171882573, 0.1309827952502608, 0.12442965212576251, 0.061840602853810434, 0.18837789439624053, 0.1225163888690719, 0.09661924543539901, 0.27500344987468306, 0.28398107397023364, 0.8135210157073666, 0.1920675723584171, 0.14384076222197562, 0.21249190266168794, 0.6722872626640657, 0.29036160231721275, 0.1421254106895452, 0.19571303785968253, 0.20391562923331086, 0.17982039748997358, 0.1984384452564093, 0.28141949945710876, 0.22522766736330146, 0.1877974844940874, 0.27997138784966724, 0.15034566295168117, 0.13254770333295307, 0.2588257150370903, 0.09831869084361078, 0.16983409868748256, 0.18711433901322683, 0.29018834350496125, 0.1426502132552918, 0.26963415839875093, 0.0908385470744344, 0.24127755543762008, 0.26168446639925447, 0.2035210785210424, 0.23820859109477266, 0.23890372604217303, 0.22328168545136673, 0.222432203081399, 0.20897218323948596, 0.2079724404732307, 0.18293729188201835, 0.16969271850279877, 0.19064310630715076, 0.19081789686823003, 0.1872550220835344, 0.1719962166676694, 0.20755861456348923, 0.22415743548113953, 0.1616903232670922, 0.18740318391260147, 0.18804060615495177, 0.17283682642414444, 0.17158375062443953, 0.19913302076093864, 0.9428619326985498, 0.15255910557873809, 0.16616192819670228, 0.16812967363225872, 0.9353971731126757, 0.2096535105736579, 0.9119375251223371, 0.8235626545487524, 0.1540153065547002, 0.8907132194415756, 0.7694678511573522, 0.1653747185545521, 0.8368938580838255, 0.1811981753631724, 0.17704463097109202, 0.18888956803916568, 0.17321213113953382, 0.17869024860901028, 0.17328388371629844, 0.19899127350195756, 0.18479799647209794, 0.20206626076852385, 0.09192930745167105, 0.0944412550189343, 0.0844999615117582, 0.08257798206611, 0.09171301466771087, 0.1182147592914169, 0.09230458200658609, 0.0849291597511741, 0.07907329402387442]}, "mutation_prompt": null}
{"id": "5253089d-089f-4c57-89f9-2315b873ee6e", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "02036add-15ea-4b45-a6dd-17d15893939d", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                    stochastic_perturbation = 0.05 * (1 - evaluations / self.budget) * np.random.randn(self.dim)  # Line changed\n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i]) + stochastic_perturbation  # Line changed\n                    trial_vector = np.clip(trial_vector, self.bounds[0], self.bounds[1])  # Line added\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance exploration by introducing a stochastic perturbation component based on the budget's utilization.", "configspace": "", "generation": 60, "fitness": 0.3089238684685165, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8886156729098335, 0.885193262879744, 0.8814045076294138, 0.8694892331098274, 0.8439232858044073, 0.8734597867008573, 0.8397969054060446, 0.8238222909235402, 0.8757979572366412, 0.26767507758958786, 0.18946995115277154, 0.09188371696118813, 0.15297415221064004, 0.2037009423838515, 0.08253520907584933, 0.37257592270086626, 0.21060479821620115, 0.1726818045705113, 0.08845926611926191, 0.10926073691103955, 0.12218804273021344, 0.11070697857779088, 0.11196380103985248, 0.1426832872172481, 0.11680671361511341, 0.13756497197291429, 0.08957526319992815, 0.13079587108483848, 0.07598360129502801, 0.0470728314060056, 0.10518513642513738, 0.09152942642470885, 0.07321371854331682, 0.10848723370448365, 0.12358642655445895, 0.08909631393927664, 0.9192963661392124, 0.9052869436088655, 0.9263959290256656, 0.8973675834383749, 0.9292382058631963, 0.9153215394173363, 0.913463910915232, 0.8788661655916035, 0.918183492151271, 0.6924999142375561, 0.5550417843811377, 0.645194942850599, 0.5775891250630039, 0.5838684613004559, 0.5733267031369931, 0.6276449155789713, 0.46425243010782635, 0.5402807590819169, 0.9190991659688258, 0.1409933447311743, 0.22297768840902477, 0.9229577812836403, 0.28033915801422415, 0.21153298010798516, 0.17654028781552755, 0.17741820165331013, 0.17818862896042642, 0.3237812331487334, 0.5139936115769237, 0.26646951084099013, 0.23861288031586847, 0.2838582506784595, 0.1970688450658128, 0.2251049211099222, 0.28207894295649716, 0.47788395516176774, 0.25726262116572507, 0.23909714470165488, 0.2248293868033484, 0.30528141520684826, 0.2665253202725547, 0.27520106329300686, 0.31476515290045914, 0.21554546254699658, 0.13355286920347775, 0.09941434593954235, 0.10611649082727836, 0.30458537696567123, 0.1238203241895739, 0.052220829245435585, 0.03631702379486745, 0.08561705006352271, 0.11802225163523561, 0.16185718309406816, 0.38547607512877935, 0.1885174511713743, 0.24066160324173225, 0.13856669544350553, 0.08969631207575857, 0.06468493388013374, 0.29015360497309284, 0.557794487521498, 0.16793046804645784, 0.1022632534233282, 0.13790082626734634, 0.17393463309029134, 0.10302420483728314, 0.08392358839554559, 0.08960646317676235, 0.09910594614366164, 0.07120569999425297, 0.06964183052087214, 0.185389429703963, 0.26274186502174546, 0.1486263350910091, 0.14491947203696653, 0.19599250362173248, 0.17272791976306157, 0.1655662652662241, 0.17330438033667028, 0.13247162699618475, 0.5726928289832347, 0.7885096363647558, 0.6566103117913327, 0.6369666612433647, 0.5767501179743653, 0.6571261133606354, 0.6082172255610933, 0.6111377039839765, 0.5270296300979489, 0.06159332889462443, 0.045065090106962136, 0.07317386622746258, 0.11312709594373682, 0.06838702491499171, 0.14229984220069658, 0.09391835785750269, 0.08846854508557311, 0.14025088379383766, 0.5777926304024215, 0.18467491038500128, 0.2737257689508622, 0.1881173248220931, 0.3508743946900983, 0.20621269706237866, 0.37455338955548445, 0.2137049197869465, 0.5014582053442621, 0.2858127056174421, 0.32305191290428803, 0.22748138794387485, 0.43951013032372643, 0.3179805145109318, 0.30869944160707563, 0.2589086409005541, 0.3850454419840216, 0.21269442507496883, 0.2714976918306433, 0.305762929084594, 0.21899968261566227, 0.2380926246204944, 0.2515353477274509, 0.18621977049020666, 0.20067800348370002, 0.2840777367013778, 0.09841371551135203, 0.19821032257426774, 0.24261241487227703, 0.2627026231425925, 0.23519174807719379, 0.2405551773256308, 0.2088343703654354, 0.19565549863828435, 0.197149380015601, 0.22479065806452592, 0.2103664356656837, 0.1817919146560818, 0.19802541585163203, 0.19026888091208594, 0.2075628903073028, 0.18316904641303977, 0.19697707745019066, 0.20480486650531515, 0.22639238240535953, 0.18666064807896077, 0.1877175864411954, 0.15285195209661617, 0.9252805185754704, 0.1998964962772961, 0.9119503574679124, 0.12210521012542608, 0.8982308954082368, 0.16617118043603984, 0.8337846035511344, 0.209995461701025, 0.9155870502064444, 0.20905677662229316, 0.16864428194925818, 0.20995089071252904, 0.16743078313885906, 0.1674197503526753, 0.8770061990894222, 0.18461509587131464, 0.19516870931457808, 0.18178868922948166, 0.1869306601523486, 0.17557936501879612, 0.17537318127524482, 0.17801246650839042, 0.18423799805864438, 0.17148181855060451, 0.09008031159932994, 0.1191746408427029, 0.08389139388646494, 0.07833825570623032, 0.08984714227630408, 0.08003285586021613, 0.07393978789038247, 0.08490340617062953, 0.07481561226737721]}, "mutation_prompt": null}
{"id": "2231de88-16c0-4f10-b664-a9ab439dd5df", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "17cdc5d4-12ee-4866-af77-893560b5421c", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            self.cognitive_coeff = 1.5 + 0.5 * np.sin(2 * np.pi * evaluations / self.budget)  # Sinusoidal modulation\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.3 * np.random.rand()  # Enhanced adaptive weight range\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a sinusoidal modulation of the cognitive coefficient and implement an adaptive neighbor attraction to enhance diversity.", "configspace": "", "generation": 62, "fitness": 0.37446148756113407, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9013132043108428, 0.9067812705195989, 0.9098973312145574, 0.8941753987466238, 0.8808765158489817, 0.8876423594992146, 0.8989129681439223, 0.8706370960574882, 0.8748712947567991, 0.7852971624091384, 0.7275889365254026, 0.6783824538711201, 0.7250910339505241, 0.7349911248636776, 0.6846760831079985, 0.6819143832430596, 0.6862798720050143, 0.6074158033591917, 0.09357692884342739, 0.13153144595234023, 0.10036520947580774, 0.1036132488279885, 0.12634559064168194, 0.08201633454910895, 0.12434600023650333, 0.11434537958918589, 0.10984101616672981, 0.08470591699779184, 0.11060277414771136, 0.060217440525146215, 0.11574172462893917, 0.1006411920228587, 0.06763195728070626, 0.0943570091483773, 0.11318562310857028, 0.05400982039821978, 0.9142637843034217, 0.8990893496937833, 0.8965623169205668, 0.8751693005221234, 0.8986015662129372, 0.9005340597485589, 0.8933103789698472, 0.9360186386651638, 0.7830607383595897, 0.753508950441614, 0.7156314203555734, 0.7228940216205819, 0.6568433970648779, 0.657934065212312, 0.67459109874403, 0.7166776053347013, 0.4755623913225737, 0.67854032482449, 0.17242212624670716, 0.14146992806994818, 0.2231791502397198, 0.9417404346480748, 0.17602768039288696, 0.2791705376974948, 0.15043600379149524, 0.1779230825816096, 0.1542625620634943, 0.7057421048920469, 0.567696174451398, 0.8183732425928261, 0.7670127531517662, 0.5666381503031508, 0.18657526407633207, 0.6862716185288982, 0.13536819459818983, 0.7356312019290202, 0.6974636215697156, 0.4647480338205803, 0.13505978460068313, 0.6586834719430246, 0.4500427106971976, 0.19610742660029223, 0.5694280615185088, 0.135045071553759, 0.499474279416528, 9.999999999998899e-05, 0.07809619302466053, 0.0946874307769009, 0.10081340208626899, 0.12328182737889348, 0.09754124852700241, 0.08132168281231056, 0.13487668983741918, 0.16764095802597645, 0.2018479535469253, 0.24404366846599612, 0.6594440412669118, 0.18562047700255202, 0.10618394757003191, 0.05914871704783786, 0.3207414113673942, 0.17801964101560208, 0.28832046825768354, 0.0945251152529758, 0.20092880390953638, 0.2529560126293363, 0.13079291838704898, 0.13808199929302978, 0.34691318123053494, 0.1762483952457372, 0.1033558441983472, 0.08095204130584566, 0.2533707802866002, 0.26388010572203957, 0.2408546465197522, 0.28592615114019904, 0.3690451122356374, 0.3394623091766742, 0.1605435702897947, 0.2796996182726348, 0.16717928071169696, 0.739435731149727, 0.6736326851391807, 0.779974296103831, 0.6986877894238919, 0.6787135606270502, 0.7871311743627397, 0.7278194346063709, 0.7139702076418009, 0.7938067640441835, 0.05724865840067872, 0.09250477403470503, 0.044421000835471736, 0.1168061579499734, 0.18384363462232267, 0.07924308307158567, 0.1172146300544673, 0.15216874183088747, 0.1203131378891934, 0.21013411247744185, 0.33969392165176593, 0.3280367403096557, 0.17172906809182908, 0.1278576036582545, 0.2272159540549431, 0.5932194846508885, 0.4623674479713735, 0.7055019336516122, 0.3333744458810124, 0.20868221762535133, 0.17381598201173876, 0.2058277349198615, 0.28936333273029946, 0.2141471300123894, 0.17914308103674825, 0.5152262317619125, 0.12717121454032654, 0.11546835997579219, 0.24863502408684324, 0.13103831115900777, 0.1628257565049922, 0.21445067200264745, 0.17377068609710877, 0.2155668813639584, 0.5451227680806392, 0.1077107397706426, 0.22488451227758632, 0.26373618636733986, 0.19991977521669602, 0.21495667428002874, 0.2401751021582339, 0.20996174508563892, 0.22588058112666443, 0.22038067519491, 0.20363522889968755, 0.19658952091248794, 0.18948913744300488, 0.18950476540549122, 0.17801545362346427, 0.20015097580648622, 0.18888258489533616, 0.1849516684569985, 0.6076362244122757, 0.1715674693822612, 0.9018133210270086, 0.1873262506525032, 0.152697953123471, 0.9457967820687478, 0.20024608124433296, 0.9271854300454818, 0.9067991379974476, 0.9026727103171553, 0.16624610272124285, 0.9142179746192706, 0.8536192173481271, 0.8901678307483193, 0.21014512499662796, 0.15450934410983808, 0.88246423858445, 0.8131930638371118, 0.16762401048115227, 0.7083970819494279, 0.17540642739428947, 0.18392282782485714, 0.1771860545990943, 0.16940746275747187, 0.1929534189922525, 0.18862851940775138, 0.18111072707538556, 0.1760493001154797, 0.1784169561166078, 0.08720920867322679, 0.11517715509778248, 0.08879501073112894, 0.08382388728490864, 0.08140902501758551, 0.10067711855072758, 0.10882381094670512, 0.062017653337621104, 0.08214388551454943]}, "mutation_prompt": null}
{"id": "baaa9881-349a-44b2-8c35-0c284e1a50a9", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.2 * np.sin(4 * np.pi * evaluations / self.budget)  # Dual update strategy\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n                \n                if evaluations % (self.budget // 4) == 0:  # Reset strategy\n                    self.positions[i] = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n\n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dual updating strategy for mutation coefficient and expand search space exploration by occasionally resetting particle positions.", "configspace": "", "generation": 63, "fitness": 0.36689527355040424, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9146008376751095, 0.9058204818760391, 0.8901999507821119, 0.8944582436243219, 0.8955834878102845, 0.9158292876533922, 0.8994823611634714, 0.900232647028979, 0.8961647347160253, 0.6979962880219732, 0.7443986709105538, 0.7470607158805351, 0.8009814488471692, 0.716990119426286, 0.7141864136920675, 0.7583916261286151, 0.6675534323482624, 0.6505687936405361, 0.11056566258202238, 0.11165455307571448, 0.07059577265247918, 0.09707465369977164, 0.08630778721923549, 0.05933266420848049, 0.11267641284547247, 0.08729746576710895, 0.08504927382265648, 0.10012993887899357, 0.08600561407394558, 0.08057751661104084, 0.08669053808311877, 0.0785636349685126, 0.07644906333674462, 0.07615876211074013, 0.08578518310298444, 0.04208489124182491, 0.9509896701622738, 0.9275499152987661, 0.9472816909586055, 0.9160277438624479, 0.9113563076761406, 0.9247751861517186, 0.9042754622131102, 0.9373181743590627, 0.9428239552744537, 0.7208787102478609, 0.6990664581821847, 0.6847326991602112, 0.6940502736886638, 0.6787674492108957, 0.5201145805351383, 0.7456635462387018, 0.6682322034233469, 0.5387019916437084, 0.23119090866972092, 0.18267219755965036, 0.15583609405624688, 0.27745706639606815, 0.22018011143977556, 0.221025309837932, 0.1528903186196141, 0.22615880742314465, 0.23742749572823962, 0.5429657012574571, 0.6172194406517306, 0.5276821548174808, 0.767731504852108, 0.4493043420500469, 0.6809841626592745, 0.5116495773736519, 0.13591302779927084, 0.7226599152206497, 0.5354076059959617, 0.474587646308512, 0.13552888184041678, 0.5555495505505339, 0.5364553309277942, 0.5216261704418585, 0.6060250291891647, 0.5990026564296265, 0.1346810697174764, 0.10931281421457739, 0.2221684983891623, 0.11732766766379554, 0.0001420584228817301, 0.18656109634482987, 0.06430573759180047, 0.15880071334390433, 0.11496459587763097, 0.2547179477416507, 0.2259023515320382, 0.18083509158321742, 0.3433223101693087, 0.14492780024340102, 0.17733633846268781, 0.08481797462689034, 0.3207822813516553, 0.26869939297470624, 0.25959139547786314, 0.3717304685369637, 0.0743267133601686, 0.13550272309143097, 0.1077116935942255, 0.12066877403758991, 0.17957525362238413, 0.19859021269090815, 0.3481057591509863, 0.07268944339042605, 0.19866194439867102, 0.2597376594294817, 0.2718054571343499, 0.22815987558504347, 0.3708685838866731, 0.2787847248362155, 0.083295513885428, 0.21303984905927464, 0.2443913843878528, 0.6994532868744349, 0.6488778019101293, 0.7300188127870232, 0.732365409935227, 0.5995580804632529, 0.6443028808838416, 0.7317817719493696, 0.7547489967953094, 0.713068705945926, 0.04110657500244197, 0.0644346572764154, 0.03920863048528844, 0.0618169404563812, 0.07737404086357269, 0.13437136966546692, 0.11926355215399675, 0.11289287152828198, 0.14512682692404455, 0.7392552338159386, 0.41985543494369637, 0.22271406106849012, 0.19421850915058192, 0.5618062044726327, 0.2608695084641044, 0.21204464819583047, 0.5879771973354558, 0.5897313569140239, 0.23891753113141245, 0.20047079071596552, 0.48556995662096747, 0.4127780363437722, 0.45224824488044413, 0.5031130222329883, 0.1641243783640015, 0.30350942377989243, 0.1768796013651458, 0.23461803015702376, 0.34409709390064747, 0.11210485780880752, 0.1641159337372986, 0.22084807938887985, 0.17998322900777353, 0.19265966649281796, 0.2957054617537028, 0.10076337762385246, 0.2421869951104728, 0.21682491906168622, 0.19643907220227075, 0.22986774994537573, 0.23748360671874247, 0.20759975209143, 0.24141789688116355, 0.223338540279722, 0.25175506401292724, 0.18483936926282474, 0.174078587752175, 0.18450757890751002, 0.18937700141607372, 0.1960876992249213, 0.1837600318323459, 0.2010130072755758, 0.20478559511819128, 0.18957501304414315, 0.1872829227156877, 0.1893950246320174, 0.18855964751944954, 0.9411714031509087, 0.19861362725553422, 0.9449790373807201, 0.12275117994763385, 0.9317265795408931, 0.16724757842115046, 0.9224073481916812, 0.21276944395176933, 0.211586781083009, 0.21142525022082714, 0.8066139434930528, 0.21111939042461858, 0.8677354828664442, 0.8695262084773743, 0.8512706939514237, 0.18510669650829137, 0.18333921186956292, 0.1927192578595016, 0.17159141286514912, 0.18107247538893434, 0.18551374673431997, 0.181221766050501, 0.18070981748366155, 0.18120355336223093, 0.09269266553167199, 0.09965151648289716, 0.06961243077794921, 0.07900806853865272, 0.0980419429946342, 0.08180500701181115, 0.09150302990804271, 0.08693433204190204, 0.08770392485194012]}, "mutation_prompt": null}
{"id": "92d3512c-4922-47f0-b9ed-30bd3b65d697", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.positions[i] += np.random.normal(scale=0.1, size=self.dim)  # Local exploration with Gaussian perturbation\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a neighborhood-based local search using Gaussian perturbation to refine positions and enhance local exploration.", "configspace": "", "generation": 64, "fitness": 0.21451902542509949, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.40699462744799764, 0.4163031713572438, 0.40820237079864496, 0.4032994097977304, 0.4222703322813077, 0.408975347763018, 0.40738759967756943, 0.43114586349220485, 0.40131269665562985, 0.037783319929237, 0.005136003652740917, 9.999999999998899e-05, 0.028253863773759047, 0.0029834898871631266, 9.999999999998899e-05, 0.005369718525791711, 9.999999999998899e-05, 9.999999999998899e-05, 0.07939852820769044, 0.10771253308067208, 0.08011829621322863, 0.11158128726818628, 0.09846427015900949, 0.10855719073917136, 0.0768023478891795, 0.10325535729511959, 0.1025660503932928, 0.08465722900477946, 0.09383060185103298, 0.06754332455847689, 0.08894271537842757, 0.09750553960077446, 0.055189181706300716, 0.0919281460087581, 0.0678991710015866, 0.07454231424718216, 0.9202795108238376, 0.9145595354645057, 0.9488063614267389, 0.9090431374656014, 0.9156783810522442, 0.9144019630189797, 0.9207441459614526, 0.9193204586300784, 0.9348065762185884, 0.277819087231465, 0.25973603015910407, 0.2803607859450902, 0.26219384226464104, 0.2572722977479912, 0.26520775861973966, 0.26571563834627854, 0.27370285133005945, 0.28398474164767995, 0.3476766030080598, 0.1958760343349627, 0.143052035025513, 0.2860203685585355, 0.3581884829159133, 0.27247510285913146, 0.21311585649263165, 0.2308539034962147, 0.34917455937842445, 0.1642252267070473, 0.1272137992088641, 0.15475576277289205, 0.19842312174355037, 0.12229925659172713, 0.17161762392367108, 0.17596932223980244, 0.15241731287144922, 0.14764939703360125, 0.15974208024604863, 0.17948623778588246, 0.12196642879231545, 0.15430136965111563, 0.1590389716017513, 0.1635043115586794, 0.19035924724521558, 0.17769561211744278, 0.12810639367390864, 9.999999999998899e-05, 0.027245229918772207, 0.008736135029967729, 0.023271278867902367, 9.999999999998899e-05, 0.022514550823800716, 0.0018052877697124492, 0.02966186839227425, 0.03384897632714878, 0.1467267580944599, 0.10347056035518709, 0.1098312724449082, 0.06653624684153092, 0.02420151620228772, 0.01860147601893236, 0.09581094700832404, 0.11146701151211202, 0.09925569337923446, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11952536146797088, 0.08042719323258574, 0.08842226843273837, 0.0741394059181344, 0.06484632345078567, 0.06448224840732653, 0.08825684042721782, 0.10303170292979158, 0.07984705973743367, 0.4221620860066758, 0.3945509830279892, 0.41027367502094725, 0.3840335791475592, 0.4064510122721645, 0.3889199624476931, 0.40858447045108903, 0.38893139858028136, 0.4059994953539864, 0.05605160576015766, 0.10316940297624255, 0.09903857513728531, 0.1314178774845759, 0.09294737103401673, 0.10124837510673879, 0.1355955710726814, 0.11385772613086265, 0.0863016798526034, 0.20777928037252658, 0.2121044406463537, 0.1927096473986284, 0.2037678397904774, 0.19683560475065998, 0.23867949433665325, 0.21616388082384685, 0.22898315267591063, 0.2482869222851276, 0.2180503766068509, 0.2639773539874223, 0.26002093692924955, 0.28560837637763703, 0.26794279378154884, 0.2884910929673684, 0.28050181239236205, 0.28326182124758137, 0.1848722477611966, 0.2230314560708433, 0.22259553251338515, 0.16466508075420572, 0.15477217211747174, 0.22993560399123136, 0.21947641493766368, 0.19292670032068504, 0.2367583425880655, 0.18035636080629824, 0.2177496223939136, 0.19757121937502398, 0.22280636127486542, 0.23640883509105293, 0.2231436686663294, 0.21325169948846956, 0.23788000633994444, 0.2222532404010672, 0.24034873066075835, 0.1809716808838414, 0.2326537777423151, 0.2141528716254616, 0.1844556662762208, 0.20038223197936733, 0.17800845422505596, 0.1876547781639174, 0.19264114122529252, 0.18910354573408472, 0.1761559450844603, 0.18665357908283498, 0.18698434748174309, 0.7078273300698121, 0.19925206076625657, 0.5685955275818912, 0.12088652732566474, 0.6741904189980217, 0.16643732842884074, 0.6209157991112606, 0.21124176211986767, 0.5334483544407036, 0.21094587255016506, 0.16934829471601864, 0.564426184216464, 0.5050111229945782, 0.520519109098736, 0.09427446692775288, 0.17540445400106042, 0.18884528887562924, 0.1787982255218714, 0.18535935877593124, 0.19910578458749528, 0.18755133861934803, 0.19405616951915272, 0.19436662119467696, 0.19591715259490283, 0.07609257452016005, 0.09237682239232559, 0.07441474604003107, 0.08013593417079412, 0.096979435346784, 0.11528865777049191, 0.0896728780892212, 0.07694241658879508, 0.08194784675409406]}, "mutation_prompt": null}
{"id": "bf2575b5-99e3-4017-bee3-1dd20623863d", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "eb2568a7-74b0-4500-b331-6b9f459c2761", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "acb648f8-19fe-43a5-83c9-d1af59b942b1", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "d6233429-3d8c-45b0-adb9-8ff3f8bccd6a", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.3 * np.sin(2 * np.pi * evaluations / self.budget)  # Sinusoidal change\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.2 * np.random.rand()  # Increased adaptive range\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a sinusoidal inertia weight schedule and adaptive local neighborhood influence for enhancing global and local search balance.", "configspace": "", "generation": 68, "fitness": 0.37923293667762303, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9006526835384675, 0.8860093970208376, 0.8911247405940833, 0.8866766952420212, 0.870606322065118, 0.8943353904868327, 0.9048366732838882, 0.8810481635144081, 0.8607515814796469, 0.6903865225546821, 0.6642839704461562, 0.5892171102990713, 0.695165357434506, 0.7279700261237052, 0.7047420304041314, 0.6099338932168497, 0.6996577090946318, 0.6142363846964203, 0.08337920315483349, 0.1238926142890534, 0.07197576019271568, 0.1440290600123677, 0.09140949623318284, 0.11591562286465928, 0.09591323532828155, 0.12415018596956529, 0.07850298945067302, 0.08472471387492009, 0.08334420096235295, 0.06791155512340208, 0.1128790926634825, 0.07930491740641177, 0.08216744194292802, 0.0769550844979251, 0.1097363433823646, 0.07211577722327589, 0.9234746219249471, 0.9233403300177145, 0.8854848547192423, 0.9097760809183557, 0.9320536840136304, 0.9135375510170807, 0.9202304033075921, 0.9383566487831195, 0.9227307205502789, 0.5549757521804095, 0.5430634805962701, 0.7023025651462041, 0.6029915911201156, 0.5957940648396527, 0.5356754034129543, 0.6665005637682502, 0.6690198363645783, 0.6852145990121162, 0.210627159326634, 0.17122128823837046, 0.2208553389131359, 0.3862347822437139, 0.3731199877821709, 0.21327637977393832, 0.8376596649671835, 0.23656014486878996, 0.42841904064552294, 0.13439701879388144, 0.45667352892282154, 0.6122799655913459, 0.36895642380011817, 0.5441410944748662, 0.3960330576098452, 0.6842995230130624, 0.46161282233152956, 0.7654192415674789, 0.5536015129740232, 0.576828580916231, 0.13451706060946655, 0.6654813572707297, 0.13488145460394318, 0.6243822425661297, 0.6886056267266262, 0.7134625439323431, 0.5415359242708631, 0.26151376907620083, 0.06588971341461891, 0.08409749852866644, 0.12383685357723573, 0.06799159321127313, 0.08256497901442839, 0.16609694476417447, 0.10989401504566576, 0.13369437383553928, 0.1574787269299115, 0.1479183467809264, 0.19632418074244273, 0.16156027699879194, 0.1593606229075194, 0.11057891544377141, 0.3077995949471274, 0.5573585300004269, 0.37250019351268915, 0.31453786574306675, 0.24912932531417942, 0.274193685191333, 0.17389325415378065, 0.2501081183747206, 0.31695010882874675, 0.2063881510940908, 0.07510025951329502, 0.08549653929085088, 0.25649077189571123, 0.31604167572385067, 0.24459302130528382, 0.28505091758658396, 0.3229045154783444, 0.322278013856629, 0.25170229660338383, 0.3197864791558489, 0.11825698173634447, 0.7370480553829232, 0.7075095519317856, 0.6645170713334903, 0.6898587731158436, 0.6917913692573894, 0.6933436981099491, 0.6773979247821467, 0.7237419118890873, 0.6501846275210059, 0.04128851891634988, 0.10844000413420474, 0.08558664860196297, 0.147025765449465, 0.0967665165656234, 0.0967711805295216, 0.1292291974898362, 0.0982333084097392, 0.09872975292227837, 0.22400674180991864, 0.44784423865084577, 0.6786262701321477, 0.31398999163672814, 0.2664150048068492, 0.1812776640402184, 0.17316426951478314, 0.2835875368494951, 0.21265558380953875, 0.24216926070438682, 0.4770526837125487, 0.23287195227392998, 0.5019136695181511, 0.24117730252346192, 0.19708995454241052, 0.23580260187932667, 0.5113832906876943, 0.1474341431552444, 0.16083842144424998, 0.275486345653147, 0.2331701892037057, 0.17190080566601373, 0.25044554447293443, 0.2646337253146467, 0.15681780886904728, 0.2279477406669982, 0.10605166570271762, 0.22940168150560025, 0.22398904756908844, 0.23464385939974008, 0.24102421469602664, 0.22394544518040904, 0.20902772111131918, 0.21755988494295597, 0.22341334621279507, 0.22371045046950566, 0.18715951250849594, 0.23067388247434573, 0.19163311083783396, 0.21143723511104306, 0.19987536150096474, 0.18879748130793128, 0.17773259217724902, 0.22624682232496796, 0.18866938472207173, 0.9353720265002577, 0.9230399977193945, 0.17651254110386616, 0.9461815956828278, 0.1978323521908455, 0.9271412391244088, 0.9198951582966145, 0.8903841704796344, 0.1673641152154427, 0.856824529963097, 0.21268022507419637, 0.895287151379161, 0.2109612797130771, 0.8605839387022456, 0.8772850029147254, 0.8519601477590932, 0.8816393810117478, 0.10450994468610375, 0.19566690318949287, 0.18380436543467948, 0.19034706642541843, 0.18343057670432783, 0.188505196136733, 0.17533503257033523, 0.1759227927331518, 0.18128481193444412, 0.18091886722791461, 0.09659557618127368, 0.07099637547119841, 0.07875222124445447, 0.07971377586088424, 0.08645136379649399, 0.08997566741294794, 0.09767222908195305, 0.08152296522829094, 0.08089584650717463]}, "mutation_prompt": null}
{"id": "07a14bcd-d028-4cb6-87e1-c321fb6b6785", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                # Line modified for adaptive cognitive coefficient\n                self.cognitive_coeff = 1.5 + 0.5 * np.sin(2 * np.pi * evaluations / self.budget)  \n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Implement adaptive cognitive coefficient for improved balance between exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.38199470053283774, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8791820162564702, 0.8784556501884688, 0.8925736080018272, 0.8679196714332169, 0.8677714297865925, 0.8855205914972876, 0.8868629045840343, 0.8677684106215711, 0.8694375437600056, 0.7064314051651973, 0.7007527193155345, 0.711485352141789, 0.6962617216595282, 0.6899627163714668, 0.6482258755061904, 0.6215982238598579, 0.7166263816062932, 0.6750650226641682, 0.07848563940458952, 0.11356919184693393, 0.10214296781410248, 0.10348016227038481, 0.12448096617315663, 0.1308692586636243, 0.11633337133665533, 0.14401522602532335, 0.11777852512213283, 0.08751921789012995, 0.10037122917959784, 0.06839492815782522, 0.12509058775719006, 0.10927474946551807, 0.06787634693988454, 0.1086286874900445, 0.10652325071580804, 0.11415819165347707, 0.9358611606666575, 0.9354045794091852, 0.9190159028838379, 0.9031641002077075, 0.9355702927948445, 0.9357035117822912, 0.9442514767805532, 0.9459058514288212, 0.9200187068969375, 0.649234311145084, 0.6266340875828595, 0.6341470023200535, 0.5860113927246129, 0.6157512967057567, 0.23251220329039557, 0.6515569481587506, 0.6223516752875635, 0.5487274046880699, 0.2308179329698562, 0.14011916370473732, 0.14624838078888547, 0.9383406213947033, 0.8755546200651051, 0.3699944601558397, 0.17797380199734325, 0.16367447577687255, 0.23481380770593663, 0.13611501809339044, 0.13559749501746376, 0.6546940321114854, 0.549584975925092, 0.4819765139639113, 0.5210023917518276, 0.6865255546624021, 0.1352209221371209, 0.4438021701442161, 0.5634865619062286, 0.44538194948871, 0.7251880012933407, 0.6437951487157769, 0.5591760619308483, 0.6058986608923356, 0.5999788788107995, 0.6551671785597339, 0.5454633858538458, 9.999999999998899e-05, 0.06173035237269886, 0.1965018005436675, 0.08014709858990476, 0.027893277793582083, 0.16404617738033833, 0.2510695501475948, 0.12659931899299592, 0.35491552670532, 0.24187966630303726, 0.16299761608647256, 0.6539274310360672, 0.09817321408267621, 0.06297314930873166, 0.04794336837317004, 0.482301875251404, 0.2856271864870943, 0.33791141811935477, 0.14465640386879963, 0.16836975337823146, 0.20872493410522797, 0.1592087187895992, 0.07794062755525155, 0.14058359092974515, 0.4181988847537321, 0.1763278680154906, 0.08310085461416128, 0.15425207046697886, 0.20326775232218697, 0.27077871351571636, 0.36777365013509267, 0.25383239649723643, 0.24069702452719344, 0.13738367385064143, 0.4560881756843902, 0.2862969736480191, 0.727128213915528, 0.7559447135670337, 0.7626949701664316, 0.7871666986956734, 0.7586238968299946, 0.69475104762986, 0.7004431051744772, 0.6719986607486598, 0.7728487882674862, 0.06519049235190144, 0.05669928767934129, 0.062374990134035024, 0.1332195461852339, 0.12317234873320793, 0.10286841455894191, 0.7299765046239137, 0.09931664801212259, 0.10188759493158794, 0.22334300966714515, 0.22278355451177945, 0.1847562611809922, 0.21542562225248785, 0.4562482232581284, 0.2190778044532421, 0.2494688419364477, 0.3367941929385506, 0.41130525127522866, 0.2359225829942272, 0.4513231565777863, 0.24902505580460743, 0.37851932028503377, 0.2750568820720334, 0.3085401093185901, 0.2275193915115704, 0.5012917904808429, 0.143479715636198, 0.11945180209162831, 0.3209092617879664, 0.16406964555980463, 0.2766789474995791, 0.27996644941479276, 0.26965828688378213, 0.363881720663491, 0.19447635290822185, 0.09682237726899856, 0.2489331580555274, 0.27576337236986226, 0.20153016481994634, 0.21222017605916477, 0.24677862911624637, 0.2385094941799769, 0.2377849639092181, 0.2273593528627097, 0.23330007492683302, 0.1820418409140706, 0.19937528979397756, 0.18484167985914346, 0.2030176719100163, 0.1905486995323864, 0.1963012893369369, 0.17240298725532832, 0.19352257616710988, 0.18040505901329562, 0.9424364818938858, 0.9325222416823999, 0.15326053639647086, 0.9242315695094118, 0.2005312120982632, 0.9251124031386279, 0.9146075410385759, 0.9099294656439361, 0.16853485229582765, 0.9359330173236272, 0.21221467436675312, 0.9231595058593169, 0.21056636716856247, 0.16803166720771223, 0.8950056428283343, 0.8625133293442886, 0.8934824388458742, 0.1048276220282105, 0.19168496295945947, 0.18457471875853404, 0.1888090739962882, 0.18402271853909014, 0.1786424921700469, 0.18534537617273494, 0.18046955292131006, 0.16981674340828634, 0.19412219021720156, 0.0920236073887829, 0.09646219670577993, 0.0792217227538522, 0.06958285357593963, 0.09063007473940254, 0.10928510849943762, 0.09214601569586633, 0.08720405109559037, 0.08064536717547377]}, "mutation_prompt": null}
{"id": "28d9ba36-7e85-4144-a951-92cbb44f8f50", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            # Adjusted inertia weight oscillation\n            self.inertia_weight = 0.5 + 0.3 * np.sin(4 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce adaptive inertia weight oscillation to enhance exploration and convergence balance.", "configspace": "", "generation": 70, "fitness": 0.36413640880003184, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8333593944478808, 0.8351519731587183, 0.8455745044790316, 0.8197357603180792, 0.7842503123844362, 0.8381970548084812, 0.7844168188179254, 0.8493073711049283, 0.8308600306097429, 0.6220995804582495, 0.5713552184443509, 0.5322911522073054, 0.590960914901238, 0.5305626552404947, 0.5340715989789664, 0.58034971951256, 0.5712285223702706, 0.5619626293212945, 0.09786077932866466, 0.12007428173330426, 0.08979772537969877, 0.10896200460243877, 0.13125176193953536, 0.3269467308189805, 0.11169139132153783, 0.1107091373191641, 0.11081759965968907, 0.08971428380338875, 0.11315306737910358, 0.05968619502292072, 0.13607278764984532, 0.11101255155528089, 0.1285699334433974, 0.106617091546645, 0.08156253944480885, 0.10021859514797649, 0.9203424932735127, 0.9315774776027415, 0.9232424855268881, 0.9156260361796877, 0.933081832321718, 0.9343057999594809, 0.944413529343264, 0.9458684861886533, 0.9130743199439824, 0.6091666566350765, 0.5905122909440728, 0.579689060013019, 0.5540442756109966, 0.4475004774488075, 0.15090671373289133, 0.5730578368704147, 0.5793342657190221, 0.6021714308825687, 0.2297710147845241, 0.20720718674605654, 0.716501518939495, 0.2807910625314888, 0.7825417168146265, 0.37775715492055995, 0.17795349654558212, 0.1693160572684952, 0.23494333128091882, 0.1361314389440469, 0.13466629069443192, 0.3870043800478635, 0.46726463964316456, 0.2096384562849919, 0.5216548538692396, 0.5545317923257647, 0.650103705288519, 0.5668461072702407, 0.4325590890604031, 0.5559375453019195, 0.7100722238079689, 0.6413472236000924, 0.4083670697581795, 0.37754373527933627, 0.13550781163716075, 0.5726673766425805, 0.39465906334165735, 0.08497748672529071, 0.06358031160335798, 0.26858124856340815, 0.11401169405288292, 0.2681182247552676, 9.999999999998899e-05, 0.10187108178098514, 0.075137829856188, 0.12029240543494402, 0.17312734059232426, 0.11723293031618154, 0.4833347652439631, 0.14066999452324414, 0.10672668428452858, 0.10285563164267808, 0.3986075786207721, 0.195083383571657, 0.22251652135340338, 0.08506826064526973, 0.1690066390261944, 0.15049843716209943, 0.12195435265830878, 0.061335259308316736, 0.07634340703316522, 0.28320251224798676, 0.15678431840554496, 0.07037399814411005, 0.2102151370576828, 0.21536589414209562, 0.3290118462470498, 0.26201706844449346, 0.24057334570075195, 0.30538527995492104, 0.17161304680203648, 0.2822524279787265, 0.08294039661213914, 0.6035069429510507, 0.655237895152859, 0.686272698567636, 0.691273202362373, 0.6274323353949756, 0.7484305875575834, 0.6571078283609179, 0.7664578184558521, 0.7158157683449711, 0.10177558029638001, 0.0823795117959526, 0.05890509698034052, 0.08859092647463129, 0.11492465776961325, 0.11633775255393086, 0.1415023906283457, 0.11868162902975177, 0.10047921343517263, 0.48284543581824246, 0.5971463633479499, 0.4469044896349359, 0.2966009047731012, 0.5592283366522339, 0.3507409807175702, 0.4262346542538312, 0.45701668014385455, 0.1900347570984674, 0.3465741450652927, 0.39954632977246196, 0.24310093741310645, 0.44685994657304295, 0.27173474537855113, 0.4887963662648489, 0.3651693439116819, 0.44243693555765207, 0.21645378789780867, 0.25145218626130694, 0.2544466275392482, 0.22884009035030883, 0.2121392994642517, 0.28403484786739097, 0.2513916517547151, 0.26485336773977497, 0.23808643627059745, 0.10866340173144873, 0.22924997297529504, 0.23806480516112294, 0.24355744232865717, 0.21031243423832546, 0.21118553244874716, 0.21529146470554406, 0.2004911392446086, 0.25520420018695955, 0.2380690069345487, 0.17416756945605572, 0.18900371632061863, 0.2403023101550279, 0.20326276764116868, 0.21817716585138303, 0.18188745385954852, 0.1741730097177535, 0.2096394404399189, 0.1812040885648314, 0.9384647109613958, 0.8935830573074934, 0.1532083723338994, 0.9083468282136973, 0.20054589951175372, 0.9333317622006984, 0.9122281395752834, 0.9062825260396841, 0.16858031093835713, 0.9070268377083482, 0.21225299992404356, 0.8849713371875315, 0.2109811755880565, 0.1678229505200346, 0.9031685032570548, 0.8425323686398813, 0.8995334231783482, 0.10485089516422652, 0.19108982853376733, 0.18104355750235046, 0.1776139644459237, 0.17217724760802344, 0.19698340754882737, 0.18544552437763662, 0.19281576035954118, 0.1847310149159782, 0.18154420672393812, 0.0801024246391151, 0.08096350708722688, 0.07437564387397266, 0.08010179776107595, 0.09187685269401735, 0.11718378331561341, 0.09217147522435676, 0.09318108892841936, 0.08024149144276782]}, "mutation_prompt": null}
{"id": "613bbc66-88f6-49e8-9d53-5b8e69735943", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "1335f0df-c7d3-4401-9a7e-d1e60f2acd66", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction * (1 - evaluations / self.budget)  # Dynamic neighborhood influence\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Incorporate a dynamic neighborhood influence to balance exploration and exploitation.", "configspace": "", "generation": 72, "fitness": 0.3804379066706722, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8917337652237805, 0.8856245296359069, 0.8959156238724545, 0.8809057619816193, 0.882041924925809, 0.9000738088061911, 0.8771266233648466, 0.8746900120376115, 0.8844832874481825, 0.7123701573492206, 0.7209400333907343, 0.6119853192366795, 0.7149957107556646, 0.7468718838427237, 0.6374238034553571, 0.6280382068116814, 0.6204970006460797, 0.6680853313392885, 0.0779052265557506, 0.12287146005099825, 0.07172231994365519, 0.09555123850545677, 0.1044004626346201, 0.12310620592938781, 0.1170346633664785, 0.1243202976973713, 0.11723680708994177, 0.0957156920297555, 0.12830608667090004, 0.05974012171768539, 0.13228239260767694, 0.11758462827985472, 0.08080822898722728, 0.10882403504812121, 0.06978187127904689, 0.1131512241382383, 0.9359622209772368, 0.9355463598060769, 0.9193004557537443, 0.9110295050573438, 0.9356804603420346, 0.93597406389343, 0.9443831006696918, 0.9458440804770563, 0.9202302574763415, 0.6479765886027371, 0.6256804434827291, 0.6043094260889017, 0.6422981809386831, 0.6044423615788681, 0.1507689588147174, 0.6768631626437414, 0.5909977769656328, 0.662928689221254, 0.23052728646589216, 0.15923885243370206, 0.2205181734170768, 0.9321503759271126, 0.3832734043366258, 0.2798951155727043, 0.17790521288055938, 0.15211100078422857, 0.23479886159912555, 0.1359487970047294, 0.13610160420021333, 0.570464532388114, 0.5670185512938428, 0.6253383034872184, 0.13161331710279245, 0.6552087756718707, 0.13482394065823333, 0.5588013063755862, 0.535958520639173, 0.5740307602090071, 0.6620356429207868, 0.6935874600956096, 0.6121218315877373, 0.5900638076868698, 0.5408732546819599, 0.4985340753794466, 0.6102808231564953, 0.20652073300059948, 0.07048239928141498, 0.268675281671533, 0.22514553263098547, 0.1290835023232192, 0.04751542466376646, 0.20561029116004292, 0.1500635439302348, 0.12431950663381863, 0.22820782617716873, 0.1292930915715922, 0.3758028297197681, 0.2768810606492643, 0.14092672021150487, 0.0645391400241373, 0.21921524482222465, 0.16528748196176224, 0.36105404330309054, 0.11379888565063356, 0.20905352005369982, 0.16635080557994386, 0.21493516668269053, 0.1993453046018343, 0.09949259404492061, 0.3713846567577719, 0.28696964946139636, 0.0886571144407895, 0.21627866470832924, 0.18173186622412374, 0.24935307577609078, 0.17480052330044327, 0.28388833538657376, 0.22701595263386498, 0.0836990363488247, 0.35971896032178585, 0.2599855524772724, 0.6950820004868921, 0.7533077080822355, 0.6937408570711294, 0.6984806619460439, 0.7270070853358748, 0.6915681644524244, 0.6437928250299615, 0.7406011345609627, 0.6718829753890151, 0.0878535965107261, 0.09549912797066284, 0.032102264519553114, 0.10922216140857033, 0.11247702585872843, 0.14666453111842126, 0.15736604572452506, 0.16858088971313845, 0.11225022889435954, 0.22051317471797238, 0.21359379764823594, 0.4707978493540893, 0.1623319869466524, 0.4594331625480784, 0.6232562453175735, 0.16767695799141025, 0.6188450657988147, 0.6272090101291206, 0.5639866912837956, 0.3349450078030549, 0.2810923625743047, 0.5228698536926083, 0.614749515610424, 0.32812884792484975, 0.2475450856207856, 0.5676798734924597, 0.12145179272103812, 0.2340641029208138, 0.31341920112199995, 0.13643776617964998, 0.2870560733955134, 0.296127065970344, 0.2399731744508552, 0.17526256958145636, 0.2012749551411347, 0.11678715909382431, 0.26687055124134196, 0.1884980222501993, 0.21014430091067038, 0.25688101107210703, 0.22096746913013854, 0.21940934918496613, 0.25223025874837945, 0.21225406859929208, 0.2144959569669046, 0.19480421036268802, 0.19286571910211703, 0.18980724438665597, 0.22119777834873489, 0.23105512699050634, 0.1816666440224397, 0.17320998807082966, 0.1987902745198925, 0.172033326729908, 0.9321536071209305, 0.9110701373370136, 0.15329739277601695, 0.8884155676475098, 0.20054381681734246, 0.9353554713583491, 0.9262217856235352, 0.9173284269547765, 0.16860800014114807, 0.9146732030040038, 0.21236104306288628, 0.9363079731237349, 0.21073795533797768, 0.16781871388637704, 0.9334325072252536, 0.8075450187916753, 0.8673387116669946, 0.10485048979734879, 0.18946702030313844, 0.1767073782655325, 0.18260057122379925, 0.1993018067547866, 0.18173469431115596, 0.19152139758238973, 0.18139719970557344, 0.19473650025619804, 0.18821420994218918, 0.08130778426378726, 0.07810713501643352, 0.07662320689488933, 0.08195675430954574, 0.09348483835418864, 0.11204696247611778, 0.08396492713464432, 0.08203063231486973, 0.0674873207511626]}, "mutation_prompt": null}
{"id": "b67ceb34-7f52-4e64-bcad-7ea2b6cc45da", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n            # Random restart and adaptive personal influence\n            if evaluations % (self.budget // 10) == 0:  # Randomly reset positions for exploration\n                reset_indices = np.random.choice(self.population_size, self.population_size // 5, replace=False)\n                self.positions[reset_indices] = np.random.uniform(self.bounds[0], self.bounds[1], (len(reset_indices), self.dim))\n                self.cognitive_coeff = 1.5 + 0.5 * np.sin(2 * np.pi * evaluations / self.budget)\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce random restarts and adaptive personal best influence to improve convergence reliability.", "configspace": "", "generation": 73, "fitness": 0.3854127345380598, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8788081854669039, 0.8926084309855301, 0.9054406695809262, 0.8580353292334957, 0.8821036612846249, 0.8712075319969714, 0.8669779203053909, 0.899677243919055, 0.8951771442131242, 0.6687246385340029, 0.6670027234747533, 0.6126188671918598, 0.6834512230624374, 0.6923277020006614, 0.5923259377589947, 0.6933069663533449, 0.6910849403486445, 0.5928817061444478, 0.1101103734880986, 0.15660088290618368, 0.07253268828239268, 0.09611579637378342, 0.1691983256250238, 0.12651520036780517, 0.11659102797257148, 0.12256087047982422, 0.12257114690624071, 0.11243113938249338, 0.1127913883283107, 0.06089393561333767, 0.11086521215570322, 0.11104351639467291, 0.07817370272689428, 0.10539117029881617, 0.09604310021503648, 0.09041647649447038, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6032529564938989, 0.5344075986056402, 0.5625240648647056, 0.6469257381923593, 0.6123386460295153, 0.15164264198680644, 0.5160134287034863, 0.482541675940809, 0.5933487456365469, 0.23051347856664428, 0.16927335742942884, 0.14183478969929442, 0.9329067373147839, 0.6327940913571999, 0.27973846200488295, 0.20333066558961332, 0.15881602916978588, 0.8920904087059328, 0.13606233157356873, 0.1353968820650926, 0.4806167273793064, 0.5361838240407508, 0.47299311114371856, 0.3371045267201769, 0.7600665574273437, 0.17021042532038988, 0.529383130811183, 0.5322741799635611, 0.5674541526185553, 0.7086028069661734, 0.7171804779196521, 0.47553532596766857, 0.5371450673021698, 0.3754800809843063, 0.5147952704359294, 0.4562860927593988, 0.06412633672609369, 0.0568024186142877, 0.2839764296238668, 0.08148451126498457, 0.21406249641774033, 0.18810075913972524, 0.22369970777698822, 0.24921551580925894, 0.3118228026409844, 0.2119282434892963, 0.14702892986031324, 0.7043506697139847, 0.19401298849595527, 0.07325354391200145, 0.041580372980189684, 0.6328296392797216, 0.23609571452171818, 0.1640814780559906, 0.11343529817124831, 0.26115307131102683, 0.1694910670745854, 0.22762356903386582, 0.13602451674488913, 0.16233540063377894, 0.39069260563607866, 0.298733003086057, 0.07317007492442895, 0.25182650128722905, 0.28028917825074606, 0.2605303010673511, 0.3004033204733616, 0.2940957438078087, 0.22394992541303727, 0.0839155536181384, 0.36281063828986093, 0.1423031529400307, 0.7025931657824487, 0.785577467769645, 0.7524854337386981, 0.6921442518404864, 0.7094552767253268, 0.8091417925935417, 0.7488298101809312, 0.7164304918890778, 0.6803283110319345, 0.0652751184023409, 0.08097507085317868, 0.0623011388069763, 0.15211952283977592, 0.12438446086145816, 0.13303918657019953, 0.6716526124480944, 0.10310941032883914, 0.08755054270100537, 0.39715914026223986, 0.44589010853463007, 0.27800114898423567, 0.1840262452591015, 0.4895938999613675, 0.34542757484341546, 0.5739493257007743, 0.27331921791928626, 0.28972176044511244, 0.4180318121876412, 0.29128550319309554, 0.24309875046326157, 0.49291980017127146, 0.27195476028693877, 0.350332570517758, 0.36629411142733403, 0.2763498031427565, 0.1482432217605727, 0.35620505701397764, 0.30428353045145073, 0.22388621695327826, 0.2787873056240785, 0.33199577614523934, 0.27357541247563666, 0.23471649267594874, 0.25610053992639326, 0.20315138186674753, 0.23989122272044316, 0.22569064869897948, 0.2001695564436431, 0.23478804671625064, 0.23556087545839655, 0.2206899019888351, 0.22239359798815672, 0.2730871694725642, 0.21793729502286374, 0.18015272922542336, 0.22595716222712547, 0.182082246985251, 0.21004923559578292, 0.23065470464752602, 0.1851275637969677, 0.17297250250271012, 0.20896025925721484, 0.19903851809460982, 0.938524969584397, 0.8956071709617807, 0.1532772028590763, 0.9361359611008366, 0.20053844491490413, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.16859005755338963, 0.9009090865623024, 0.21236460738076735, 0.9260633743059126, 0.21072805324089783, 0.16776302333887416, 0.9016550575716691, 0.8717563323943686, 0.8742109843802582, 0.10484542488027215, 0.17747134843796708, 0.1740278556671354, 0.18198567877491245, 0.18230677765412406, 0.1732029781283534, 0.17547559817299274, 0.18403291832659763, 0.18165248801951273, 0.18136964350034135, 0.07957127751966486, 0.0986370120485821, 0.07790681179604564, 0.0808696239707486, 0.10511022144874316, 0.09943138361279547, 0.07894398898332888, 0.08085665022018451, 0.08931165888832582]}, "mutation_prompt": null}
{"id": "1e583581-8a51-4490-9c25-199f3735762b", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "3a1fffe1-1f0d-4136-8fbc-04c48f76fe30", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n\n            if evaluations % 50 == 0:  # Inject random individuals to boost diversity\n                self.positions += np.random.uniform(-0.1, 0.1, self.positions.shape)\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a diversity boosting component by periodically injecting random individuals to prevent premature convergence.", "configspace": "", "generation": 75, "fitness": 0.26621152030306033, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.6038636635218296, 0.5767223461737575, 0.5994508612576295, 0.5648166324954351, 0.5424728442926355, 0.5641762628788838, 0.5732975821355265, 0.5725954125673924, 0.635533709800497, 0.11830934114519565, 0.07128886686092051, 0.08327530326590771, 0.06392347141201993, 0.09955795285783609, 0.0727254144201046, 0.03736539802841088, 0.10493409474613202, 0.07107894112024915, 0.07324179018266663, 0.10362316469034905, 0.05963408038450069, 0.12241751347483043, 0.14035735964759022, 0.11098532559197627, 0.13138322116460655, 0.10886630910810513, 0.11191743914799279, 0.09314675821068519, 0.10672800619750433, 0.0664924766556434, 0.12385299511854297, 0.09750935078663026, 0.08201342829966785, 0.09704567975425582, 0.13876644766718293, 0.09324346046707721, 0.9341466887905887, 0.9018747367536901, 0.9136392726224813, 0.8864200846687991, 0.901234140342334, 0.9026854447917754, 0.9336673096735849, 0.917906211275739, 0.8898496524556928, 0.3570108281094623, 0.39466830467442615, 0.39208534104901704, 0.3683108710717, 0.39531158750734463, 0.3460354171066403, 0.40183381783327, 0.37139535688825853, 0.3669807251534619, 0.23120016647545105, 0.16971639692598817, 0.1395547612055723, 0.9333719701742075, 0.4390865684172991, 0.27944340810361334, 0.17808861401176967, 0.15197233893814266, 0.18248261795027076, 0.13435139482666258, 0.13562633418707937, 0.20104851781629662, 0.19296063345640235, 0.2052421706181483, 0.17964643326170882, 0.3141599520058964, 0.1339900513526734, 0.21321395096152762, 0.21770633304689113, 0.2128365944121937, 0.2739512720036108, 0.27655579250977946, 0.24635388515535472, 0.1899721271658814, 0.21163425564105032, 0.20895149622618725, 0.20420914844973648, 0.07774992811018056, 0.029806585911370753, 0.04490126779735981, 0.11765428565570313, 0.09411893325870169, 0.00017764551161492115, 0.015795808195526284, 0.04730270225844635, 9.999999999998899e-05, 0.11725730823535119, 0.1047934433436627, 0.22243070494278872, 0.06866710595766234, 0.04998091459499465, 0.02822998139542776, 0.16803880250559355, 0.12642483010686245, 0.10231717497113646, 0.007994986323655584, 0.06253060295209201, 0.028043591289814818, 0.016742871820763727, 0.023932763496352316, 0.037114739519148454, 0.048348223312669636, 0.011323052450170179, 0.048127322192234034, 0.17648169713517758, 0.17478270789019845, 0.17739376181197475, 0.12036643560005833, 0.08846637913638478, 0.12885807511696257, 0.08929106900145767, 0.15176347883316466, 0.11493242811554061, 0.48979066117292225, 0.4840097076761428, 0.4862351047129374, 0.4708630524480555, 0.5180038792373323, 0.4709378638192254, 0.48756352405217784, 0.5094040252420748, 0.49738759727869697, 0.07757432461723512, 0.0759499754630526, 0.047272186866762045, 0.12243332353391667, 0.13765927019519641, 0.10941858616447042, 0.14986820221800068, 0.0959436754695494, 0.11685774989831244, 0.26892558049599913, 0.34356142827301805, 0.17202626001069443, 0.26857758020918254, 0.30353538368609734, 0.1943906185029205, 0.24569221199370872, 0.35490346026836384, 0.17568793158111984, 0.24128603007666938, 0.3560406599054493, 0.22567217446953958, 0.3402084313590419, 0.32252934437287095, 0.3304882854036252, 0.2719653687322512, 0.33424690529573553, 0.21545876381846607, 0.24181915728484904, 0.24334557356886366, 0.12005320626728322, 0.25573721007135475, 0.2721241926046617, 0.21686293358950448, 0.17612945797238866, 0.17202262571598692, 0.09805084528377361, 0.2586618800214807, 0.25311814261359655, 0.2267387699864747, 0.2317762271397077, 0.2413130786200639, 0.2206899019888351, 0.25242197601625704, 0.2050848698200025, 0.22788440128964937, 0.1849722032576182, 0.20839466405894036, 0.19220690435618082, 0.20706789129113123, 0.2292300768592389, 0.19711098897387103, 0.16991941467527572, 0.2071402381214662, 0.18713913184228304, 0.9094078759305189, 0.9189109543339291, 0.15313292700950132, 0.9048424503541382, 0.19992199865919513, 0.9145000659642217, 0.8797473807787958, 0.8424689224991363, 0.16860605120882288, 0.6875719631296768, 0.21248085851036247, 0.804052906394706, 0.20962459922436594, 0.16813202880498868, 0.6757834288990157, 0.7219052228844514, 0.7345687918991657, 0.10486227808946769, 0.18924018138968945, 0.17514485118201917, 0.17822101265731982, 0.1789336175402002, 0.18175761292545434, 0.18026564474247664, 0.19130400441252615, 0.17846684674781466, 0.18615723943009088, 0.07836089142269176, 0.11409829528858861, 0.08734317144615866, 0.08147305603954269, 0.10543479724362026, 0.13248934969580328, 0.10185744875624148, 0.0776461423725997, 0.09235093543413952]}, "mutation_prompt": null}
{"id": "af186371-a09e-47fa-9fdb-7e6f83059251", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(3)  # Added r3 for perturbation\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                perturbation = 0.1 * r3 * (self.bounds[1] - self.bounds[0])  # Adjust perturbation\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + perturbation)  # Added perturbation\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic velocity component and enhance diversity with perturbation for better exploration and convergence.", "configspace": "", "generation": 76, "fitness": 0.16633374112490606, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.16.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.38580858024756115, 0.35754699956551206, 0.37698005295177495, 0.3269208736380529, 0.31463576901211243, 0.3410251440241283, 0.3151169659677563, 0.3432602201850091, 0.33239805741554695, 9.999999999998899e-05, 0.01099385918561857, 0.009469312377827, 0.015565770155060443, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06695721870255089, 0.07407249525784354, 0.07528230657814206, 0.08080302947070139, 0.09066841707383533, 0.08662852835295143, 0.05154451250290004, 0.0478309951561543, 0.06273991300536219, 0.0725967376564397, 0.08144265987788712, 0.08193392292238444, 0.07615100592399249, 0.04477900416585001, 0.08970065721306875, 0.046650711010364665, 0.08869955776642069, 0.07510029984046163, 0.9403599790103018, 0.9070681336028957, 0.9248331364258207, 0.5826227920981043, 0.5111038102422679, 0.8197282590523526, 0.5249577937140587, 0.12270006205751383, 0.5624370772261442, 0.25166467185810737, 0.1672727926976253, 0.23352496830777802, 0.19260306696342866, 0.18144967973383108, 0.23695898412106808, 0.07827911553397426, 0.07727440993342916, 0.2073001401013398, 0.20969083751334938, 0.279962727768442, 0.2792155507192118, 0.14521124843329458, 0.2687636523381737, 0.24411675507655717, 0.1160047152549718, 0.1613334976218641, 0.17981619086622613, 0.10136069167532225, 0.13505381109581482, 0.09793322544293792, 0.13476993229124423, 0.1336043547688447, 0.05396420939929958, 0.12852340472192825, 0.1523375925646927, 0.14621636503447122, 0.13534131501712277, 0.14961510020137647, 0.152573218929538, 0.13795490713214653, 0.12565372505349792, 0.15804607408412608, 0.13668383686263808, 0.11066642406898752, 0.15002260020036773, 9.999999999998899e-05, 9.999999999998899e-05, 0.008668219807610122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06260915353757679, 0.020953414060365882, 0.05061154736702189, 0.04355216804884221, 0.09300231176788654, 0.05466194567894578, 0.13458526153399342, 0.12679253112430156, 0.06166069672986252, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053669752166436435, 0.043913249390111875, 0.023159196398288118, 0.06522461067686036, 0.06498492464352801, 0.02208834370637247, 0.056929456829065916, 0.03280213924308539, 0.053403250728044305, 0.3685739461500157, 0.3661214131159617, 0.3438637889704914, 0.3142789238023084, 0.2016199708080113, 0.3276434200543652, 0.34229040728212334, 0.34285588323996796, 0.35302019522047234, 0.06632276718827546, 0.07435060906483304, 0.06044960123778531, 0.05182492564022645, 0.05476717438173362, 0.08396257609266045, 0.053290033044254725, 0.10254796777223452, 0.06440685432595272, 0.1657418347299937, 0.13046452774275952, 0.1759837238884624, 0.17085859446082108, 0.15968773412058268, 0.16109236441630215, 0.1236438155192271, 0.13542890467301882, 0.18522830706346016, 0.25896302089388523, 0.2213247277001683, 0.25358895176760043, 0.18049146585507025, 0.2060201464463458, 0.24782461377047138, 0.20520866537937954, 0.2168198286690921, 0.24260983098527178, 0.18352464344922415, 0.19747051436005314, 0.18671918256148712, 0.1448395919269706, 0.187082839996642, 0.1843577541603053, 0.14566067020948026, 0.16588391606770492, 0.14971004092824947, 0.1673347426496521, 0.1836062683920865, 0.1795516422431923, 0.1840120852170649, 0.17570037475935618, 0.18818406351707906, 0.19290137579737288, 0.17399011635247574, 0.1643622920503054, 0.1748414958739326, 0.18622481437264515, 0.17386636104875508, 0.16580722943065962, 0.19032205312534, 0.17283618876606832, 0.17800564497661253, 0.1820210956408147, 0.18629557911613082, 0.1806978934129776, 0.18490812290224357, 0.18543295817564853, 0.1685974202360514, 0.19637779436296332, 0.5886546133950586, 0.12063079671730592, 0.16825197694481886, 0.4319697126879609, 0.34045831729864584, 0.19489231126203221, 0.5541099048132507, 0.17747820520617774, 0.16549321897848934, 0.1441812175954521, 0.10220954549002659, 0.33726984395012327, 0.38349296649168196, 0.18412279517897456, 0.18892005892365238, 0.1931769515062297, 0.17332608064571087, 0.17827854579997204, 0.19317670672562082, 0.18689399207097013, 0.19309435029019206, 0.1702755373019783, 0.06441820058547842, 0.07689371488386931, 0.05818495941510593, 0.05553094778858836, 0.06549366799139134, 0.07031583628879579, 0.06593490264207669, 0.08117501836972241, 0.08003431672926542]}, "mutation_prompt": null}
{"id": "8f622f38-b517-4957-b241-50e98de93550", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "4a7ec236-3c69-4098-8a6b-b4620f9cb9d3", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "b62851d5-f5d7-4bf7-b41a-0a2f71033ec7", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.4 + 0.3 * np.sin(3 * np.pi * evaluations / self.budget)  # Adaptive inertia weight\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Incorporate a differential crossover strategy and adaptive inertia weight scaling for enhanced position updates.", "configspace": "", "generation": 79, "fitness": 0.3651311298110606, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8966379088025429, 0.9051308584141404, 0.9102847548925351, 0.8602406933736657, 0.9133083071015229, 0.8828011159220033, 0.8897157076454768, 0.8602003185849041, 0.8925250131681841, 0.658678156442303, 0.7480466122838445, 0.6884177088300935, 0.7506813652987729, 0.7024212826399523, 0.6701922490968417, 0.6480800211531925, 0.6662880209275432, 0.7118692479350744, 0.07377691581129364, 0.10992354047931585, 0.06558822974017298, 0.11160674291515937, 0.10090311440485389, 0.14208191189354524, 0.112374789581965, 0.13015403923582747, 0.09284737176054336, 0.09205921311637011, 0.10578541272609565, 0.08506345388277425, 0.10027740532132279, 0.12267634889523049, 0.054491349607859174, 0.12651262731887436, 0.09584168160042683, 0.04885509912202235, 0.9335454445030265, 0.930885963683309, 0.9217642362643385, 0.8976600094008156, 0.9276310401822859, 0.9137560481228855, 0.9344486229700476, 0.9451382645325166, 0.8977588830476524, 0.7423787408686067, 0.7244604544842861, 0.674776969210532, 0.6483478607904141, 0.6639166952939841, 0.5069948120084729, 0.5315753564243249, 0.6829008744099669, 0.6582738983015831, 0.2295835567393817, 0.11296449640570005, 0.1691114178626001, 0.36277523767578534, 0.28094395096127545, 0.37945252671408813, 0.15092525877950647, 0.1776448146399625, 0.17731303767656792, 0.13481941093869731, 0.13593250087358721, 0.5531980855888926, 0.5828479345483579, 0.5400686444181341, 0.5360755949028322, 0.623580892748302, 0.13557449371287078, 0.527013051628358, 0.13519466735710772, 0.5086402940849575, 0.6387084805645158, 0.5906716500581854, 0.527876277159695, 0.6190875387187792, 0.5704641463815768, 0.1335403041306339, 0.543341731163118, 0.06839868984873898, 0.09980910984432412, 0.2280050096323777, 0.14204485620729101, 0.21205460554153321, 0.07170201163280521, 0.04180833570773612, 0.0982394938265383, 0.09803043879230955, 0.15094849095693696, 0.3072353569993621, 0.2748322527511238, 0.1841904513110686, 0.16606400322993564, 0.2118824356756609, 0.33744027793258413, 0.23182350892591108, 0.11305210898227325, 0.18491615938090533, 0.3357713626419654, 0.17024394158700884, 0.14870576644689715, 0.1564001513458232, 0.09587850403634457, 0.23426405380746895, 0.0990276712924324, 0.07247640679791623, 0.24057375868590214, 0.21686356687766417, 0.24377240367303954, 0.2871556642666614, 0.28260371329026823, 0.3131366536254534, 0.2240739048742304, 0.13907272433774232, 0.270930302727165, 0.6892285711590052, 0.7240282027965105, 0.8175891616813626, 0.6817520961109714, 0.6151461407993908, 0.7239679792007937, 0.7166309233885864, 0.7240540806893512, 0.6606164343788252, 0.05358472638900569, 0.014947381867475462, 0.08316418816488491, 0.09278362811096574, 0.08098763747071502, 0.07726843620841095, 0.11067252486295875, 0.09164367091282488, 0.09508249748393394, 0.5658687234026007, 0.45445084731592444, 0.38534285196919404, 0.22628854315064983, 0.4190942681039074, 0.27099921785965386, 0.4162447469559091, 0.6057390521636645, 0.40010556579001655, 0.2422640150364741, 0.3066103791549454, 0.17169778532578495, 0.4718013406628695, 0.2691403462086692, 0.2939176213988113, 0.18150770601178168, 0.29181237982674346, 0.11580775759656259, 0.12127960272859561, 0.2968835429092831, 0.16947646397085558, 0.20358091024030178, 0.2909588897162283, 0.21891424823963734, 0.23413512501772027, 0.21075251530611117, 0.09305414098025999, 0.20978738723440804, 0.1931987045740109, 0.21228919530509727, 0.29197356683654074, 0.22077267880336193, 0.23082401468840896, 0.24727950666341136, 0.2200069813060066, 0.24764255100756816, 0.1848046311590822, 0.2554949421922814, 0.19390477647544335, 0.21206774708802045, 0.2268796336399218, 0.19833870465251024, 0.18120391344075149, 0.18079317574541276, 0.18983315590278638, 0.9429016167896775, 0.925210475314101, 0.15281279921555613, 0.9194818418358237, 0.19989811259946044, 0.9338486488277122, 0.9412237580037351, 0.9125852478201412, 0.16827325133302984, 0.9015182372496131, 0.2132435401849112, 0.9326294648241092, 0.21028198901145068, 0.16789240427427032, 0.8803124199033809, 0.8734157266335837, 0.1668227507110378, 0.10437770151199688, 0.19917834766305764, 0.17587833335268677, 0.17469464475831897, 0.17795742149868932, 0.19601419656559327, 0.18602918385347034, 0.17741438575673563, 0.18352811820666115, 0.17329773084971511, 0.07882260046593781, 0.12208128900833803, 0.0798346172507618, 0.07938513211387022, 0.09606781329534875, 0.10305663524621944, 0.0873066354568327, 0.09041797896129355, 0.06932594505564282]}, "mutation_prompt": null}
{"id": "9f4e3935-5fba-4770-8894-6293d10b8174", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            # Adapt cognitive and social coefficients based on improvement\n            self.cognitive_coeff = 1.5 + 0.5 * (global_best_score / np.min(self.personal_best_scores))\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce adaptive cognitive and social coefficients based on the current best scores to enhance fine-tuning.", "configspace": "", "generation": 80, "fitness": 0.3832251741890726, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8803262623625435, 0.8826379086999894, 0.8680021748875083, 0.8534248705464766, 0.8658342195896075, 0.8713514723695599, 0.8605734492334928, 0.8683512965063906, 0.8522570209673637, 0.627148441289083, 0.7008132368695503, 0.7069400933154334, 0.6822274089826367, 0.7019757599200936, 0.619099639696985, 0.585888648828088, 0.606729016671447, 0.666653235699276, 0.08609655437640773, 0.10185899560378908, 0.0904932100106236, 0.1084185943048317, 0.11257931197860249, 0.1515247638878584, 0.09126149686958362, 0.13026960847835067, 0.11572649893310905, 0.09249662781544998, 0.10016360740908492, 0.10762179681461226, 0.11290230993555084, 0.12011900718116941, 0.06926864879304906, 0.10058602185638721, 0.08612384767315562, 0.09825754205700055, 0.9251472754492567, 0.9323685386959886, 0.9138798081907935, 0.8940378679979258, 0.9353510803725039, 0.9064589199111749, 0.9528724498414, 0.9459002172106452, 0.9251480345482066, 0.4950325861850874, 0.5647601035838439, 0.65996086416792, 0.4889954065712494, 0.48047989154596504, 0.15123281691939994, 0.5986556471326592, 0.5495568783829416, 0.6239128897201798, 0.908743410497701, 0.16972678723166557, 0.22308427706167466, 0.939959531313712, 0.2199662076113862, 0.9155350677837472, 0.8594626014850333, 0.15675275062107352, 0.17721991078911392, 0.1355659185708653, 0.13599066791838343, 0.5579478729139922, 0.6148838228875091, 0.4926288683520387, 0.13347673506028646, 0.7105621166597618, 0.1352680671531753, 0.5778055482336828, 0.5596549973735719, 0.6210409020264447, 0.7049941175330636, 0.5733132604404174, 0.6093173589271454, 0.6009118631954479, 0.46953522558882455, 0.6479637528019982, 0.48831607028652, 9.999999999998899e-05, 0.10233321849128785, 0.29528955444683447, 0.13426155698804143, 0.16070931241336184, 9.999999999998899e-05, 0.11363530042156345, 0.24202147785157369, 0.22274998376440358, 0.31386529555702714, 0.1974191834046245, 0.36391233842446113, 0.09371843164764648, 0.09894551754396541, 0.03637740648435661, 0.5505485596091728, 0.4775862265706826, 0.2325688837742952, 0.13761192103556474, 0.19991839067419592, 0.1304768965615687, 0.16369917461897343, 0.15953344468290542, 0.20576143658859247, 0.26754208479526564, 0.10959150746574209, 0.07880181803394792, 0.2108500750381076, 0.30015981279408044, 0.22595708197691933, 0.29562083372277725, 0.23969527991593964, 0.37952088945859175, 0.3055797105739182, 0.34224678279723597, 0.14754359611257828, 0.7590532512275634, 0.704115156536425, 0.6700157144814773, 0.7405311140149232, 0.7742523364981688, 0.7669512826185428, 0.6847243996091186, 0.7386990377316724, 0.8151736984577931, 0.05897149211494557, 0.07152050746422267, 0.07976962260511389, 0.10329884371154907, 0.089596950925523, 0.10171880755597373, 0.14249986918506696, 0.1113900152626578, 0.0928170016168478, 0.17027410828524647, 0.37868251132129715, 0.38369366345860256, 0.3726870148961917, 0.3598051162310377, 0.5098375427904223, 0.27956392230694005, 0.6089517605373532, 0.47465764589352766, 0.22013630345045265, 0.41926373395905225, 0.2502833152448226, 0.4931112367436109, 0.27554420260336365, 0.4380269116684541, 0.24238371854600593, 0.4547031654465872, 0.1115347039518032, 0.11893365001244471, 0.3015831480785701, 0.21439725248759256, 0.2470579498316685, 0.22993202321797568, 0.25560323421529874, 0.1448956840071398, 0.21029900721921524, 0.09657313933923783, 0.21447370030232304, 0.240826059788403, 0.20137850478775865, 0.24389401539475652, 0.2337955465299899, 0.21916939943863611, 0.22319025680883564, 0.22942786860431308, 0.2147843010302064, 0.20089447308754693, 0.24832485145087024, 0.19509505375299163, 0.19958309022262422, 0.2501708787205241, 0.1856275008375291, 0.17006289747848136, 0.23899892695197156, 0.17966891946303587, 0.9323951387390966, 0.9125294321434476, 0.1531584802167012, 0.9369233150817148, 0.2001349273565297, 0.9306729621119847, 0.9166791598068289, 0.917278229998864, 0.16849929749611214, 0.8792454061357874, 0.21274993976079615, 0.9150186373546458, 0.21060424876185957, 0.16810452988458924, 0.9087368609180219, 0.8900050710676526, 0.8569720347533503, 0.10486933118244657, 0.1797378112556577, 0.2009952753430846, 0.18308403528737227, 0.1964636782751863, 0.1768770894789572, 0.17475644935843226, 0.19231653925809755, 0.19245590449503902, 0.1708342045516833, 0.08644600666767333, 0.09995152151256681, 0.0902470951688612, 0.08816471824525374, 0.08822955288200518, 0.12729953465063115, 0.08798583068366939, 0.09685802755645889, 0.07684176398659892]}, "mutation_prompt": null}
{"id": "fe3d3332-049f-4853-aaa0-790452b8510b", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                # Change 1: Adaptive cognitive coefficient\n                self.cognitive_coeff = 1.5 + 0.5 * (evaluations / self.budget)\n\n                if score < self.personal_best_scores[i]:\n                    if np.random.rand() < 0.5 + 0.5 * (1 - evaluations / self.budget):  # Change 2: Adaptive update frequency\n                        self.personal_best_scores[i] = score\n                        self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce adaptive cognitive coefficients and enhance exploration by adjusting personal best update frequency based on budget progress.", "configspace": "", "generation": 81, "fitness": 0.37956440524971746, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8933154434647921, 0.9080206937142541, 0.8596760066596701, 0.8588402901000718, 0.868138937298449, 0.8388958067438552, 0.8902079867669996, 0.8849235977228942, 0.8556637525454128, 0.746341521106044, 0.7297542410789435, 0.6740198305918828, 0.6926222462363837, 0.7094009836944237, 0.6304344431924096, 0.6285851582561534, 0.6625118274077867, 0.6661933917393779, 0.0969100732308712, 0.14459085083489787, 0.12549948482205486, 0.10978234330041581, 0.09282225022705082, 0.11700651443414323, 0.1337231989186164, 0.1032088253985265, 0.09242922214947735, 0.06545635493065494, 0.1101691718432134, 0.08875874363327008, 0.14885180001732057, 0.09843170323801298, 0.07936530229131245, 0.11405807906571774, 0.09642246626602813, 0.11889747789686611, 0.9029675823788564, 0.9176010615181384, 0.9264943628874475, 0.9103067778112146, 0.8893543168837095, 0.9248647808494912, 0.9345222704532334, 0.9209511267246129, 0.9376913599334973, 0.7251551815431392, 0.5985801601954595, 0.6289401789235476, 0.6728229151137702, 0.5520636001644389, 0.5956072751328725, 0.6492274861010838, 0.6640269552911866, 0.6214925090378052, 0.1629797038212646, 0.2171325122487291, 0.9041537727990008, 0.27779499598914514, 0.1721532600415021, 0.8228082907037206, 0.17625794035608378, 0.22343633210487002, 0.8556194849585895, 0.6771368437687365, 0.6997783837877152, 0.41363603473737554, 0.1319823401470801, 0.12815743374582544, 0.33564536668031186, 0.6810966505880605, 0.6198407122724383, 0.6093080847432797, 0.5133920307564933, 0.4967203946126104, 0.1346342210244862, 0.13536461209003303, 0.1357431878195262, 0.5616107978401887, 0.5600494996624061, 0.4161006216820623, 0.497850069252203, 0.15277744842235186, 0.12523042895714132, 0.19342438127846284, 0.18296204975952524, 0.15235496699840712, 0.03664591769569947, 0.08501771587124474, 0.16057874045878473, 0.3087299730303402, 0.243519231911837, 0.13731817218320796, 0.16763747251188144, 0.20999870470357007, 0.25173235803059646, 0.06141637564690261, 0.3648210442871299, 0.32060482287602377, 0.15740185800130024, 0.08167009181574214, 0.28396585899973825, 0.20006066835632386, 0.1197480974541073, 0.10875486661237233, 0.1621255348581464, 0.25388726564635744, 0.25634410790871853, 0.0721749037415691, 0.4074519165242073, 0.2776864362917284, 0.23900942837357153, 0.346558181703146, 0.4828715904428039, 0.265378930446754, 0.20552367895355506, 0.24616013159086492, 0.08243589505250981, 0.7233968699061628, 0.8380016249083249, 0.6657213682601959, 0.758960102813731, 0.6365932030019302, 0.7085943688820917, 0.8163649789330525, 0.6574863010370173, 0.7278108280519124, 0.09862700494714993, 0.11367734755259695, 0.09106433408048287, 0.11680866192390404, 0.1195047972698089, 0.11590352308994734, 0.1054719125362773, 0.10702275404958583, 0.10472415780317845, 0.2381582294854787, 0.5364010808092787, 0.45359097341823285, 0.2888227688294761, 0.1616903798705014, 0.2194871626117153, 0.6224578888352748, 0.22340163213974573, 0.6167039510991321, 0.24744304817097507, 0.28307822714580166, 0.22608928428080632, 0.19896256404326707, 0.248371448736461, 0.4718704567062212, 0.19160801237356395, 0.546600906899362, 0.29726105328931474, 0.2292425905854688, 0.4078587130135879, 0.1968546250943325, 0.3409247237883991, 0.2592148561773905, 0.361496822985921, 0.2188690870008536, 0.28254699460514443, 0.09690349766275974, 0.2229322495320044, 0.23025496949319746, 0.2154066497097611, 0.20808067619807513, 0.21103330923989194, 0.2214842443518552, 0.2341077037914453, 0.22120096015850466, 0.21558376886959307, 0.1789451225268618, 0.1811158500432971, 0.1796847283719264, 0.20999362899122553, 0.18992547522634662, 0.19185014870529926, 0.19212622446911432, 0.18566106283248685, 0.19457871834094442, 0.937357181603916, 0.1878788700847004, 0.1533083056394864, 0.9301402393150309, 0.20031490235325577, 0.9464893874802329, 0.9126612159793133, 0.16878808129852074, 0.1670438775613342, 0.9356625195657131, 0.21079795882894214, 0.9306002865751168, 0.21054731643355074, 0.8455519038386803, 0.8861031048700698, 0.7475766621346565, 0.8807742283683033, 0.7702996305970207, 0.17470050479151522, 0.20215477275407379, 0.21525880971289346, 0.1714095500743995, 0.182948729178661, 0.16786135569387295, 0.16759182958722452, 0.18926117097242723, 0.177570687171146, 0.09673027670337286, 0.07883331130920745, 0.08159028441989447, 0.08881741939347809, 0.09429391718191704, 0.08325028560284808, 0.09154689552486106, 0.08528182583136446, 0.08834087855820161]}, "mutation_prompt": null}
{"id": "4aafbfd3-33b1-4086-b560-29217e00f5e2", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(4 * np.pi * evaluations / self.budget)  # Chaotic inertia weight\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector += np.random.normal(0, 0.1, size=self.dim)  # Gaussian mutation\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a chaotic inertia weight and a Gaussian mutation for enhanced exploration and convergence.", "configspace": "", "generation": 82, "fitness": 0.3259866534991687, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8340746636632379, 0.8393505505174945, 0.8593674774800382, 0.8325712799106781, 0.8624131251843378, 0.8460656349259671, 0.8388643366860324, 0.8197261178582179, 0.8311911716201702, 0.6918111523710114, 0.5628400310225485, 0.6132503610734186, 0.512156317033251, 0.5023574295456356, 0.47708509220206163, 0.5523733951730934, 0.47222970929663866, 0.31419175058674553, 0.08065628102086142, 0.14871096140668016, 0.08079184567945852, 0.10666028419680629, 0.12384137699593156, 0.11942394706227422, 0.1412474764055438, 0.11024111746223408, 0.09147746458757466, 0.06950945276021792, 0.10418308344694938, 0.03388382898697817, 0.13332773729097902, 0.10595086599935255, 0.08052279078023561, 0.060258463004535634, 0.08082604781955138, 0.08000569817570757, 0.9136538524734555, 0.9149171156935992, 0.9110953138965873, 0.8885657020150137, 0.900708233694766, 0.9199126999968564, 0.9215544041362725, 0.9007400729274632, 0.9241735720200609, 0.68978909297948, 0.5002681440017669, 0.6012930015253073, 0.5442873433682133, 0.5226891826607537, 0.5848355402799645, 0.6490823912384291, 0.45834194439341447, 0.4896274638055442, 0.8670929147422355, 0.17129353306728934, 0.22142425533118548, 0.38227919326073223, 0.27922375459650683, 0.21515271397426616, 0.13114556256157595, 0.22182198134189535, 0.15600931299495624, 0.28799006321613474, 0.13469489269583212, 0.4538443235207752, 0.2836176522586076, 0.3144545770878584, 0.1703088042758416, 0.628920428944842, 0.13263473219442545, 0.4142038689209645, 0.2685494852313385, 0.12518019885128706, 0.7159580493409663, 0.25066774840937545, 0.3103725623795439, 0.3119760197799153, 0.30452016251678893, 0.1315081609011226, 0.3245418606798769, 0.048622530712856826, 0.10502632387198396, 0.133735176265096, 0.08536655114863789, 0.09791731250039415, 0.16212377928163857, 0.0853603224783186, 0.08603370603673743, 0.10111819709053749, 0.4827803202837144, 0.17996383010471417, 0.32563381576469685, 0.12179394360505102, 0.2442944871612811, 0.1454722072411443, 0.31336237653272225, 0.2575879971076215, 0.16399274870786507, 0.10812625129577358, 0.1384086289442692, 0.19739300046287034, 0.1024130161235467, 0.07691457630674281, 0.1699653241344793, 0.0956588543598742, 0.0881735834090901, 0.07344224119762799, 0.19133902299546468, 0.24696382222750735, 0.1204844667509688, 0.21841380299688773, 0.17687687286212717, 0.32278070342741283, 0.18889806182468238, 0.16456029848016496, 0.08325114215612661, 0.6866346651486415, 0.7459178709590053, 0.6068457573760669, 0.5851278787679176, 0.5454072990660199, 0.6137269482958232, 0.7363206323179873, 0.7008670119290379, 0.6558840716047414, 0.07735158155717414, 0.04474134408311625, 0.0877065233713431, 0.10828627720801609, 0.09722635523463419, 0.15058480495595772, 0.10845454068129112, 0.10863333109061601, 0.3706635729205767, 0.4393332462217655, 0.22302278197139647, 0.48594859789434486, 0.44751184712627023, 0.144258990031625, 0.41310132455630033, 0.2667718481936169, 0.19686427261881212, 0.3531646481601389, 0.32138064340049777, 0.3505043329306402, 0.2023246022267866, 0.3594595760161625, 0.4088188107344898, 0.2882146487981506, 0.23068593499456347, 0.3093615980685418, 0.4877076274736657, 0.3486846818453285, 0.2604793380342044, 0.2018376049612678, 0.2563522006215305, 0.2777077368760006, 0.357287827374005, 0.1979698672490775, 0.32042554953656155, 0.10043527943732133, 0.2036620970145835, 0.20965587678186126, 0.2271145758528551, 0.25043559975243657, 0.23525816744578776, 0.21901897383631963, 0.22552729633641544, 0.2305286634188609, 0.24989534070588282, 0.2006778041941767, 0.18873774718163394, 0.2463393175795905, 0.19945334315330443, 0.18538412023428086, 0.19009050939381222, 0.1976545469960721, 0.19893061190476358, 0.21456271076743894, 0.9020049844076448, 0.18741054033453652, 0.15263993447359703, 0.927740337364541, 0.20012241497520322, 0.9038566363616276, 0.12203452949512028, 0.16901191985882802, 0.16688019827336154, 0.8242294276078639, 0.20993680829771544, 0.891406087750084, 0.21108513435305865, 0.16872596051948963, 0.21076745172680444, 0.16753740090375302, 0.1681297225146342, 0.7965571811606906, 0.18223217044921403, 0.19176923662957912, 0.17961115440924935, 0.19850335109930872, 0.17787564417366286, 0.1773335780870008, 0.1838565123715834, 0.17951284918120514, 0.19193159289350825, 0.08406408561639034, 0.09874283768561887, 0.09108610605052203, 0.09557430414656298, 0.0909407332751303, 0.1287396341604612, 0.0866708660873714, 0.10216419600584381, 0.07689894738240333]}, "mutation_prompt": null}
{"id": "299e9083-072f-4b57-b559-507b8ce722e4", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "1f3967d8-e0db-440e-bb59-3cb34b52995e", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    # Modification: Use the best position within neighbors for trial vector\n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, self.personal_best_positions[a], self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a local exploration strategy by using the best position within a group of neighbors to better balance exploration and exploitation.", "configspace": "", "generation": 84, "fitness": 0.37245605932986026, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8880010738428752, 0.8710426229969092, 0.9028415560934497, 0.8516838089959479, 0.8763159158126944, 0.8982668858863823, 0.8872597740494833, 0.9072189040787884, 0.8832089997252789, 0.758883968348486, 0.7181368303890687, 0.6920969523928605, 0.78236919096682, 0.7001710585680545, 0.6909135927867733, 0.6917293223005776, 0.7237287852856531, 0.6794678724969065, 0.10991696906263548, 0.15659023622975743, 0.08006996549323664, 0.11742633458017859, 0.2557681534603353, 0.1463555828485925, 0.1543703781140746, 0.11611686671725363, 0.11325858225559116, 0.07960464588933103, 0.11250241410203565, 0.0713641766711769, 0.11735832242935007, 0.10873247187181545, 0.10509063619981585, 0.11521205962405279, 0.10532162885069685, 0.10263297790242121, 0.8955774925556208, 0.9138382961479015, 0.8880206509720495, 0.907492644223236, 0.8814397371471828, 0.9178508447346652, 0.9117215659808843, 0.9043822533423631, 0.8930994586956573, 0.6615113327323617, 0.6456416994351513, 0.6800754781901968, 0.7265521684014243, 0.6425523906209617, 0.7224638997391639, 0.7014983558954815, 0.7078726167909448, 0.6299142252300609, 0.23038300181679905, 0.1401632916267932, 0.22213768005556378, 0.27979459891630976, 0.2123236368643745, 0.14882411117320993, 0.15311715032581674, 0.17762634947647526, 0.19287695042074504, 0.6394302372247704, 0.7255755448406944, 0.6235748204427639, 0.6789345252373524, 0.6749922622733067, 0.43244268164591015, 0.5803241142331047, 0.13630089632289177, 0.7442689736427062, 0.1994338620842253, 0.5358473553144547, 0.13481514942651118, 0.6562698752262475, 0.5955818818526472, 0.6291500742998655, 0.5418997841578603, 0.4172992039974983, 0.647919918835175, 0.04088616034539372, 0.05316760913169094, 0.2750004165641885, 0.17315196457672377, 0.17598834346503445, 0.1735179398216402, 0.16871450356860895, 0.30090431564292697, 0.2140018937380701, 0.24935956463347797, 0.12148352166807841, 0.3062342919679927, 0.17191673464166002, 0.20383863400267133, 0.0969254154840744, 0.2520999401934447, 0.2372863240978621, 0.27461850386422093, 0.12682352330154412, 0.12575825410784747, 0.30624637858085224, 0.09255178160611377, 0.10718900493434047, 0.33846989842166764, 0.17000789022058505, 0.20447963828034343, 0.08186436197545877, 0.04109636784820536, 0.20450033395581657, 0.3321697812669938, 0.30150121291987, 0.3033052521920212, 0.28700954020969216, 0.32881082357681, 0.33647416307114253, 0.1930622741477811, 0.8024152086340588, 0.7171921595979576, 0.6885878517586129, 0.7107614214295476, 0.7163873523239059, 0.7247298833037913, 0.7491473684556201, 0.6524531878365201, 0.740031210550391, 0.10163217702847072, 0.067164752534836, 0.06295394044805014, 0.08020991589648585, 0.09694118724718448, 0.15946652503359748, 0.10503703011868415, 0.10561029591025306, 0.09585941524987829, 0.4037533045498174, 0.3375657570168372, 0.6379034160788783, 0.3092379879694357, 0.3267652127546006, 0.2372902230025935, 0.34656997473853357, 0.20050271962103738, 0.2708198159714468, 0.24775745890688372, 0.19403360419705873, 0.15928192509618844, 0.21516851621044375, 0.29372731383494877, 0.5409249334756917, 0.16925474731846002, 0.48598138031206073, 0.1577686072792217, 0.1923774439418151, 0.3404149126630339, 0.13174432506848333, 0.15998947857232293, 0.2956453643361152, 0.25999177904236803, 0.14245487204560536, 0.19408334363587088, 0.0856813120610761, 0.2563782743271653, 0.25180663810363313, 0.2244919844103005, 0.2542659717922602, 0.2268560430826132, 0.21604876418576435, 0.23213513280688036, 0.2543344729112419, 0.19782736902299658, 0.18240481659922503, 0.2063512227484352, 0.19858359000546533, 0.19861423351406104, 0.20202436210932206, 0.18833794317166008, 0.2124330017557703, 0.2077035782040355, 0.1898477737841524, 0.9364365511651043, 0.9345716372925571, 0.18754025160826715, 0.1730645725452611, 0.20075934269464113, 0.9313989767503886, 0.9342748731080696, 0.9031947582847304, 0.1689534026494648, 0.9354249577163241, 0.21338736967537186, 0.9225266235575749, 0.21142015767706757, 0.16757723191548957, 0.8959727310618253, 0.10511194857110495, 0.16838382245527483, 0.8039886822621386, 0.18267681239943978, 0.178913197939646, 0.17856201751971368, 0.19483998526681057, 0.20008475421605765, 0.17032214260248257, 0.17475606455258008, 0.18223864462895667, 0.20243167872901746, 0.09961956710645103, 0.09405932062363209, 0.0869968339542132, 0.07279337753668846, 0.09169264048043746, 0.1365723764503386, 0.09352122629039805, 0.09859756395610597, 0.0798678164989507]}, "mutation_prompt": null}
{"id": "dea52a04-309c-4c51-8a4c-7e85e71776f8", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                distance_to_global_best = np.linalg.norm(self.positions[i] - global_best_position)\n                adaptive_weight = 0.1 + 0.1 * (1 - distance_to_global_best / 10.0)  # Changed\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])  # Changed\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce adaptive neighbor attraction weight based on the distance to the global best to enhance convergence.", "configspace": "", "generation": 85, "fitness": 0.36209881933666366, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9100824059529867, 0.8837881242262655, 0.8973091572536358, 0.8514352608834579, 0.8706324476968964, 0.898573956369005, 0.903454999378587, 0.8964005383031759, 0.8939695447129784, 0.7777115370108655, 0.6709702405349731, 0.6755113184077114, 0.7692410843335591, 0.681197997790695, 0.6245724979281428, 0.7378456002321081, 0.7874662143657268, 0.6909622318810776, 0.07833087495730873, 0.11636004350934093, 0.07956438791638609, 0.08884609519234132, 0.10828771891354705, 0.10675186059413244, 0.11617241727783001, 0.11567176432250548, 0.12052053250001393, 0.09456084337400028, 0.08190286324672613, 0.0693990150549797, 0.08579357094470452, 0.08660340952115697, 0.09256246627539966, 0.07587576580088096, 0.08462036535784823, 0.08880784728425728, 0.9266881634489236, 0.9204710647819279, 0.9302850363934775, 0.9260605237998205, 0.9254682400316578, 0.9298184700472959, 0.9322352531189122, 0.9280712753105345, 0.9215584126299298, 0.645811136274231, 0.7198632561540758, 0.688335206450357, 0.7485957885098479, 0.6994613502938414, 0.6825884388790275, 0.7107198278593109, 0.6610934174642813, 0.45245297598749223, 0.22977964204066847, 0.1831299336127834, 0.17046039873600127, 0.2839418114319656, 0.2753132912952224, 0.21643475964788061, 0.12930190448258583, 0.17688365283904117, 0.1911352783719773, 0.6404327060531059, 0.3963702312836803, 0.6389684145911798, 0.3908530560420149, 0.573932425950999, 0.6558155322620023, 0.5612609413384719, 0.1347142857972724, 0.6350103614134506, 0.4491160624623829, 0.5755000858694099, 0.1360030408766183, 0.7115564741609455, 0.617022294146828, 0.5159369791975199, 0.7184748722570534, 0.6421328936048247, 0.24029402186019977, 0.07098609143881018, 0.1314563351131106, 0.10854300333044753, 0.12770336145193828, 0.21666627455363885, 0.1927731904397204, 0.0996517351177767, 0.17610673784568076, 0.09088992298673271, 0.32234551801228906, 0.17524620660707746, 0.3204375720738176, 0.1427467134097229, 0.1142012901348789, 0.11821637106147409, 0.20473085281269288, 0.2492239086034076, 0.0991005389350803, 0.1272527852700308, 0.2600851668495914, 0.12421301865877432, 0.1114497618149608, 0.1397459259189171, 0.3151498190175067, 0.15692219537160057, 0.2840786011365908, 0.10476653052131624, 0.1239315231213377, 0.30444403592750235, 0.2512514275664728, 0.20161303789211593, 0.24193386456753074, 0.2544014545356821, 0.08967576288062484, 0.0818250891577329, 0.2874190965581671, 0.7207002311634108, 0.7356711077169806, 0.7031482489443115, 0.6636974036699805, 0.6856204407389705, 0.6787425539138103, 0.6524009825391045, 0.7991256891518943, 0.7046495992274744, 0.07209791310884561, 0.07169009731369369, 0.06251428640226986, 0.09630528639594582, 0.06543597614036134, 0.14927798952140658, 0.12432252329558047, 0.1276338194253327, 0.08295610299512668, 0.2421353653157865, 0.3884275229997439, 0.2785554738457333, 0.31040115887751385, 0.6092724536211302, 0.21550553173100162, 0.6676238591183197, 0.1569077174449669, 0.22992343012950367, 0.2584345082340065, 0.6444656549099714, 0.32322249312787776, 0.2878336392596381, 0.2656502680999938, 0.2832326122519375, 0.27327186932075154, 0.585411365279314, 0.18557103299397382, 0.15430295168109698, 0.23350435992092877, 0.21895086505481376, 0.1524617823527411, 0.3330234495125681, 0.18343059490078306, 0.19076350781081597, 0.20255765082199717, 0.11221444841024764, 0.25000063225309777, 0.23089834835760825, 0.20666768189633544, 0.2306676188584985, 0.21531416941221504, 0.2335074827963487, 0.23090276292197565, 0.2150684611600283, 0.21202754652490352, 0.2102729918236187, 0.1879602662307701, 0.17637644638937067, 0.1948917375478656, 0.20146654248627616, 0.175970293749088, 0.18549543321798412, 0.1901947452692757, 0.17089761156559857, 0.9396285901437971, 0.9333986830535873, 0.15306429617640915, 0.17286783153653107, 0.20065386994289824, 0.20071840123269113, 0.12162308600968241, 0.20959083985848892, 0.167168817330817, 0.9357688732246774, 0.21062087325830736, 0.834571980849533, 0.21032016537781406, 0.8560742850184596, 0.9066894999887175, 0.8973806742754609, 0.846941055364077, 0.1041228337014507, 0.1855230215674012, 0.1718843197593407, 0.1859106961857666, 0.18082376234954234, 0.18140013184819903, 0.17924359005033708, 0.1770045932123958, 0.2020110322809956, 0.16883546003360805, 0.08568424195066615, 0.08265467339112675, 0.0931550653859442, 0.08270860341952024, 0.08293140779237784, 0.13590498894179437, 0.08348113565473592, 0.08394685366526189, 0.0751152426734445]}, "mutation_prompt": null}
{"id": "fa3bed20-533e-48ba-b606-b8e8b29a0e4f", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                adaptive_lr = 0.5 + 0.5 * np.random.rand()  # Change 1: Introduce adaptive learning rate\n                self.velocities[i] = (adaptive_lr * self.inertia_weight * self.velocities[i] +  # Change 2: Apply adaptive learning rate\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Utilize adaptive learning rates for velocity updates to improve convergence on different landscapes.", "configspace": "", "generation": 86, "fitness": 0.3291082108917682, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9215732898634141, 0.9083548968944315, 0.9194467417972353, 0.8908647781159493, 0.8951814746359842, 0.8890764905287317, 0.9080835723824955, 0.9182050842448566, 0.9077864338963367, 0.7960322883179388, 0.7510085930353151, 0.6870726611880051, 0.7572502802882457, 0.792832554677811, 0.7857725041753113, 0.6853287252282145, 0.7567681029929473, 0.6872451158868074, 0.0676494887644914, 0.14691455850991897, 0.07961634102838366, 0.08424852870806354, 0.11717089773709244, 0.13469221542907706, 0.10881443394054968, 0.08200860004498134, 0.07795858840524283, 0.0776956123821636, 0.08075794032940264, 0.07897344216284219, 0.09775978956431786, 0.1113028212702677, 0.06512162944270061, 0.0968866691751098, 0.06004673183441067, 0.06919446964810505, 0.9202195852499274, 0.9357020125333714, 0.8928667104060989, 0.9296869092555216, 0.9128327240591458, 0.9322724526807475, 0.9142086129970897, 0.8905550348433036, 0.9115800939713474, 0.7449895264653872, 0.7879101675526418, 0.7361970856560752, 0.7149370344391488, 0.45092131400805047, 0.7661147260009198, 0.7729847321575026, 0.7626332066038828, 0.6873362243027399, 0.39838038240268625, 0.13124839675272182, 0.14139303195975206, 0.2219323212905856, 0.23667294941623485, 0.17639056905510098, 0.15648197323056723, 0.17903188784542456, 0.17837449120646565, 0.32615371111869507, 0.13337746795788075, 0.6126209997076206, 0.12962927206891783, 0.5587854570355852, 0.15019458271985697, 0.5727836127851206, 0.18627637803970887, 0.1550274476839093, 0.1908328692247886, 0.2577811205312187, 0.18882458855229567, 0.13656331077508332, 0.3413260096340468, 0.26765943185187446, 0.26910419964723764, 0.23252772941083366, 0.25638610153804064, 0.01772019807837677, 0.4601007543036899, 0.06215346514721498, 0.08841941086621519, 0.1660290109839756, 0.06815922294281718, 0.03559925308054368, 0.10848057345027096, 0.14126356304470533, 0.14858690622128545, 0.13312666952777275, 0.3909307278883537, 0.0791196663144429, 0.12758561786889844, 0.07538439320819146, 0.17598709795839462, 0.20501421129757202, 0.0508245782100335, 0.17347936808893683, 0.12871545418257813, 0.27781640137552266, 0.16582093439829004, 0.133207248415681, 0.13430388976955687, 0.16801386231308246, 0.2611801384789576, 0.11477554539613044, 0.2817097328449304, 0.2190133154327627, 0.09979563175669537, 0.10863561750477657, 0.1955503771452779, 0.16248835227070924, 0.15437269231103, 0.15816802310672484, 0.10673114341878387, 0.6040412437542224, 0.49786769558236843, 0.6350300162820416, 0.6059488292323139, 0.7073546806320514, 0.6087085219219734, 0.6127078059323494, 0.6222523040294821, 0.592355933943623, 0.10599310823458641, 0.09995177356842755, 0.056569614845177085, 0.12477862108962712, 0.06352569240613848, 0.14768127932394381, 0.07256860196774728, 0.10507423087881984, 0.09346379342245004, 0.4674219860033123, 0.5468035340765749, 0.7311468349584047, 0.25701074120119416, 0.387666921084184, 0.25586537983500934, 0.22817091025945246, 0.3548947034324651, 0.2125783903734868, 0.18579068292742307, 0.18420949569581557, 0.19551271159239592, 0.2252472000864011, 0.34208503231990406, 0.2715836830190982, 0.2500096760208106, 0.23597347904957777, 0.15433543227297364, 0.12567075216227963, 0.30833303445628535, 0.17724119638872704, 0.21778345790455322, 0.26549324225592175, 0.2338876877726459, 0.09865131219194567, 0.29769781568926956, 0.11065885802609554, 0.22066288383267396, 0.197084853488806, 0.22646534946128272, 0.2818188709251519, 0.2158332767968394, 0.22835393634109868, 0.24134878284313677, 0.21993303101183448, 0.2331211260597552, 0.19240964677375982, 0.18015471023480134, 0.18397997999214066, 0.18451232763332825, 0.18593710906515082, 0.18612417198882547, 0.17740652544840907, 0.2027430417057995, 0.16482378246475526, 0.9102059648209059, 0.17880020053103307, 0.18920247554022285, 0.9249958519478128, 0.20094313437716893, 0.1989724221711604, 0.0996512048141136, 0.1691931246778433, 0.1525777783074138, 0.9183591958860592, 0.21029828408507367, 0.05178053130405347, 0.2115273621776842, 0.16911964367161492, 0.8244642478863872, 0.6830373464960009, 0.8706142428461189, 0.780352996367527, 0.1784006200272903, 0.1766903446882463, 0.17053024757243307, 0.1802795509196118, 0.193056999236897, 0.17713088286216006, 0.16848646297377567, 0.17475630985726798, 0.18088319631177652, 0.08703013610569155, 0.09737682577393547, 0.07914551738642206, 0.07510503605404195, 0.09323566936666017, 0.11288273600813192, 0.1065694434553659, 0.07991874441486757, 0.08881967577258387]}, "mutation_prompt": null}
{"id": "4a13b9da-d797-4e32-a40e-d9619d65c2d8", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "5eaf7e7b-3e84-4eb9-9e66-2f38cba85e1f", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "de92e08b-5abf-46be-a7ae-cd36c7b229b6", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    diversity_factor = np.random.rand(self.dim)  # Added diversity preservation\n                    mutant_vector = self.positions[a] + diversity_factor * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance the mutation strategy by including a diversity preservation mechanism, encouraging more varied trial vector generation.", "configspace": "", "generation": 89, "fitness": 0.375487972147603, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8975356890810265, 0.8909151499592218, 0.9001852073595783, 0.8494256886584619, 0.8607862054871047, 0.884899475458202, 0.8857046109921678, 0.879191472161668, 0.8664068892090063, 0.7155912320824058, 0.746243102891488, 0.6844422235311576, 0.6958842125277467, 0.6952545125648316, 0.6851474533018325, 0.6343783510986747, 0.6836005715130973, 0.6972500241644958, 0.08766945622365707, 0.08560948959354897, 0.10737025036456338, 0.10493292014491196, 0.11186341085516704, 0.14432256021372303, 0.13195217846868268, 0.11970520663921103, 0.1832866053077984, 0.09148400682099977, 0.12241664758811566, 0.0614849976849311, 0.10249092569742757, 0.08501757754259687, 0.10397411752886032, 0.10566555586420634, 0.11217317206963995, 0.08601292905329883, 0.9355860059199412, 0.9166212347267364, 0.9359834078396116, 0.9496683900550134, 0.9399150555132157, 0.9276094018043679, 0.9387080913589815, 0.9323333028787708, 0.9079057658336235, 0.6574426644870708, 0.6526912542731775, 0.7390682283266372, 0.6089014161909576, 0.6001157681470768, 0.6879433826867125, 0.6719357801988023, 0.6510599601901348, 0.6874645366486682, 0.9084869457502545, 0.1371544759344442, 0.17074292928909895, 0.2794240071565227, 0.5478210770189216, 0.21215970949131802, 0.22831328826874853, 0.15308131165110717, 0.6523898718466983, 0.4561972000912278, 0.13495517794079392, 0.58641248762735, 0.39775529114613095, 0.3736576787351349, 0.6301006320163489, 0.6347600998883645, 0.13427488392839781, 0.4449950074904957, 0.5452336096731834, 0.4177018852922678, 0.1348073010244858, 0.1349899092430158, 0.4495694241408178, 0.4891699546066468, 0.7643806086233861, 0.6576335930507813, 0.5890700910656239, 0.08340923519563581, 0.13262410068845676, 0.06259210651138658, 0.27513607395205986, 0.1843720648804409, 0.04933541444678535, 0.1084260159211472, 0.09535881995557305, 0.08401980373792872, 0.4086353214933245, 0.1831196483304357, 0.5739043230824512, 0.12258711527053112, 0.09144577665460218, 0.15077092695357697, 0.25216100758443905, 0.21696003162162347, 0.19423330480835366, 0.18348647364332782, 0.16395494720702786, 0.1828172311319196, 0.11979753112368818, 0.26740935753190065, 0.15125053695606638, 0.18221777808824124, 0.23718202887571105, 0.09289589896753292, 0.25540504630538774, 0.3992876497462876, 0.13862707428372578, 0.2722049512661483, 0.25066285485968165, 0.3415187326515423, 0.3740317266416934, 0.32168365897691686, 0.08356413602146984, 0.598523642534486, 0.761430594242813, 0.7945638390628227, 0.7867127544346292, 0.6832931131019115, 0.6504590010923048, 0.6476652212867866, 0.6493825033747953, 0.6632730593056589, 0.04716457990592804, 0.06756391573334186, 0.10856643810804822, 0.09271942152484858, 0.06609019720690323, 0.11918701027046008, 0.1407595933885295, 0.12942387894287444, 0.0857138916199357, 0.3510169101401148, 0.4189888497816604, 0.37301732033044377, 0.29073619298023345, 0.4920621869597104, 0.5794999199832567, 0.2509397416384799, 0.25316914367200827, 0.4157787364901955, 0.27349766486635385, 0.5900716932672844, 0.1731978090402836, 0.1764252106147436, 0.423856356041289, 0.57282872545132, 0.5098990874287331, 0.23721811867984777, 0.17228398662627964, 0.23940047065898007, 0.2714807157486826, 0.1864285966359881, 0.1776103878195361, 0.23667233770058138, 0.24841857141884605, 0.113537225261377, 0.2763299216222209, 0.2510706188281049, 0.21580860575051486, 0.22552436597986303, 0.22441451566158288, 0.20874739446576707, 0.2514196973936994, 0.21942927995906314, 0.2143383815886143, 0.2067431732608742, 0.2268891234856193, 0.16453853218164272, 0.22605373540603657, 0.18681382004615277, 0.18934352879324623, 0.18812698612473677, 0.20389635568226083, 0.19797768428572748, 0.182117213088117, 0.18459690171901255, 0.18788014652969265, 0.188296893863787, 0.15271356379594692, 0.9204949597281622, 0.20045808944030563, 0.8978245408463306, 0.1221570732123557, 0.9138916437294988, 0.16828722206053737, 0.9431983757303625, 0.21252064451086894, 0.8746707891077677, 0.8508772147414467, 0.21122852964540606, 0.8257204155132281, 0.8933317958601025, 0.8554163085220665, 0.8547844036168635, 0.18934049026142952, 0.1840945829807391, 0.20950093334863107, 0.20249978244594358, 0.1820387281950281, 0.1881197304903448, 0.1767476016037346, 0.17638779431027507, 0.19258944959505164, 0.09509356666534319, 0.06933668560790918, 0.08083582187642002, 0.07897460413558333, 0.08615199247160454, 0.09499736103556211, 0.07892254545183364, 0.1035767046727668, 0.0841776644415626]}, "mutation_prompt": null}
{"id": "9cb5b779-bb0a-411a-b826-c7c6f5e6c6f8", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n                # New line for historical best influence\n                if np.random.rand() < 0.2:  # 20% chance to influence by history\n                    self.positions[i] += 0.05 * (global_best_position - self.positions[i])\n\n        return global_best_position", "name": "HybridPSO_ADM", "description": "Enhance particle diversity by integrating historical best position influence over time.", "configspace": "", "generation": 90, "fitness": 0.3734062367088441, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8804979099209506, 0.8873258364716599, 0.903609655211198, 0.8888058564950931, 0.8692530799701158, 0.8961923473251241, 0.8788758939559012, 0.8921441141485429, 0.883669333332831, 0.6655775242124631, 0.6851186236326503, 0.644867579396073, 0.6605967061916809, 0.6767229943315163, 0.7175826755662595, 0.6595865157255687, 0.6623552350539025, 0.635280874258531, 0.12202612772785726, 0.14403940699285467, 0.07185985229318248, 0.08807800342089245, 0.14560017519485713, 0.09086239802801976, 0.12723401696647474, 0.11079870096322808, 0.10011700072133112, 0.1128937050088461, 0.07090929364373855, 0.08570926686018088, 0.08679783426958021, 0.11140977127190521, 0.08737438008423815, 0.06945990358009224, 0.09768307191355341, 0.13420615235625466, 0.9230697432685739, 0.9330270613664762, 0.9323408843142086, 0.9082596591099498, 0.9192525900475761, 0.9107686790173257, 0.9344226419313394, 0.9060561620078923, 0.9175246923492684, 0.616158905039975, 0.7094580424124276, 0.6686248003753503, 0.6602069860108806, 0.6625887773781557, 0.5985736212554102, 0.7025135420288543, 0.6120314896502623, 0.5661619551660972, 0.3611657642115853, 0.11353798619989264, 0.21085043127138015, 0.2806761123991529, 0.28054756659665203, 0.3532833616186025, 0.18850786676780273, 0.19509693922788962, 0.2353166982286773, 0.5568801641951033, 0.44974471857613285, 0.13027328555364126, 0.7134083712126915, 0.6976286872482258, 0.763098100806702, 0.7198842939310264, 0.6184482524497048, 0.6461160670982609, 0.5379117605336289, 0.4185418189462826, 0.4875193392075281, 0.5994953266717327, 0.6174626721585563, 0.5548326554287628, 0.49903450825213214, 0.360624896268095, 0.4664268951329543, 0.2830340000934414, 0.11785061562687171, 0.14217338994270812, 0.15850841292196294, 0.12683718380423648, 0.13832807258520374, 0.30738698675934306, 0.14107043541294773, 0.3044238211878789, 0.29550591431199236, 0.24935627984451214, 0.26070726011884615, 0.1439232348351689, 0.17406622295239327, 0.09906773446032435, 0.1607995891131221, 0.531985667565646, 0.18965376233926579, 0.2151203827239324, 0.25142827873450857, 0.2613460728474868, 0.13558632913534563, 0.1954014364601261, 0.34204231082692227, 0.2035411696250573, 0.2298481841065636, 0.09477406209270378, 0.2954425794305058, 0.22240783964316868, 0.1723851812236037, 0.2546692051039203, 0.3735469635884, 0.20840698603913077, 0.18186702718006587, 0.25175283613636745, 0.0839221761013208, 0.6960638385819077, 0.6584208473984864, 0.7297566934021125, 0.7300184167887502, 0.7209038401182033, 0.6881114409449499, 0.7552852960972016, 0.747846837188926, 0.6770623912926181, 0.0642148231977051, 0.08093117034957198, 0.09847652955534991, 0.09772866676000436, 0.08742530746086397, 0.13346875605137443, 0.09215085264040279, 0.1446819906337643, 0.08210957107255035, 0.4051323278046163, 0.7660672865358938, 0.7057998403550978, 0.3147679953159396, 0.34155991333291313, 0.2568269436417592, 0.2172044822868412, 0.7044228916549886, 0.5873403571096492, 0.26522297911044734, 0.28752291013945264, 0.19333279269237258, 0.3334414684548528, 0.2786523499412964, 0.27579592930705266, 0.2561284691041458, 0.5721520166295038, 0.3221841668430725, 0.17241146404864827, 0.24706328630917196, 0.2105292832399729, 0.3086552521611987, 0.24486098654750754, 0.23439958839300679, 0.19378900228317364, 0.27282246547273314, 0.1317929833203203, 0.22293050753684884, 0.20563286460902597, 0.20850010393810914, 0.27531560618859574, 0.24466063866861032, 0.19439107119857735, 0.20732080966703081, 0.2194812213148476, 0.20413666064085845, 0.18407812380493738, 0.20012320928104377, 0.1805635815241532, 0.20629749502765193, 0.249521288976708, 0.1893002700814852, 0.172899144776255, 0.17690989636745358, 0.197599081300613, 0.17956469235724148, 0.1888168724913637, 0.187724072414452, 0.9322494181192397, 0.19752922665777395, 0.9108279889823127, 0.12249826243042117, 0.16944655392746522, 0.17581801458000723, 0.9437709946907915, 0.21223237408122564, 0.8630231838672757, 0.21117303061848391, 0.8343736066933549, 0.2087078508159832, 0.8994612646876047, 0.16645109636569466, 0.8919191157961999, 0.18303059262075982, 0.1900857952308853, 0.18702155933617304, 0.17698427509221692, 0.20945449440253605, 0.1972152847339823, 0.1898950271459917, 0.1854602717240924, 0.18336077733807843, 0.08768341202737107, 0.09106114995594983, 0.0783445715716341, 0.0764877626827778, 0.09068497857706859, 0.0719330099258827, 0.09093203026180141, 0.08938195810535632, 0.07630008803272281]}, "mutation_prompt": null}
{"id": "acbda446-f234-457e-83d4-e5c00630b6c0", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.cos(2 * np.pi * evaluations / self.budget)  # Adaptive inertia weight decay\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.2 * np.random.rand()  # Variant neighborhood influence\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce adaptive inertia weight decay and variant neighborhood influence for improved convergence.", "configspace": "", "generation": 91, "fitness": 0.3649657385527055, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8558602507246921, 0.8622521320119602, 0.8681957558053367, 0.8523381962549502, 0.8287568567353958, 0.8628436506333385, 0.8475842736973118, 0.7958118662529969, 0.8360315599519073, 0.6889810117497841, 0.6407341695590787, 0.6653686859332737, 0.6342732047907933, 0.682952734613123, 0.6308031003156334, 0.6422962381496546, 0.6974992655347996, 0.6363507254007241, 0.07684707146340208, 0.10229613309562013, 0.06600736486057157, 0.08956653411276472, 0.11180942827157536, 0.15468462210913314, 0.10618843988944404, 0.1215822893300903, 0.09780836006437787, 0.10506203897385458, 0.10805267241408079, 0.07642203976191975, 0.10766464950739119, 0.09027297948870927, 0.09081316939128281, 0.1125912599076655, 0.10234393912172346, 0.07638887659838145, 0.9384644112349675, 0.933696214698131, 0.9093098156760587, 0.9179371024069386, 0.9243788140053236, 0.9315974047929875, 0.9497007395651339, 0.9423351076735007, 0.9235690559587372, 0.6564960861148569, 0.7103584015236106, 0.690779633324162, 0.6030477822934411, 0.6718029421625831, 0.6821000766556001, 0.6698421288089988, 0.6686264901798713, 0.6834097310821216, 0.22757908085859313, 0.22379832581808912, 0.22289921586731287, 0.7853470869704342, 0.27393049045816464, 0.9061970426734226, 0.14267578887044907, 0.2346146185628747, 0.8558607538767105, 0.13405452805029305, 0.6061877687964223, 0.358850514276278, 0.6130599085820343, 0.13332009076170215, 0.24682970631479462, 0.7462724619303942, 0.1338644148141349, 0.21629365229830066, 0.20683540107009724, 0.25824721515430316, 0.13577043884118922, 0.2855651582147398, 0.32716550941821465, 0.6680892596376062, 0.6162558745347064, 0.13482451781981541, 0.2280723282759073, 0.1038786477011503, 0.11917503845702138, 0.09785658389429608, 0.102029754838448, 0.1285249649464154, 0.2663862983912283, 0.11118708541785405, 0.0048820928268155095, 0.10235830166060245, 0.3007723958051256, 0.15205604514694748, 0.2746737542680515, 0.11119256651671017, 0.1001118501714594, 0.07886532116354705, 0.20472779964949017, 0.17163628022447286, 0.24879390588771066, 0.07350068126447473, 0.12770566288324026, 0.3346077375601808, 0.07618438218076606, 0.07028045691941165, 0.1615436482011139, 0.3968906188828353, 0.16502326636856413, 0.07579460102267677, 0.21041825829162997, 0.18812775616250277, 0.29150515273413724, 0.3011021444929689, 0.23810747827748358, 0.31791090620847373, 0.2969007837476214, 0.12288059104599502, 0.09450762874666585, 0.6680237860717876, 0.6190680546974525, 0.6632648464564193, 0.6746309252121127, 0.6970445754127041, 0.6441528646132915, 0.6202120263681643, 0.7786181225771147, 0.734144691692912, 0.08543545138286246, 0.12620900018170866, 0.07918458556159835, 0.1022449121413227, 0.0914773185185086, 0.1092788479678547, 0.1283884572095234, 0.15045574255654193, 0.10666721700529447, 0.3904763363330618, 0.7067017048643349, 0.5528951636304762, 0.4398394809263234, 0.22470662145807452, 0.23173366086300973, 0.2466600005340288, 0.5682483355632737, 0.5232261342016312, 0.3546288163519704, 0.32277990129949774, 0.18185619051162494, 0.5332518672108446, 0.26341899689927284, 0.2885136264880427, 0.3489268674867847, 0.405862179046624, 0.1509040583724136, 0.35400220283228967, 0.28920465743317414, 0.2241391861030605, 0.1656036400556422, 0.25318841467984055, 0.27652540466337727, 0.2769504878173846, 0.4033493715583477, 0.24951384398649756, 0.22161622840845296, 0.2295408801949126, 0.23041194952770716, 0.20679165507669017, 0.2080346477699484, 0.20490858971057546, 0.21021522701131556, 0.2109993092132182, 0.2166739880962788, 0.1972646391103654, 0.1949249481703691, 0.23850515177037235, 0.18781558183230007, 0.252277107466943, 0.18752672885711075, 0.20752961226711164, 0.21511905402886045, 0.20197123097595782, 0.9398981179510377, 0.887080201080811, 0.15280249152553094, 0.8998521562886826, 0.19744590677350893, 0.9241266261437404, 0.8955484461075182, 0.1687740207254288, 0.16779992405384925, 0.9131615198099761, 0.21230067279314047, 0.8932873603208146, 0.21070880387057578, 0.16674582721898912, 0.8817185851651808, 0.8560672094425914, 0.844396504832639, 0.10429909206257815, 0.19655902883860243, 0.1915989977436411, 0.1878433393225616, 0.1860049429645857, 0.18857364719466518, 0.1828661446445946, 0.19434791684342234, 0.17314120334465466, 0.1980731656911856, 0.08673987462541699, 0.11015649620681744, 0.07991493558611806, 0.08013670779259141, 0.09050770722000723, 0.10564310967363255, 0.08107232627814898, 0.08623532830738645, 0.09208700331434883]}, "mutation_prompt": null}
{"id": "fca24d0a-90a0-4113-84e7-8ad1755a75e7", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                # Added local leader influence\n                self.positions[i] += 0.1 * (local_best_position - self.positions[i])\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n\n            # Adaptive population size\n            self.population_size = max(10, int(20 * (1 - evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce local leader influence and adaptive population size to dynamically balance exploration and exploitation.", "configspace": "", "generation": 92, "fitness": 0.33906279716379784, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9183582936511773, 0.9079964041428334, 0.9144928102249726, 0.8919594286254453, 0.8994853873806894, 0.9038513028551222, 0.908849982008665, 0.850721872815984, 0.8708649051358441, 0.7721062085769214, 0.7508941197252107, 0.5960961598523968, 0.6749622549883509, 0.7620845285330897, 0.711995085774507, 0.5627965825486684, 0.6727949919046932, 0.659680592857017, 0.07849058863356717, 0.08276161116491698, 0.04338289532711881, 0.0923306073659429, 0.11832206176332238, 0.11838231452152681, 0.11230599334840408, 0.0953865979586268, 0.0901814456236707, 0.11088744830520736, 0.04695223485387634, 0.06392490923058591, 0.09650366744873395, 0.08810202468274564, 0.03962258964215548, 0.09476585352219313, 0.07278659308875535, 0.043824393922449634, 0.902589064727769, 0.8917944456577783, 0.8983875558551799, 0.7965913246911727, 0.9330416929013533, 0.904758745976463, 0.8403708191917745, 0.9366382494076486, 0.9290136551114393, 0.6716733621831206, 0.7796996380791642, 0.7687285279253482, 0.7722504745431503, 0.7690360348742971, 0.15092200582531368, 0.7749810456829457, 0.7347041427338267, 0.6626198757973482, 0.3775156830831391, 0.14091221485835936, 0.14289427188582926, 0.9341889510027248, 0.2724680760296899, 0.21254629435058536, 0.11845679117060648, 0.12859162640652466, 0.12399674664479388, 0.4498031701445757, 0.20116805828656648, 0.18810014184420465, 0.6124255653472699, 0.7027711004067472, 0.4657104408852234, 0.7696601233095254, 0.2546127083927032, 0.5294577764219175, 0.6095393903329557, 0.48041916494014436, 0.13635385084454887, 0.40458853084167723, 0.20002782864921442, 0.6460820499244282, 0.46266016876217764, 0.13390959775880218, 0.2745311212169612, 0.12320280863063948, 0.16920611841847388, 0.07168086704096877, 0.18833203746472482, 0.019852305417195737, 0.04888259625016056, 0.08506931188684208, 0.08645866006744019, 0.07256139286610164, 0.16043818476099547, 0.09862744391806322, 0.1067142914369098, 0.09858995093501566, 0.0966661452368136, 0.12004013604675401, 0.21855977748839273, 0.14018154863780052, 0.13295697707329424, 0.28592924409336484, 0.2514899756275145, 0.13273980193665325, 0.08140512922948218, 0.12174356450251855, 0.14185220572370294, 0.3879192999982167, 0.1133693761892709, 0.07508856227607252, 0.17827134536750577, 0.1303199004966764, 0.22819126960860192, 0.2966603145727791, 0.2811749460391244, 0.06781612033941387, 0.14308346996221732, 0.25050047180054835, 0.10778949394111681, 0.6003107876119991, 0.600505804345465, 0.6512852802129296, 0.5744978732968866, 0.5863544810922527, 0.6801182448292589, 0.6815074066743199, 0.7717803568157211, 0.6682855706368502, 0.07609021303059049, 0.06781193331138857, 0.034540253229904505, 0.10079604247914609, 0.07046077965414244, 0.14103095958447232, 0.10248114339818715, 0.09424218717672994, 0.07910286944978684, 0.2411563244770738, 0.20778409880579718, 0.22407977915760524, 0.28540370412335714, 0.3049270120561861, 0.3221917900679814, 0.24304441070270133, 0.25248696526343195, 0.1866676627957755, 0.47804944579771813, 0.20829205894548208, 0.1654960180893439, 0.327422150178621, 0.2336221220023985, 0.17269627865591608, 0.25704061583092996, 0.2766964438031192, 0.16217682958507462, 0.1298168577101405, 0.25600931722414266, 0.140681186398948, 0.19905709598536836, 0.2462149751365661, 0.1613873993436229, 0.14641409094699753, 0.2720808384921446, 0.08917293501639201, 0.18085095546093732, 0.24980581970509008, 0.21849024339622602, 0.19724103957187278, 0.29186263513367783, 0.24292650259973536, 0.22276082540908548, 0.25361642347844426, 0.22383071305684066, 0.1828275300996054, 0.18624747184026136, 0.1656969442603642, 0.17321775766161973, 0.19291216203406814, 0.18581031550432792, 0.17319981115823901, 0.16894175364149888, 0.17699776297773606, 0.9254611537420026, 0.18807055209670875, 0.14637943577135448, 0.17323707771823194, 0.199434545155195, 0.9482691025201393, 0.9334740534637583, 0.9064210443135471, 0.1675253601185288, 0.8854083331179197, 0.2059089423984276, 0.6327973528678199, 0.8163913576615781, 0.16911296322789515, 0.2081689267766459, 0.7350755222366331, 0.16813309736178528, 0.77837526776721, 0.19671037197563213, 0.167449215274868, 0.19751429852281865, 0.18753233924699064, 0.1718265795468995, 0.19270640415465867, 0.18636414500404297, 0.17949977236929515, 0.18368029050451706, 0.085612566959413, 0.10680929856404597, 0.08672470629372908, 0.08875975261856384, 0.07733262846070232, 0.09427808100418755, 0.09869761335846794, 0.08160371054129789, 0.08484917205857578]}, "mutation_prompt": null}
{"id": "05041910-756d-48cc-a57e-33f7e7bc6184", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = self._initialize_velocities(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position\n\n    def _initialize_velocities(self, pop_size, dim):\n        x = np.random.rand(pop_size, dim)\n        for i in range(1, 10):\n            x = 4.0 * x * (1.0 - x)  # Logistic map\n        velocities = self.vel_clamp[0] + (self.vel_clamp[1] - self.vel_clamp[0]) * x\n        return velocities", "name": "HybridPSO_ADM", "description": "Enhance global exploration by integrating a chaotic map for initializing velocities.", "configspace": "", "generation": 93, "fitness": 0.37978172985401554, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8741469428141999, 0.8867508579507264, 0.9025783312493145, 0.8578547571910841, 0.8502437399722542, 0.8797609833196658, 0.8823976295240468, 0.8707048393428262, 0.8774674740418384, 0.7060835216889083, 0.6808631866015749, 0.6580014730573281, 0.6837571054946394, 0.7313995541907812, 0.691699261169656, 0.6572681055515663, 0.7297177641899062, 0.6872533154825039, 0.08247959805823901, 0.14101640912405622, 0.09785621805041989, 0.08247631708336411, 0.11089790234699959, 0.11354313082426815, 0.1161885833462255, 0.0877513969775493, 0.10497473747494912, 0.11692891269440531, 0.07014450835931674, 0.08407243582355184, 0.07026105516709558, 0.09199627988626946, 0.06884197732341457, 0.05825631100688211, 0.13252416867551198, 0.07579070782412944, 0.9397582695140319, 0.9300523314609288, 0.9086127295990134, 0.9276510220199157, 0.9285844758738909, 0.9110727416574013, 0.9538984305196123, 0.9423150752319583, 0.9224166165151908, 0.6567682380009208, 0.6485555038056116, 0.6897364777617071, 0.7072268850117576, 0.6950974459649362, 0.6961354777398889, 0.6067849092843557, 0.6443496104375543, 0.6579585900616075, 0.40133435217074387, 0.09924214207895221, 0.22833188082142408, 0.2812508795665031, 0.2135246473782425, 0.213463322748917, 0.23268909847147967, 0.22073769282360622, 0.8670741482256511, 0.13454514489765057, 0.5834946637878387, 0.13174032112675504, 0.5872319977967118, 0.6715444825680977, 0.7288796167884555, 0.6583673231070919, 0.13473478669214367, 0.6352129331720198, 0.65133714395278, 0.570673121945818, 0.569300920454315, 0.6182595260818704, 0.5373610882926214, 0.5626558172424789, 0.4505886328501503, 0.7545382427833842, 0.5422728517781277, 0.10745515022345009, 0.05267726251690441, 0.06686339808286612, 0.0670425418341094, 0.1896982405289971, 0.09598574309796182, 0.2309619291383681, 0.09211375575906078, 0.2171305903009334, 0.401498428916245, 0.11866658211044412, 0.3838423335199722, 0.24703623397551844, 0.1679968552758455, 0.04657417504985606, 0.3389339521310095, 0.26841394216683645, 0.23622155066576334, 0.21113982360139794, 0.1813288704939946, 0.29980048197750175, 0.07664269758543962, 0.23113317983908688, 0.10010897748368586, 0.19266792884614903, 0.10750589842851965, 0.07066006542787728, 0.23580596248970154, 0.4263503217663457, 0.34771917974331235, 0.33516190417492353, 0.2567894022539532, 0.2489392781667672, 0.3349949585439793, 0.08365802459624794, 0.13932777664519236, 0.6515448579187393, 0.7340583307516028, 0.5802267332099229, 0.7701381170442352, 0.6979587141621757, 0.6629682631325231, 0.7027194166968591, 0.7629957576732943, 0.608236083357561, 0.04515636276322654, 0.06151746599259822, 0.030633538162637364, 0.15763860491669912, 0.09910457901936753, 0.14121064140033157, 0.12499320918602475, 0.09224101046348265, 0.10847368457305584, 0.5200040636664498, 0.7127222274499228, 0.6624392614779766, 0.21912694442082203, 0.24286038693532297, 0.20546876261067182, 0.6415810576095877, 0.2057496399806381, 0.257546820208842, 0.1842705391919508, 0.31126687748551485, 0.19289992683579882, 0.3612395812437852, 0.2661955716256963, 0.3161313777429816, 0.2636132998819296, 0.2993995445186729, 0.16198025657295345, 0.12029160246113446, 0.356302093365109, 0.2367042121250893, 0.3289744627839234, 0.2652650959690064, 0.2798860577806166, 0.218658483502163, 0.27417451900959544, 0.11471621419623024, 0.22966894498108892, 0.24238286841881296, 0.20868174773004, 0.1993089413850998, 0.27556962414755304, 0.2292092567714108, 0.24570729491980592, 0.20920201415462758, 0.2071222250322794, 0.17943250107035458, 0.18482595372991295, 0.18933183641379436, 0.18824198078831045, 0.7124239232526575, 0.20747762237937495, 0.18571410684227052, 0.19182299341017295, 0.18751157762414428, 0.9302635493106198, 0.9008221926878238, 0.15356548903394718, 0.9083266794177307, 0.19997239395441135, 0.9344188237451498, 0.9089724268071475, 0.9021655147483155, 0.1668140138082126, 0.9063252740546992, 0.21325067908422657, 0.9054514548285661, 0.21201563890922293, 0.16795519695668337, 0.21038052376533145, 0.10509132424683154, 0.8130094050512615, 0.8988193634975181, 0.17302197230256866, 0.1663982159250854, 0.17399956302128594, 0.18654589306908076, 0.18436216981135822, 0.1722783328832045, 0.18121258822672948, 0.17465008491943013, 0.18899993008955396, 0.07546386191807708, 0.12651844541201573, 0.07890562606951934, 0.0797287227450848, 0.0962278400796458, 0.10127551859353567, 0.08004723135782466, 0.07901637900409242, 0.08150316470133234]}, "mutation_prompt": null}
{"id": "5721cc72-ab02-4aa5-a82f-13a1d330aeb6", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n\n                # Local search intensification step when close to global best\n                if np.linalg.norm(self.positions[i] - global_best_position) < 0.1:\n                    local_intensity = 0.05 * np.random.uniform(-1, 1, self.dim)\n                    new_pos = self.positions[i] + local_intensity\n                    new_pos = np.clip(new_pos, self.bounds[0], self.bounds[1])\n                    if func(new_pos) < func(self.positions[i]):\n                        self.positions[i] = new_pos\n\n        return global_best_position", "name": "HybridPSO_ADM", "description": "Incorporate a local search intensification strategy when close to the global best to boost convergence near optimal solutions.", "configspace": "", "generation": 94, "fitness": 0.34801618507127324, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8273564868434042, 0.8690942057467315, 0.8531539969506889, 0.8385394452733211, 0.8619235412105808, 0.8648666373595946, 0.8420341193420489, 0.8596610298344421, 0.8162232297517283, 0.6244826788952451, 0.5012284687171636, 0.45852041530293675, 0.6165634083684055, 0.6383601661141712, 0.6537521524592407, 0.6644387804165115, 0.5677907203611787, 0.6382227209703573, 0.14762122504053388, 0.09350107210942493, 0.05360094924725567, 0.13253598306793957, 0.11708271874271847, 0.1442749102020876, 0.11606958629027064, 0.11682200918464059, 0.09200525501521173, 0.10819888036673897, 0.0894677162630183, 0.10715139287938924, 0.08349181208065615, 0.0827892209490737, 0.08121838286266925, 0.09680160207228383, 0.1109174641362759, 0.08914714241986277, 0.91076781527096, 0.8931360738140615, 0.9310539328569245, 0.9287765470774842, 0.9328656893878167, 0.8973226757896604, 0.9192828712153016, 0.910826998574838, 0.9250703233458905, 0.4577455611839326, 0.45981367047206045, 0.5439735590057933, 0.5003986419370456, 0.5112839621682408, 0.5485377900664021, 0.4421341260975761, 0.5144824134267071, 0.4993401608671627, 0.23059015148174744, 0.13999033878586797, 0.13997448675925084, 0.21065864982644478, 0.8887188465633666, 0.21278119091590242, 0.17748248761277396, 0.8868706032929735, 0.1562683743746075, 0.13369223740159997, 0.45116090535162867, 0.42440219971234505, 0.2966466945575579, 0.3526597126401909, 0.37464794462879414, 0.6131227897343912, 0.34500527619486365, 0.39341087384881335, 0.1348168767342568, 0.46104251015788444, 0.13489951116839327, 0.31765488472610903, 0.4455434141971586, 0.44525746417641066, 0.5099559175840699, 0.658348947779964, 0.6695275637802054, 0.13812499664542832, 0.08599574712039049, 0.34927958846441354, 0.15678791743370546, 0.10556734686373515, 0.12241669032806535, 0.14963545349781948, 0.12795312778539902, 0.17225920682113405, 0.3295425466916061, 0.2000415600427431, 0.25554102394558753, 0.23242012520885413, 0.14910810499399818, 0.11317174927873075, 0.2706878532132653, 0.3263139756011906, 0.21039876978473004, 0.16457327562088808, 0.14922839118658193, 0.12859395916347316, 0.08474397781239618, 0.0715270658877667, 0.12648236540759195, 0.15095484588153418, 0.17432644598678237, 0.07244522522400909, 0.09328621011615301, 0.16049866172116212, 0.23097717409092422, 0.1903487028970866, 0.21101354999241917, 0.17375461066071207, 0.08224036829420711, 0.2160837293077631, 0.21031665261973864, 0.6625032335784209, 0.6546992269856873, 0.6210496081364528, 0.6151200144355848, 0.5847214147150078, 0.636907032145444, 0.6595449918543157, 0.6479870962177618, 0.68389382795278, 0.07362782231762899, 0.027548139234959357, 0.10762310327891667, 0.11441249040887747, 0.08950969591009961, 0.09302122442136329, 0.1359024185639086, 0.1163239358105449, 0.10504977500800561, 0.5615038371562286, 0.17702272367833172, 0.622050129253777, 0.27958949019013046, 0.3020478459273802, 0.3436852487248523, 0.23012158434830543, 0.16217387377961712, 0.17286030701541244, 0.300310550608771, 0.28305883387435904, 0.19836071809012934, 0.4208985317176599, 0.25712509287242835, 0.2624298282317922, 0.2543799359075367, 0.39711842099398686, 0.14764711451193058, 0.11969509868990458, 0.2599738005672342, 0.21805641712071933, 0.27617372454017564, 0.23841987150119592, 0.17283343520486794, 0.18348330942491242, 0.26595079170341673, 0.1061432490802845, 0.21779728212198313, 0.20830862541908113, 0.19731888167086498, 0.21619980121353788, 0.22872802262326952, 0.2196803921585493, 0.22875084245695576, 0.2266838316769917, 0.2505792536033806, 0.22326125508768646, 0.22296536867987304, 0.1793435947638352, 0.18506205245689644, 0.20310411479041723, 0.18924745534148935, 0.1821180825807024, 0.2164282284257366, 0.18141024137478357, 0.9359591821262369, 0.9288709282419901, 0.15315461567865163, 0.9324402820187937, 0.20068070299278762, 0.9217246927139859, 0.9208143259583513, 0.9020302050791968, 0.16669841837038224, 0.8698687972599548, 0.21272407283851424, 0.8925057045084714, 0.21014056048678642, 0.8591644174699172, 0.9195045371441446, 0.10525724621765598, 0.8438335748758413, 0.16325961391604593, 0.18945468034946755, 0.17156110315782114, 0.18255698449593105, 0.1804739949356159, 0.1869423304401986, 0.18597815833207076, 0.17122753311103844, 0.18661543146879322, 0.1777068160159464, 0.08594012455138889, 0.07345148409106272, 0.08886372210090976, 0.07211175211807819, 0.08867517444235051, 0.10351896523135218, 0.09247461405359536, 0.08748392220010015, 0.11078697527922998]}, "mutation_prompt": null}
{"id": "1feecbbe-f86b-4366-bd87-ede50674473c", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                local_influence = 0.3 * r2 * (local_best_position - self.positions[i])  # New line\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component + local_influence)  # Modified line\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce local leader influence in velocity update to enhance exploration.", "configspace": "", "generation": 95, "fitness": 0.3730223878998864, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8644601443443819, 0.8808744117316475, 0.8768740049274283, 0.8178784479435254, 0.8724119604311287, 0.8821800426405658, 0.8844134491598636, 0.8875764651431415, 0.878847394209088, 0.6353074256667807, 0.6489372955004411, 0.6438979817966278, 0.7041295427042259, 0.6533379521231708, 0.651464107760771, 0.5715263528460086, 0.659005957258151, 0.627818188183654, 0.06882143840860355, 0.06768592898535719, 0.09370726257061746, 0.10287616604009531, 0.12295471760100607, 0.15470669655602232, 0.10438944726003851, 0.12529743300200646, 0.09187656717088999, 0.10928995720564094, 0.10998800326008407, 0.07917728893851705, 0.13364570581214663, 0.11070324198840586, 0.10019278536952203, 0.09459585405815729, 0.10807343763546251, 0.10789332649131378, 0.9311574962414031, 0.9312142667962119, 0.907265091541736, 0.9151339644311665, 0.9235345021479484, 0.9161927718720407, 0.9251788180378441, 0.9243614259293897, 0.9251059188612641, 0.5971963089302412, 0.6356047013778352, 0.6644775589783578, 0.6698270103403481, 0.6311115832464868, 0.5965697220454111, 0.6506443383912, 0.5876971661249522, 0.6328527239066151, 0.23134267001752773, 0.14035336025780543, 0.1685044302278056, 0.2778519147585745, 0.21264262881377094, 0.21221913574590678, 0.20492130290827393, 0.1775064954761607, 0.16061717764076333, 0.7004864639621635, 0.5079291982810239, 0.6095742116702143, 0.475291112640713, 0.524427865271694, 0.4436457023431494, 0.6748433639071016, 0.13473586045207808, 0.6116637333864707, 0.4755129921463418, 0.549652946486459, 0.1346570984846056, 0.7140676344006281, 0.547267292293248, 0.6259705824457199, 0.5371026472730758, 0.5984852452883174, 0.13558011186555852, 0.3243748169874876, 0.13185294738215958, 0.28953694584625167, 0.14242514878992985, 0.14059798582941707, 0.04208786092161576, 0.17048900209721018, 0.13628339079100682, 0.22618863784695964, 0.23265698322277917, 0.1892680079243937, 0.23080182305980457, 0.08992616382930885, 0.09350322746639117, 0.050720898654513125, 0.22006918932038944, 0.5101934826882205, 0.18617665961671692, 0.25481672778838116, 0.28575269255807245, 0.11584689156704242, 0.07581319391710406, 0.17535063489684777, 0.10416379574592627, 0.23510312131009026, 0.17281619180618313, 0.07339231678196723, 0.28177541471723777, 0.2540117016310308, 0.202956341705956, 0.3140505852172545, 0.2417439727594014, 0.2705962854671108, 0.1990279575515913, 0.08253283218330143, 0.082847950818847, 0.7956727907913135, 0.824041055677132, 0.7318957704543241, 0.7427946730182353, 0.6373302402138001, 0.6780057695139965, 0.6657405038327758, 0.692767278324298, 0.7073685334042874, 0.09260378679436909, 0.08113216059301664, 0.08540078124151118, 0.0939205546950076, 0.08883890323658139, 0.14465508633114765, 0.17106991080567546, 0.10868408597260482, 0.09538045897578484, 0.5787515381104108, 0.6526801006749986, 0.3423099556236209, 0.14154255871307575, 0.18489872125411255, 0.19863900063024764, 0.6230916050480224, 0.5296082596979016, 0.29703761742522194, 0.30475731644873083, 0.29766226862909795, 0.16361900345587588, 0.5205590831047947, 0.26358417886941965, 0.5729018928571539, 0.2486837218954141, 0.5561025671335282, 0.14817055858414074, 0.20021208458058093, 0.2822456938015504, 0.18790934339388754, 0.29117531255617146, 0.24995028824349386, 0.31540248992304654, 0.22613732421274724, 0.17055627294437814, 0.0982359418581138, 0.2473679725305804, 0.2302767997226418, 0.19709561320035485, 0.2079049839828182, 0.22259401578370475, 0.24936264940493524, 0.21747967571431615, 0.21746199671234767, 0.20180904826634627, 0.17828589253056448, 0.19087485707853225, 0.19827499477217025, 0.19351586083979377, 0.2011222024506094, 0.18776989271950606, 0.1893924586818997, 0.20844394762944507, 0.18824563649609516, 0.9242663162298289, 0.18830090306707337, 0.1468535594878827, 0.9113455896982582, 0.19978933368962937, 0.9350022663901654, 0.8994026929189594, 0.9037474013920505, 0.16716470792888483, 0.9131619637888388, 0.21350558085501437, 0.9163135772495395, 0.2098317017138457, 0.16746852460394746, 0.8915573163122955, 0.8923744133597225, 0.8688315781942852, 0.861874681398726, 0.18804319163708239, 0.1880732114166649, 0.17541692449933033, 0.17952223080462903, 0.1813427076441274, 0.18057996705774426, 0.17851505352765817, 0.19180093014817645, 0.17564666583562571, 0.08500608578820779, 0.11094617501753778, 0.06495280561812955, 0.08929727803045784, 0.08533482189365427, 0.11042802748243319, 0.09841270978072791, 0.0843922909532222, 0.07478034783086007]}, "mutation_prompt": null}
{"id": "bcb2bca8-2095-4b26-9970-b073004f3733", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                friction_factor = 0.9 * (1 - evaluations / self.budget)  # Dynamic friction factor\n                self.velocities[i] *= friction_factor\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.6 * (self.positions[b] - self.positions[c])  # Slightly adjusted mutation factor\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic friction factor and slightly adjust mutation strategy for improved adaptability.", "configspace": "", "generation": 96, "fitness": 0.32245052821188086, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.9076519083530715, 0.9012149681144718, 0.8941506168499533, 0.9015225228622985, 0.9013894544368695, 0.8986186910559585, 0.9105480928410209, 0.8985681863663165, 0.895746430293144, 0.7308366864984956, 0.7813844861166588, 0.6175664853613672, 0.3206072632686825, 0.7973697281617457, 0.3261750358734786, 0.35956922081610065, 0.7785637543191948, 0.3579607879112289, 0.08585409974856595, 0.08958434783545854, 0.06884926178618311, 0.11125735702504902, 0.12594565276515401, 0.11722006833102883, 0.14171331663748765, 0.0890800940118135, 0.0912235380535551, 0.07930471942779371, 0.08276902004941544, 0.07913071908249092, 0.11499890950531066, 0.09316701210117151, 0.0876605790400301, 0.10789567120777699, 0.09681224080775264, 0.06748980832699547, 0.9340193942859325, 0.9274722309740487, 0.8980386836588539, 0.8912738105695956, 0.9326319276927006, 0.8632400510395748, 0.9316481448071, 0.9407717044683175, 0.9128874663000909, 0.774091406888592, 0.6708043850642662, 0.5587789236942933, 0.7205324814128692, 0.798963313690971, 0.8001452036799079, 0.7964649317206645, 0.7512770575825533, 0.5539674521734435, 0.15830601900678654, 0.16845476604401555, 0.1348520066091391, 0.36603379978484885, 0.1801381006431957, 0.19718090091131135, 0.1517588069423016, 0.17845210237391906, 0.24233545876991092, 0.13419606117108873, 0.13665001734467364, 0.2778566854328034, 0.15170128990799936, 0.1616764287047816, 0.37536397867179294, 0.24362423757919638, 0.13525879358790716, 0.146023452273084, 0.19998889091008554, 0.17396270591081353, 0.13396710915220933, 0.18425369831808325, 0.2068797309362993, 0.17805572820350657, 0.21317558539584425, 0.1645550785261083, 0.19540710778974812, 9.999999999998899e-05, 0.07615130466913489, 0.13416553043794122, 0.04420418919218283, 0.07335327552102722, 0.08110036738127924, 0.14035425132768065, 0.026887544932284846, 0.0643207645642273, 0.14790386373765718, 0.12723130052364717, 0.241160394928421, 0.12616507021441026, 0.06962626344844425, 0.03624416922778273, 0.364366485929446, 0.17101006571498545, 0.13795630709034645, 0.3971665984725764, 0.39873338063398156, 0.17638580770948198, 0.11394940367335515, 0.08146198027114882, 0.09564791929839034, 0.19805453238100035, 0.1526251838394983, 0.07510557368275184, 0.06657184670705141, 0.23893929531204194, 0.2100314459967495, 0.10088077335553114, 0.10113722276000425, 0.09530972100758883, 0.09779793774358658, 0.18626880885868147, 0.08682715632117255, 0.6362334031040254, 0.5280479535495683, 0.5477888256629211, 0.6202946942172722, 0.6844807120675693, 0.6495001489928369, 0.507142317326015, 0.6081987334662585, 0.6717957911197354, 0.002353004936066272, 0.11053341815276452, 0.029613932936701337, 0.10581400369859362, 0.09849482518589991, 0.10940227908955891, 0.09625293002052981, 0.1387380709576631, 0.11059792433875404, 0.27165156509618515, 0.348697733836385, 0.29021330529575584, 0.5044184835855572, 0.5756202949885432, 0.2156263195846071, 0.6204019088802593, 0.3985814012172836, 0.31077233770570234, 0.202369642498741, 0.3038937028233921, 0.19328490765590767, 0.3687351604602812, 0.2586767270686928, 0.2311440231757922, 0.18064331297431324, 0.4124869173089142, 0.13025019455911113, 0.14908309879493065, 0.2650340467218226, 0.11693424227292304, 0.337178847110313, 0.33739678011859486, 0.3087777472535005, 0.23246574743547344, 0.1957618645922251, 0.10817061259022087, 0.2887158592154173, 0.20076205799553049, 0.21368443114601354, 0.2244054952388176, 0.24430071608750648, 0.2494622925562996, 0.22009474857597766, 0.23018352092914152, 0.22909986502562085, 0.1682203583838826, 0.17852904153979776, 0.1946660634249453, 0.19188022132251292, 0.21836671634548444, 0.1773470939965941, 0.18214946942726418, 0.18743769323626724, 0.18533735959296627, 0.9471873534510608, 0.9206186946406604, 0.1528003429289876, 0.924243120230499, 0.19994758475751562, 0.9507518937737965, 0.9374955011603615, 0.16421081992105424, 0.16835461989370382, 0.41694538828973304, 0.2127582038304422, 0.7772740019528648, 0.21111450887637528, 0.819079846735165, 0.6756525144870974, 0.8639222768530859, 0.1686890594627234, 0.10502395360169525, 0.19373383468905692, 0.18243256403337427, 0.18777221516245546, 0.19688903765825339, 0.1853090047990701, 0.18262301959454785, 0.1788152073110295, 0.17571037201207673, 0.18771269821991832, 0.08724176445282883, 0.08576645896343105, 0.07263239249987741, 0.0792412881560709, 0.10055640570007796, 0.09462732899382076, 0.07221802410859968, 0.0933471752297812, 0.07670513615315244]}, "mutation_prompt": null}
{"id": "78ec1c9f-aa37-43b3-89d9-fbf6292be8c0", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
{"id": "a7fefa82-c194-4915-9671-aac03ee96bd0", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)\n            \n            if evaluations % 10 == 0:\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n\n            if np.random.rand() < 0.1:  # Randomly perturb velocities to maintain diversity\n                self.velocities += np.random.uniform(-0.5, 0.5, self.velocities.shape)\n\n        return global_best_position", "name": "HybridPSO_ADM", "description": "Integrate a diversity preservation mechanism by perturbing velocities occasionally to avoid local optima.", "configspace": "", "generation": 98, "fitness": 0.27954485288786796, "feedback": "The algorithm HybridPSO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.7412239592114983, 0.6660242503138002, 0.6134292319024617, 0.6985142466855001, 0.634922218016847, 0.5956552965503294, 0.7272834436357355, 0.6275178661963973, 0.6646630743966638, 0.25053977459469035, 0.07846948027465261, 0.08018054503755134, 0.1985255913247559, 0.07855058881207766, 0.1887813561978231, 0.15396705288505141, 0.12002201860389428, 0.20490825008182934, 0.051700467440514486, 0.08883420564907485, 0.07791054797209995, 0.07979941303575766, 0.10471371326867551, 0.1146474495448776, 0.10764837131903171, 0.10713533485130666, 0.11584407075162473, 0.0848170925835271, 0.08917566980711022, 0.05611886080770323, 0.11559376965097601, 0.101936747988153, 0.07153051097464869, 0.09222375503406277, 0.1047659230776139, 0.06226964666256862, 0.9227790624475315, 0.9194253826686812, 0.9068817188890799, 0.904768257647776, 0.9045532279923127, 0.9125891176429024, 0.9444304295004139, 0.9360699922748961, 0.8795567490782035, 0.4184860364569999, 0.39682193527597953, 0.3776572863265386, 0.4511874234651173, 0.39125253548596406, 0.369283420072825, 0.36771703298577796, 0.3676460650850947, 0.3407967497466373, 0.23079837488637744, 0.13887333796084134, 0.21342598511203292, 0.38355897402042727, 0.7861722897570422, 0.6948711074843918, 0.17793791571445505, 0.2372141747224642, 0.23498016369888153, 0.13602821354014138, 0.1299520766590636, 0.20531998803642704, 0.23861616298730193, 0.20232762953104566, 0.1924368307108607, 0.3540945156164923, 0.1790777780521564, 0.23774173091724438, 0.24105836040927642, 0.2080451234441476, 0.24300669670061503, 0.27656696322158836, 0.19327515145748608, 0.24483788736652157, 0.20663296089031824, 0.2241286203863535, 0.13252191193365237, 0.04220560997826017, 0.0672559616542292, 0.06229540932408362, 0.0695805074723368, 0.05499840332515504, 0.08217646627914543, 0.01558985522610723, 0.04144084279954463, 0.15942984933542415, 0.2514776618157515, 0.14167676729701473, 0.18126695487605726, 0.050360156621708896, 0.15196135276524547, 0.038405003710042185, 0.30210657028549937, 0.11419199918528178, 0.11083672322194127, 0.16472051736722604, 0.043479037502642814, 0.0836193101960806, 0.11797456146680285, 0.053819679457308145, 0.0916026559736618, 0.22073496704920248, 0.052612610263665927, 0.06903767302793984, 0.1149665998450139, 0.13775725866143418, 0.13235754479943318, 0.09531169955872898, 0.1250622512280707, 0.17148486722391176, 0.08222625254260019, 0.12023166113556649, 0.08599208944770875, 0.604443971632574, 0.5071985127940282, 0.5030929656415235, 0.5897135287199223, 0.5232215327900618, 0.5305973414840582, 0.5365626359465108, 0.5717526706552994, 0.5359438070573326, 0.047133363721379995, 0.06617735843971173, 0.07723549717240863, 0.10603483878456355, 0.09280137516481846, 0.12131239915232905, 0.16259146736672847, 0.12048110450003424, 0.10105037953766893, 0.38455140194071824, 0.1867491021501929, 0.3083592222634274, 0.14862609039605812, 0.32450707931621914, 0.2075438660346911, 0.3235597610679811, 0.3626328772867733, 0.3316637890818176, 0.3157562020168597, 0.33332852512885736, 0.1844455554747858, 0.2725216598345851, 0.26098901225548365, 0.3516660077557674, 0.21972692795477422, 0.2749715149359111, 0.15469680547409992, 0.15308482441124616, 0.2944867101063251, 0.1663149463550173, 0.21172832127317642, 0.23708994959552931, 0.17820089980732068, 0.17403311042123137, 0.22922315036574237, 0.09448226769647206, 0.2300614078415033, 0.23113059202892272, 0.18525147918171003, 0.22499698720235262, 0.21826915675531722, 0.199574906514268, 0.22184156162279411, 0.2044002741269575, 0.21717561137510966, 0.1929726808058455, 0.18971741651807084, 0.19156638286161765, 0.18857761789360727, 0.2231588955376782, 0.18828335514182903, 0.19124876181872974, 0.19566179902728664, 0.1815817489192999, 0.9244317327902013, 0.18717714352264314, 0.1527717153009902, 0.9397535997452828, 0.8587063484333634, 0.8481108073663487, 0.8994842048876857, 0.8958347893777113, 0.16806596346003566, 0.9169497567158315, 0.21273692879687633, 0.8224250014308678, 0.21065650335957442, 0.16829746472798468, 0.8873665618643654, 0.9101716245076692, 0.16836394488837414, 0.10431631871989955, 0.17702599126547336, 0.17269183641561303, 0.17720986624813084, 0.18983972340481003, 0.18766650305653898, 0.17343496434792016, 0.1768759404176874, 0.17968329739586475, 0.18297496497468757, 0.09771117656231276, 0.09919852733571866, 0.0777699090139693, 0.08583954701618457, 0.08385543339362067, 0.11123214347550181, 0.0955312472378822, 0.08561535697786982, 0.08866194388802229]}, "mutation_prompt": null}
{"id": "a5393032-5e93-4467-84b3-f794d1eef1c7", "solution": "import numpy as np\n\nclass HybridPSO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 2.0\n        self.mutation_coeff = 0.8\n        self.vel_clamp = (-1.0, 1.0)\n        \n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.velocities = np.random.uniform(self.vel_clamp[0], self.vel_clamp[1], (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        global_best_position = None\n        global_best_score = np.inf\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = self.positions[i]\n\n            self.inertia_weight = 0.5 + 0.2 * np.sin(2 * np.pi * evaluations / self.budget)\n            self.social_coeff = 2.0 * (1 - evaluations / self.budget)  # Dynamic adjustment\n            \n            if evaluations % 10 == 0:  # Select a local leader every 10 evaluations\n                local_leader_idx = np.random.choice(self.population_size)\n                local_best_position = self.personal_best_positions[local_leader_idx]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                cognitive_component = self.cognitive_coeff * r1 * (self.personal_best_positions[i] - self.positions[i])\n                social_component = self.social_coeff * r2 * (global_best_position - self.positions[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component)\n                self.vel_clamp = (-1.0 + 0.5 * (evaluations / self.budget), 1.0 - 0.5 * (evaluations / self.budget))  # Adaptive velocity clamp\n                self.velocities[i] = np.clip(self.velocities[i], self.vel_clamp[0], self.vel_clamp[1])\n                \n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n                neighbor_idx = np.random.choice(self.population_size)\n                adaptive_weight = 0.1 + 0.1 * np.random.rand()\n                neighbor_attraction = adaptive_weight * (self.personal_best_positions[neighbor_idx] - self.positions[i])\n                self.positions[i] += neighbor_attraction\n\n                self.mutation_coeff = 0.4 + 0.4 * (1 - evaluations / self.budget)  # Dynamic mutation coefficient\n                if np.random.rand() < self.mutation_coeff:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + 0.5 * (self.positions[b] - self.positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                    \n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, mutant_vector, self.positions[i])\n                    if func(trial_vector) < func(self.positions[i]):\n                        self.positions[i] = trial_vector\n            \n        return global_best_position", "name": "HybridPSO_ADM", "description": "Introduce a dynamic mutation coefficient and an adaptive velocity clamp to enhance exploration and convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d4fc38f3-5131-4c7b-a705-bc0929f9735b", "metadata": {"aucs": [0.8767528083855941, 0.8923211486096954, 0.9054406695809262, 0.8619603753771898, 0.8816484026528324, 0.888128538207517, 0.8668393784621983, 0.8997783890727449, 0.8951771442131242, 0.6995623225981696, 0.7116530942483915, 0.6320851804001641, 0.6929287676060016, 0.7242381778246032, 0.6517134306415429, 0.695251972401516, 0.738430233008424, 0.6755137982999875, 0.10983827514490463, 0.17414872150412575, 0.07255619243753375, 0.09510148189440593, 0.15585640139074863, 0.12651814156896068, 0.11659430663202908, 0.12257624313790183, 0.12301477785170278, 0.08847864852080511, 0.11109745304664853, 0.058405053968957676, 0.11086517835087228, 0.09564720386522607, 0.07106984314093356, 0.10413139131434113, 0.09072286512931738, 0.07591693128529364, 0.9358575632746763, 0.9353922129941344, 0.9190081916861236, 0.9070023593012954, 0.9355628054803025, 0.9348407885691437, 0.944235709896785, 0.9458972609276887, 0.9200189709146671, 0.6714767180243175, 0.7118857307014631, 0.6298707984005685, 0.7146374670054585, 0.7119176501637525, 0.15166478691465546, 0.6716911764702693, 0.5692146177791814, 0.6623119513088163, 0.23051347856664428, 0.16922084293451878, 0.13475196089342734, 0.9329067373147839, 0.3816323624032095, 0.28011761274658076, 0.17797522209829253, 0.15211100078422857, 0.8920904087059328, 0.13606239134982845, 0.13542987952100316, 0.5659669311236005, 0.47235323534008167, 0.4718162012760826, 0.5585405659691934, 0.7815946316579997, 0.13496381976381655, 0.5800072584287301, 0.5582475772338016, 0.5464185529014856, 0.7553849565002989, 0.7533950626262803, 0.5821913538608058, 0.5991124832793002, 0.5726869589226912, 0.6264529361501299, 0.5116864160334373, 0.04172511790403677, 0.056314005277184886, 0.26401212255921036, 0.06271750946678911, 0.19221383980304185, 0.13162233248841781, 0.23508557621592807, 0.19889948920372458, 0.2749536213359435, 0.20441921322917078, 0.12825830177675912, 0.7334857449411811, 0.29445206309160443, 0.10916131794093964, 0.10309193260115079, 0.3522023642447595, 0.21032916692040537, 0.13756294321008267, 0.1166433810715447, 0.24095600404759554, 0.17957844748111418, 0.21646508329108904, 0.18350906255157984, 0.10276321645300035, 0.39968142848570964, 0.2884780468084235, 0.07927984005597277, 0.2812969472786354, 0.2805955795711733, 0.2584918380602419, 0.31192602440400696, 0.27032471878378506, 0.17072885319054532, 0.15505173256529392, 0.37107094066842006, 0.14911064960037546, 0.7694400974304108, 0.7916504962302415, 0.6461249607387889, 0.7086431307421546, 0.8039641596873064, 0.8153108253226354, 0.6817947871756511, 0.6920878686865711, 0.7820437283322095, 0.06527512463683038, 0.05663078196842419, 0.0623011445795304, 0.15249777696253963, 0.12506425324313786, 0.13303960027773187, 0.674111461879618, 0.10309056993796495, 0.08808918689140888, 0.32965010486436574, 0.38809788476974016, 0.31657090707239477, 0.20271081947897884, 0.24889373474068988, 0.3461354289733639, 0.39159719061751264, 0.5362455130187868, 0.29977241248889086, 0.4408739474669259, 0.29720995790765725, 0.24423789439235488, 0.5196847559075215, 0.27229526569761997, 0.35199611409161236, 0.4364096759998636, 0.2768154984021779, 0.1175265771859324, 0.27812431295461515, 0.30568545254918067, 0.22510562099688913, 0.2800691512784418, 0.33070680942095354, 0.2731996242579128, 0.2392327844780826, 0.25668069487414524, 0.20532117964219931, 0.25281269978465504, 0.2328496966885757, 0.19819104847120572, 0.2215495395400714, 0.23441266016527906, 0.2206899019888351, 0.2258545247127849, 0.2730871694725642, 0.23728368344685768, 0.18014938488028276, 0.22595716614795902, 0.1710114590004549, 0.21004957230497634, 0.23065521810771383, 0.18512756594800184, 0.17297328100202536, 0.20896034846094536, 0.1924292798564865, 0.938524969584397, 0.8956071709617807, 0.15327720301267778, 0.9361359611008366, 0.2005384475998998, 0.9353638755771511, 0.9084961987773411, 0.908537542577577, 0.1685900575695214, 0.9009090865623024, 0.21236461787253036, 0.9260633743059126, 0.21072805338047262, 0.16776303324260555, 0.9016550575716691, 0.8724427384776499, 0.8742101437648563, 0.10484542488582416, 0.1791447521254087, 0.1826494711841118, 0.17321924202458472, 0.1692882597009986, 0.1780650780470805, 0.1725176647928347, 0.17206643966644009, 0.1744261072302803, 0.17444714160583286, 0.08488951758625629, 0.10068033281192279, 0.08440781481059167, 0.08200052030977023, 0.10587907684932674, 0.11077816876479796, 0.0853154069478751, 0.0802138434289924, 0.07933940960422547]}, "mutation_prompt": null}
