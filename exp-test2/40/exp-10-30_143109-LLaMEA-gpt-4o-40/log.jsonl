{"id": "82f81de4-aae5-498f-bf39-8ab94002356f", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    0.7 * island_velocities +\n                    1.5 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.5 * r2 * (island_best_position - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A dynamic island model-based Particle Swarm Optimization with adaptive velocities to explore and exploit multiple search regions effectively.", "configspace": "", "generation": 0, "fitness": 0.12952494010982601, "feedback": "The algorithm IslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.16.", "error": "", "parent_id": null, "metadata": {"aucs": [0.1814346014909315, 0.1545374672782549, 0.15636361876490756, 0.1860589996911618, 0.11276472033228402, 0.11406147821600066, 0.13519764539132373, 0.15194484846317335, 0.1845223164093993, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04652550641603215, 9.999999999998899e-05, 9.999999999998899e-05, 0.021773286980753426, 9.999999999998899e-05, 9.999999999998899e-05, 0.07949820134613861, 0.06809468488901915, 0.06404557724586701, 0.09280923707782351, 0.04427631509701224, 0.03832796083574119, 0.0701644567911438, 0.07197327634518647, 0.03306803386001811, 0.04611347521306175, 0.06425534838615587, 0.04862076631808998, 0.06955020171294013, 0.031376613076284254, 0.044161132795845104, 0.06282674102951202, 0.024598511560924963, 0.024631345074607403, 0.9820558353393509, 0.9839480144631155, 0.0986889806463761, 0.9836493243455002, 0.970358856540751, 0.09925341677898214, 0.9721394377511305, 0.16286348072273904, 0.9875412601020297, 0.09756040082321671, 0.05672772577628804, 0.08889501266565825, 0.012164269296049857, 0.03777626685688773, 0.11173577289097592, 0.08392857747590954, 0.0385724323425205, 0.11491736103805017, 0.12477600688870227, 0.08241909255800073, 0.16414435820568962, 0.17904198405210248, 0.14407245698942772, 0.11576761312982486, 0.19563302780303626, 0.15151622793614372, 0.12454293735972011, 0.023666749131292852, 0.08830127611642291, 9.999999999998899e-05, 0.03770669700380136, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10112680553587183, 0.05395263067974576, 0.020735434321069945, 0.11827637375087086, 0.08546450293533414, 0.04476391990397277, 0.07278205236041135, 0.1068746963948135, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07348805536516123, 0.047656733630947024, 0.06419380012403486, 0.0833739442231266, 0.0710321881906133, 0.08909106717060056, 0.06594976410628717, 0.1445245641277505, 0.050531718656685154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01888753693094425, 9.999999999998899e-05, 0.05812109363481999, 0.027045563326404953, 9.999999999998899e-05, 9.999999999998899e-05, 0.03677098011354141, 0.15493858888282552, 0.2244165162700782, 0.18943103439066844, 0.1779777101446538, 0.1587010738607758, 0.17523969818468454, 0.279503997874744, 0.17360601441971435, 0.2694700152740017, 0.08150124039336493, 0.03676802782090327, 0.07084935419508875, 0.062311257720231494, 0.07652820248211978, 0.07270815529770935, 0.05336243191923418, 0.0453519008020663, 0.04048265915619376, 0.17028626325706586, 0.2718097522206302, 0.2426996345104092, 0.18309004896891878, 0.19429319336561535, 0.1877978989521243, 0.1785085570916235, 0.1556270295679828, 0.13378517994801964, 0.16406190852853308, 0.13696074549197457, 0.18032783842937083, 0.1859031552292738, 0.14146664781226193, 0.21971897625342607, 0.1741506572410988, 0.1499227177243605, 0.17080926068774993, 0.11112363148056481, 0.1190154750132375, 0.1412253379853834, 0.11775410732151925, 0.12207120100061652, 0.1485429245588772, 0.10131473059988472, 0.1360049047967108, 0.12806047683390864, 0.23886367222705607, 0.20449829742419634, 0.16489133784196108, 0.21923027280039553, 0.18153387583132352, 0.17839440753317626, 0.21649540264829426, 0.1898343226144663, 0.18722107975665025, 0.17676995745413426, 0.1762149378136021, 9.999999999998899e-05, 0.17356971686933398, 0.17518778781644218, 0.16890740261341175, 0.19502655946596337, 0.17803354391713855, 0.16972061266179572, 0.18645488272221822, 0.166332583534743, 0.12064963623013969, 0.2554031422965026, 0.1413628290649549, 0.16761605238072774, 0.13763329681120717, 0.15627049998098141, 0.390362347227026, 0.3618958516366453, 0.1822105133465144, 0.13647380562325984, 0.10558940715593912, 0.31810468543580284, 0.14966337655217976, 0.11379630800063911, 0.1144183796691215, 0.1677470486718916, 0.21833683230987966, 0.1955787570508163, 0.21596143832391024, 0.220560184355305, 0.1968155544148622, 0.20094108170820058, 0.2145614205934404, 0.1968503578486167, 0.1945240144605388, 0.09287893759740506, 0.08162495146553861, 0.06724219647558383, 0.07282664757031232, 0.07094918309784404, 0.06811272177582106, 0.07374352303089782, 0.06850178277330199, 0.07513486467781127]}, "mutation_prompt": null}
{"id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.19498415766430902, "feedback": "The algorithm IslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "82f81de4-aae5-498f-bf39-8ab94002356f", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "8d143322-c058-464c-b7d5-cee46605bb56", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "20fd5703-b748-4ecc-a2be-84a6eee3871e", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "670c05b7-1b0d-455e-b7bd-32ab2fdf2353", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "d62c49b1-b1a3-4537-aab8-3ffc03d22a4e", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "6d125f11-3846-4409-976a-bf96634af475", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "385dd681-df22-4982-bc55-ad4b0514a5fb", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "7595eb53-d5ab-4fef-8d18-f40dc3a3c315", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "da2cb71e-4125-4982-9c93-64badbca98f6", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "f115d4d3-5320-4daf-9911-e0d9ca50b8e1", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "00e0851b-cd76-4b82-ac67-5e71c5cd6909", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "daaa092c-3f92-4c32-a957-9b793e99df02", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "caa3f979-d6fe-444a-99da-b977c888f22d", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "c3bdce59-25b6-45ea-9d34-1c662c111df7", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "f6b3360a-bf5f-4439-afcf-23a34d1bef07", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "e260d18f-cd10-4fc2-aa49-90c330188de1", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "e2186280-2478-4136-a377-596153d8fa2d", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "0bb8387a-38e9-465f-8bd8-d0ade89cfa0b", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.inertia_weight = 0.9  # Added dynamic inertia weight\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                random_neigh_idx = np.random.randint(island_start, island_end)  # Neighborhood learning\n                self.velocities[island_start:island_end] = (\n                    self.inertia_weight * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.positions[random_neigh_idx] - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n            self.inertia_weight = max(0.4, self.inertia_weight - 0.005)  # Update inertia weight\n\n        return self.global_best", "name": "IslandPSO", "description": "An enhanced cooperative island model-based PSO utilizing dynamic inertia weights and neighborhood learning to balance exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.17001974391791774, "feedback": "The algorithm IslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.3629089485665994, 0.34628042611249654, 0.26645291029108664, 0.2918904844404825, 0.27159225915184537, 0.1869198961342473, 0.14863379203212224, 0.2924731618302492, 0.3458176235976633, 0.06554436923348717, 9.999999999998899e-05, 0.04695299926137397, 9.999999999998899e-05, 0.05308490759771034, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11708465642980115, 0.10789915704469188, 0.11312890846668744, 0.11403917596084068, 0.06467619684140058, 0.11467793407296123, 0.13579258251750603, 0.1224441478268905, 0.08956488411254881, 0.05606816983615681, 0.028948640114589752, 0.07619167569752006, 0.078938889537571, 0.05702469963683543, 0.10133786543839729, 0.0761527212864388, 0.027429986980809895, 0.08138381112469928, 0.9885889748505984, 0.9854270602451896, 0.9743352269179031, 0.9794928383546047, 0.9760892045270597, 0.9812014056373197, 0.9774740730569142, 0.9730973751140288, 0.9847098276135219, 0.14823101041148035, 0.08921974674614142, 0.05460834907035772, 0.08704441144482922, 0.060376705567594446, 0.13567495148888342, 0.14670035979983098, 0.050989580946930846, 0.09541037672101971, 0.16233263544722398, 0.12915106387783815, 0.1668892540562973, 0.2738554415104901, 0.13479282693243566, 0.11973269988385205, 0.1085107610870788, 0.12408590709509704, 0.16407189003188272, 0.14457517302596534, 0.028347207144186592, 0.06320129143060205, 0.21272128137837854, 0.1292789876939925, 0.010253042962442338, 0.03966454875500802, 0.11880098352683377, 0.022746730502994583, 0.13338604898596118, 0.11533292183759403, 0.12362631361902843, 0.13353713593008598, 0.12987587874671536, 0.0033099935211771125, 0.1508934925555836, 0.09682435246821752, 0.10522682820075113, 0.012819070724130355, 9.999999999998899e-05, 9.999999999998899e-05, 0.04865964091079167, 9.999999999998899e-05, 0.008624056135003388, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04895883223654818, 0.07075903533568562, 0.08076918919411724, 0.02957511383788769, 0.07502657962122317, 0.08100386072449384, 0.09795014276355851, 0.05937870420503355, 0.08898899711103969, 9.999999999998899e-05, 0.07919944376573418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013113370697759974, 0.0009583539835573696, 0.04316461364500357, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002492214287409089, 0.07364432021455636, 0.2781824513342913, 0.19332264361703932, 0.22815720393005745, 0.340802368456515, 0.34908466047735354, 0.3099680007225828, 0.3183210517860794, 0.23879409153990983, 0.29519969559711345, 0.05664210690057547, 0.06253360944267061, 0.08624791336003856, 0.07020621636987201, 0.0628993189381648, 0.12658138001987396, 0.07236811686600608, 0.07034615088629814, 0.0648422729349708, 0.16114286309839876, 0.20033333004603526, 0.19664970888857058, 0.1779661651311899, 0.17419632743249092, 0.18339707264410265, 0.19418494599801328, 0.1939959916625591, 0.22283679081812147, 0.17491309943151845, 0.1376045051061272, 0.20439839062351384, 0.19535083786139884, 0.2433984804489645, 0.20298679084394688, 0.18199169476587063, 0.27016432243276145, 0.19643320963237743, 0.1187619435458831, 0.07377593686800787, 0.17481465569392984, 0.1552436564106776, 0.1677925913131585, 0.16653677215939555, 0.2480096515610939, 0.18709315583674424, 0.1445410820987323, 0.25081234304659716, 0.23111352499252846, 0.19800709652756487, 0.2012214178610089, 0.1691718794942717, 0.20592268985666906, 0.24278029269486057, 0.2555125646308818, 0.20591540745912051, 0.18851740478136447, 0.17403630701234651, 0.18191567481081505, 0.20504845037276986, 0.1916486788379983, 0.19228123983792722, 0.21150700940191647, 0.18075867537412127, 0.17492288266101164, 0.20160864633895825, 0.1684921207306097, 0.22063793903342122, 0.27353194669432346, 0.16589665320576163, 0.1622977585940777, 0.26980756272324913, 0.1668170394037637, 0.47470110534106247, 0.3873811953622073, 0.17242609734746617, 0.1171798582400545, 0.4242605948445596, 0.1805536638186409, 0.1265623448070362, 0.19131858019815395, 0.1651759554433727, 0.18452894489693816, 0.21679167644579134, 0.21915105040385296, 0.19656957536087927, 0.21629584602348506, 0.2053830091227713, 0.21330631376641707, 0.2410476051378576, 0.21186277071180926, 0.20636001581533314, 0.09769560522620413, 0.0836494243265995, 0.09473952663593066, 0.09567085555412325, 0.10916938678074495, 0.11592864313860174, 0.0974386589189804, 0.0873844104662388, 0.13601794893301355]}, "mutation_prompt": null}
{"id": "cac1b191-8b3f-48c9-81c1-82617bb5a820", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "91f13d64-2ea7-4889-b3ac-cc9d26047bb1", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "db4aeb99-4b4a-4aaf-8015-8f6a90ff3efd", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "6e5e6f1e-b9e8-4ffc-8f92-e31bda178cd4", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "36728992-9181-4c66-92c4-a0f0f33094e1", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "127c44c4-fbb4-4bf1-a88e-e73ae78f8726", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "47780d37-17d6-4c3b-8ce3-2accdecec846", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "5d076864-d7b7-4a03-9341-be5802d642e7", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "382a5996-9502-4fdc-be7c-1a32e0701295", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "01ef7a95-d40b-4137-8e54-cba699b564f4", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "85d331f6-90f0-488c-b418-f80d1e2358c9", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "5282d3ea-f276-474a-a8cc-484f7e833864", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "e4a726dc-8c10-46c3-a821-8cc8ccabbf0e", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "9665f288-fa28-4005-950e-b19589b38f35", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "c0f245d2-9067-4e87-9c5c-0c148b161088", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "ac55f47e-4e49-4e67-aafd-52aaeda01ec4", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = self.calculate_island_size()\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def calculate_island_size(self):\n        return np.random.randint(3, 7)\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n                \n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                inertia = 0.5 + np.random.rand() * 0.5\n                self.velocities[island_start:island_end] = (\n                    inertia * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * np.random.rand() * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n        return self.global_best", "name": "IslandPSO", "description": "IslandPSO with adaptive island sizes and dynamic velocity adjustment for improved exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {}, "mutation_prompt": null}
{"id": "b438a306-968a-4d49-9d26-4f5b72c531ef", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "ed30c704-1536-45f4-94f8-221f8bb67654", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "7f082880-64b1-4beb-97c2-c46fed795262", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "30ba733f-d9b2-4e08-9f9e-d9a20a995adc", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n                \n                if self.func_evals > self.budget * 0.7:  # Introduce strategy change\n                    restart_indices = np.random.rand(self.island_size) < 0.1\n                    self.positions[island_start:island_end][restart_indices] = np.random.uniform(-5.0, 5.0, (restart_indices.sum(), self.dim))\n                \n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.5 * island_velocities +  # Adjusted inertia weight\n                    1.4 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.4 * r2 * (island_best_position - island_positions) +\n                    0.3 * r3 * (self.global_best - island_positions)  # Increased influence of global best\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.15  # Enhanced crossover rate\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities, enhanced crossover, and random restart for improved diversity and convergence.", "configspace": "", "generation": 38, "fitness": 0.16924098160191642, "feedback": "The algorithm IslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.12.", "error": "", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.4300317812638512, 0.49847287909243265, 0.3343411244151301, 0.27788102704278894, 0.361779299351799, 0.20745996754519525, 0.3279286702178347, 0.411299366854746, 0.2995626630434135, 9.999999999998899e-05, 0.0017425333274724286, 0.00028016331286018215, 0.05506879446981361, 0.004899025116271383, 0.14439965494884222, 0.004351927112564269, 0.003140121171811061, 9.999999999998899e-05, 0.10747396766155648, 0.09110752473273409, 0.10177198200372173, 0.12411218452229567, 0.10553120791221049, 0.07480277931737833, 0.11466159546552057, 0.09592978646441519, 0.05851006732388775, 0.07199237405851633, 0.09289194928040212, 0.10250297682048115, 0.0754514142887347, 0.043124304399121294, 0.08939379159333416, 0.13443828138443603, 0.11747127485291198, 0.10138953453184807, 0.35527073819175425, 0.4314343052416715, 0.3245227869322078, 0.4521634486110021, 0.35923612071556776, 0.3527301380205179, 0.374966096930215, 0.3564217359924653, 0.35722971027062134, 0.15960658153767704, 0.07671077408450167, 0.1199953498847115, 0.13872960510761245, 0.09657835998379904, 0.10643293774598173, 0.14003968019687785, 0.12702932744245443, 0.22083527824878446, 0.24039494704852638, 0.17880626243620568, 0.1936147373789633, 0.2828657589488883, 0.3975876816666467, 0.11874267338527589, 0.15637634320597227, 0.1670972561173638, 0.1832407762868251, 0.08727155987887292, 0.13162304836037053, 0.029545836273785264, 0.044209428875845, 0.03078010716880286, 0.14100901355613027, 0.05062418722558537, 0.1549065264533549, 0.09030658562483274, 0.1594525459621443, 0.10226158294698873, 0.22053186890189735, 0.07483560586850868, 0.14542806297171118, 0.131583781153505, 0.14831382123790082, 0.13362464286691322, 0.06730191053755985, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012273613640936265, 0.15580586324583945, 0.13784459517603354, 0.1099131493524943, 0.06021633680704708, 0.030982819441747966, 0.09024745709355741, 0.09983275599441566, 0.12086078782430343, 0.18135742932382526, 0.00028948263601091817, 0.06686759035390899, 0.06609947867536281, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12757078402166422, 9.999999999998899e-05, 9.999999999998899e-05, 0.1284404213747331, 0.02771897764725162, 0.08875388882667246, 0.02264973645002666, 0.023439991555521233, 0.14641528542035998, 0.036772980158742974, 0.1062239445637726, 0.08769435448907481, 0.30772335461025513, 0.39269305529148024, 0.38195804129109545, 0.31091023612253277, 0.2976929483231825, 0.3760238228771896, 0.4370517188520414, 0.29111500023940606, 0.3302845678233449, 0.07942227177719563, 0.08545531774306914, 0.08110148025331942, 0.13386978898041124, 0.07658631391925941, 0.12317462943289614, 0.0609225795714583, 0.11814397091746542, 0.06355127857787102, 0.1708997409026961, 0.16852718382536713, 0.1853581657235005, 0.16953091770539008, 0.2385744298780611, 0.18168794644111363, 0.20658859864097512, 0.19823736850935902, 0.23862746206070629, 0.26607469846978693, 0.14537518303428865, 0.2768918016829027, 0.18896446343973072, 0.19533199514338662, 0.29449108182595696, 0.207788168576848, 0.197894505649158, 0.24619557206113774, 0.36387484690343497, 0.11557100067988535, 0.22144664796548208, 0.23032748274318005, 0.1783826869156906, 0.3078747637796577, 0.1675479655937765, 0.236698981479618, 0.20753106644993802, 0.26728190777651917, 0.21665144572937212, 0.24773293372287541, 0.25649797304534006, 0.189516616494542, 0.22948224554395824, 0.26219431854419173, 0.24517506749458085, 0.22153240510393668, 0.198576934784781, 0.24717923533637387, 0.1771699974576153, 0.19787006791598327, 0.18146236876944788, 0.19230540382433425, 0.1748546557743914, 0.19455549376512338, 0.17675443907141142, 0.1877320982817955, 0.2330752181236767, 0.16386107004365313, 0.5559754446920899, 0.16616184035347525, 0.29767106290272405, 0.3205164793408468, 0.18945734910173373, 0.4515087462098596, 0.3531601813661721, 0.17758170604286783, 0.3060288050945311, 0.39699562514235054, 0.24572552079601395, 0.13729743422944507, 0.12418833938921492, 0.17587013819380248, 0.3525562683546636, 0.2018731930472767, 0.1992421077085268, 0.18691910779473508, 0.18442728267864805, 0.22188751871092616, 0.19234611143879887, 0.20768122553717416, 0.22687815000129996, 0.20993063289850855, 0.10983808999896061, 0.10109335993237112, 0.10471051137945941, 0.10110966853537307, 0.09914617582457286, 0.10749895650553065, 0.08034176656033087, 0.08284243070603858, 0.07596280208262451]}, "mutation_prompt": null}
{"id": "dea3bf3d-1338-485e-be6c-fdc48c0175b6", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "0f782f5c-367c-4cc5-a323-8e3906731601", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "ead79ee9-f6e0-4fc0-a392-dd88e5ec6d72", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "9453d52e-6bb7-4c13-8aa1-b715574466e1", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "997f9660-8d18-4b62-a99b-28ab17af116b", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "1e6ebf53-9876-4522-85d7-fcd2feb6f04f", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "54868ad3-0b49-44fa-a7e6-c44cb22662b0", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "e788177a-f29c-4286-93a9-7982e9891e2a", "solution": "import numpy as np\n\nclass IslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_position = island_positions[np.argmin(self.personal_best_values[island_start:island_end])]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    0.6 * island_velocities +\n                    1.3 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    1.3 * r2 * (island_best_position - island_positions) +\n                    0.2 * r3 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n        \n        return self.global_best", "name": "IslandPSO", "description": "A cooperative island model-based PSO with adaptive velocities and crossover operator for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.5380561024066494, 0.5919896216423535, 0.9164205916763719, 0.41993150294937076, 0.3811055365932151, 0.18774804681143253, 0.3770572331827742, 0.756920837141029, 0.24610487921963675, 9.999999999998899e-05, 0.07866484408537999, 9.999999999998899e-05, 0.16893243447813422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06305494159661684, 9.999999999998899e-05, 0.11047057934089322, 0.12395232767172493, 0.14645248603056482, 0.13480030724586123, 0.1169740866641783, 0.07705384150311567, 0.1386332540407238, 0.09679310159881338, 0.09060488876121886, 0.08729818591457861, 0.0594170617299411, 0.10402938560812891, 0.10136252462390749, 0.08381326982354587, 0.07535339700929689, 0.13509322272391655, 0.08849425818904388, 0.09663101397782814, 0.15903000424516578, 0.9791303875604902, 0.08674466718760432, 0.9744453629305065, 0.9596097338858353, 0.10723944471937286, 0.34914430715836053, 0.9596600566531142, 0.30243540920766887, 0.18245972430407942, 0.06415695169863322, 0.05732479386450717, 0.1951489664271694, 0.06802261845757962, 0.1771753705808904, 0.2715918318490309, 0.15564816085720268, 0.2507702378096208, 0.17050140602483876, 0.22744362145623953, 0.23079599037970577, 0.21615912390292735, 0.2863090358515976, 0.20346290567723468, 0.2460502426438862, 0.23178272362852348, 0.33677297849999754, 0.14618276465255642, 0.13552147731914632, 0.007096155346102195, 0.11857650518109042, 0.12843524317142907, 0.13168523944175192, 0.15797753411074122, 0.1574088096825471, 0.08552105756111017, 0.16944700360695386, 0.2497213590185413, 0.13632239212930686, 0.13274173106986276, 0.13663061192078751, 0.13875900195439772, 0.16041063349440232, 0.09884523223019148, 0.15149147758802228, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017568602503495123, 9.999999999998899e-05, 0.024428013856856667, 0.0420178557186095, 0.008179495233875622, 9.999999999998899e-05, 0.10382215414142282, 0.2055243464198171, 0.13317854534482398, 0.03242123978018974, 0.035246946281178526, 0.08885529525737179, 0.08720688554134193, 0.15525609512627014, 0.1948102080757773, 0.15897770568888214, 0.17612451131917406, 0.041182255400497914, 0.08290145980286268, 0.10091314319640055, 0.209887242112486, 0.04068709175129348, 0.12541746606832238, 0.0582756179219065, 0.10940813939784788, 0.13404579045377707, 0.03549532273328149, 0.05579748403104223, 0.04026134231038048, 0.1306563164402964, 0.060949807258684485, 0.2428219585466631, 0.11968786840591006, 0.2320343882883834, 0.3873887542901415, 0.2872200300662535, 0.4298331717652889, 0.3145043255009419, 0.3119348228839999, 0.5830278588105188, 0.47132678579422516, 0.5991947252283321, 0.08889372273682072, 0.08206349617097708, 0.0764656851135378, 0.11899895956093876, 0.10433562023822163, 0.1168271956595579, 0.09024573470896557, 0.11024199330035322, 0.1483237790841324, 0.23086170935784966, 0.2109926180586439, 0.18953006933815564, 0.19576874026457458, 0.2752177413975312, 0.22934399446497933, 0.1716800855084748, 0.20458852462447508, 0.2929366847931705, 0.34564492546122594, 0.16540070304239163, 0.21361714774113794, 0.29246392094179385, 0.25121953034682865, 0.229480929816946, 0.21360205768639084, 0.2637388872337658, 0.2609678559940194, 0.21763461013989904, 0.2092427895869977, 0.1846000662561279, 0.27432012695123864, 0.3022592779698421, 0.3263316326275334, 0.19588752916856167, 0.24723601323345634, 0.24584876717616166, 0.2407906397881513, 0.25183052542806195, 0.2654839651955454, 0.25964277498127286, 0.2341610193645619, 0.2178002824779467, 0.23074322441152684, 0.23891717531165235, 0.25568850998665404, 0.18023742912079432, 0.19636496496197897, 0.18593057019450032, 0.18107513164466793, 0.17338295355421107, 0.18393864659034076, 0.17343103690746142, 0.20507808600500121, 0.19397119776553784, 0.1829940824682379, 0.186123464856498, 0.13941181385143886, 0.173571126761071, 0.16452320952078336, 0.15094212697010212, 0.18659737080943162, 0.18870640719300869, 0.7679110842207094, 0.5530138598271634, 0.21925895258911354, 0.15923035223260484, 0.27661445605714585, 0.14593655765614988, 0.10851872635473447, 0.16602719256102205, 0.1273810214973803, 0.18983578413373503, 0.18851631573834893, 0.20310085026993774, 0.20550533280877803, 0.17336443271715596, 0.23280956743024628, 0.2352391768546538, 0.2133368347739325, 0.2053468123911344, 0.20087916770462466, 0.07834254322539635, 0.0805726470083713, 0.08859998694258775, 0.08444647733604083, 0.09462991507833163, 0.10536062242331445, 0.08334229857599551, 0.07208558986695845, 0.0846455154092689]}, "mutation_prompt": null}
{"id": "286ff4f7-8a43-45da-b2b3-1d8b70c61af8", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n            # Elitism: preserve the global best position periodically\n            if self.func_evals % (self.budget // 10) == 0:\n                self.positions[np.random.randint(0, self.population_size)] = self.global_best\n        \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "An enhanced cooperative island model-based PSO with adaptive learning factors and elitism strategy for improved convergence.", "configspace": "", "generation": 47, "fitness": 0.25172742996882796, "feedback": "The algorithm EnhancedIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "6f496a9b-a6cd-40f6-a316-5916143236bb", "metadata": {"aucs": [0.8452352512567061, 0.8732471297406627, 0.8201033884952769, 0.8445441280203818, 0.18889881986623325, 0.46478167756088873, 0.7512495152192662, 0.8550548140728971, 0.8635382804929148, 0.08613833675792959, 9.999999999998899e-05, 0.6047929381706582, 0.09369503551136316, 0.20848401555510787, 0.30772186997526074, 0.37660774526301055, 0.013813149382998602, 0.048440527149330226, 0.11105931878052488, 0.12982304470019257, 0.14402874071350247, 0.1429401455588557, 0.06323550542062295, 0.11521784905599419, 0.13629613233975446, 0.12375360839582772, 0.09104033709969916, 0.0863648686134233, 0.08609686559953023, 0.1077825365179167, 0.09446422454830405, 0.09461414432403636, 0.11452755867522624, 0.1039107922495286, 0.09603937099586435, 0.13516499330578968, 0.9812889979407771, 0.9940281379629268, 0.9895757548982482, 0.9930896133732936, 0.09948218843800238, 0.9710744442583739, 0.9728266953658994, 0.9842374486911297, 0.993283702298299, 0.6965082772817854, 0.6338616109186406, 0.05734450734076402, 0.15442930727124116, 0.3425595309785048, 0.6185351808159532, 0.12413413761453318, 0.24294691309061822, 0.41943220412545645, 0.8746657857001743, 0.3618914942762188, 0.1536754548183784, 0.2807610302492972, 0.19363776057928428, 0.19278632026904174, 0.1511059720459178, 0.15133637070506034, 0.22359027020389233, 0.2586351952239332, 0.12931615436231336, 0.2836282772048375, 0.12880277718962319, 0.21735803801925402, 0.3621445104328904, 0.1262565964404142, 0.22541888640429453, 0.18019243501723303, 0.19405486840466124, 0.20818240616298966, 0.16197463593550143, 0.16137656346374496, 0.15340045360956467, 0.12839417710329093, 0.23082806171919068, 0.30638275433379003, 0.23863904325488328, 0.0016597980386937605, 0.002192029853579358, 0.02107117054381502, 0.10966344879520507, 0.045969656358515576, 0.012261177629646403, 9.999999999998899e-05, 0.0033962109680160113, 0.007108645657914359, 0.06828902544672366, 0.0758085568802861, 0.2117441669122675, 0.057286524149775864, 0.009116852830322375, 0.1225874556635439, 0.10510457864327216, 0.055859725822329676, 0.04040304429041697, 0.04627763896141679, 0.13244673553853858, 0.037789380871174894, 0.11203846385961547, 0.0773931863378493, 0.06609680814940311, 0.06798481377677112, 0.09856585495752501, 0.07098402926754299, 0.32017140265096833, 0.04318392178612651, 0.05419001426286063, 0.07416614532815802, 0.05395164155800225, 0.08112843328139241, 0.12357492865494657, 0.08329628469546457, 0.07967908823093495, 0.5977763927831088, 0.5077290716670403, 0.5494399125529227, 0.49168858535834326, 0.5659841665942755, 0.4282481108094326, 0.5719260933914561, 0.5520138782660812, 0.5433479250528757, 0.10650023255620966, 0.08243842743987784, 0.09831298752885576, 0.10109340349584639, 0.07690531791799893, 0.12184020157100672, 0.09086783253843589, 0.10572437760962261, 0.10834115306648673, 0.3821410476792687, 0.22500247732278644, 0.25586648080826446, 0.18446663259104656, 0.19796080641510838, 0.2807949834629728, 0.23329626504110135, 0.23688956437268427, 0.3048428444351259, 0.23744747293498958, 0.2565940034986154, 0.3796404568998799, 0.21521264938073914, 0.35945297350433736, 0.28231206054292, 0.21382896686979125, 0.34774049689883624, 0.2745500575027304, 0.1732542375706133, 0.08422496935196377, 0.28847084803953826, 0.2576504231952521, 0.148982193213959, 0.2055221835419221, 0.18701809397655866, 0.23758290262305992, 0.15914028134922542, 0.2482166838246347, 0.26564331946233366, 0.23737658147023488, 0.20583174761036793, 0.22892729942625012, 0.20152702390673782, 0.21171550612175505, 0.23291702306026074, 0.23213442542584606, 0.21411149930755813, 0.2147357515332502, 0.1903666932525646, 0.22633997482230483, 0.19943533135957192, 0.20669096789193075, 0.2105847042527672, 0.25203177521746567, 0.18103194774730658, 0.21213649948256652, 0.1437900005592333, 0.16698945104465734, 0.17315777459660897, 0.20099053804271594, 0.16673628810372376, 0.14280489880088698, 0.17810255289837296, 0.840610541282619, 0.818782101139474, 0.2111028518349164, 0.9207929999560923, 0.16236502665385155, 0.21240726700841905, 0.15126642361610376, 0.09404769049657391, 0.10389703187055455, 0.20277450141180975, 0.1920447088774857, 0.19295638529393544, 0.2021103290562979, 0.19924848792433603, 0.1967449643364334, 0.19911383641571911, 0.21328159729905827, 0.20936596640783733, 0.19853402215782312, 0.10481487431543124, 0.08908219160157371, 0.10146337739025335, 0.08712765026912983, 0.10312582893191846, 0.07121852415800134, 0.09328562046585653, 0.09700810878862909, 0.10773881602902569]}, "mutation_prompt": null}
{"id": "6958e7c8-5659-4718-9264-2c7910c3ea82", "solution": "import numpy as np\n\nclass ImprovedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.mutation_prob = 0.1  # Added mutation probability\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.15  # Updated crossover rate\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                \n                # Adaptive mutation strategy\n                mutation_mask = np.random.rand(self.island_size, self.dim) < self.mutation_prob\n                self.positions[island_start:island_end] += mutation_mask * np.random.uniform(-0.5, 0.5, (self.island_size, self.dim))\n                \n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n            # Elitism: preserve the global best position periodically\n            if self.func_evals % (self.budget // 10) == 0:\n                self.positions[np.random.randint(0, self.population_size)] = self.global_best\n        \n        return self.global_best", "name": "ImprovedHybridPSO", "description": "A hybrid PSO with cooperative learning and an adaptive mutation strategy to enhance exploration and convergence.", "configspace": "", "generation": 48, "fitness": 0.21892413507117603, "feedback": "The algorithm ImprovedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "286ff4f7-8a43-45da-b2b3-1d8b70c61af8", "metadata": {"aucs": [0.44926130310605417, 0.427335477942975, 0.44127090419605, 0.43282789477500927, 0.42697749645374616, 0.4602220715934019, 0.4781638575881286, 0.4498954025585157, 0.4513807755155862, 0.0461768828805853, 0.027818871701394188, 0.0037473685254666433, 9.999999999998899e-05, 0.052619376117459815, 0.009421305218670573, 0.02678813284697812, 0.05675605801235872, 0.05314554254241555, 0.10851464104869413, 0.10188580011111681, 0.13303896401086746, 0.11332665481579529, 0.08657190910848023, 0.1267764668888003, 0.10583814068779207, 0.13203400745518845, 0.12872465227531593, 0.07971305883951885, 0.1082870228882501, 0.0933822235101367, 0.13050344025983363, 0.08741775124162654, 0.11680833667244495, 0.09459637406519084, 0.1042648505344097, 0.09570117016126956, 0.9896966771834456, 0.9923168419406979, 0.9837022162539628, 0.9929992738255388, 0.9526156931825349, 0.9566959990863148, 0.9758640976481369, 0.9835575231922606, 0.9927887133220739, 0.322755762825258, 0.2783655802800413, 0.2792936589263295, 0.32720056383238527, 0.2887409159742208, 0.27191474322053477, 0.27692993908086805, 0.282167189668863, 0.2830933359511233, 0.2464221693703904, 0.3163781464104496, 0.6225114075886872, 0.28174192386398855, 0.26919220641882424, 0.24947369296578226, 0.2555668617732514, 0.31193976256825995, 0.3474429568152948, 0.1709140364057251, 0.1144307476551274, 0.15361084970175287, 0.1284150618903237, 0.1856690510033192, 0.18877740003949883, 0.13125308851905682, 0.1529337474269823, 0.1262440609253288, 0.15837285391604472, 0.14089842066223246, 0.1573847947598046, 0.12480131012566853, 0.15200730739553803, 0.16437306399222784, 0.14897374454039292, 0.12892516781945307, 0.17522405081709658, 9.999999999998899e-05, 0.017114037977884022, 9.999999999998899e-05, 0.07560651934813689, 0.03129442636165336, 9.999999999998899e-05, 0.01960247999402831, 0.004698741190712452, 0.019898658355746, 0.10569656957314111, 0.049073403049954, 0.10278506231463702, 0.02846372635036587, 0.0686593277358305, 0.09607601891400697, 0.04773745107582983, 0.04795805115839358, 0.0527174330138479, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05409732288381952, 0.07090904884093963, 0.07162332617137379, 0.10220979087767301, 0.08445224548635122, 0.07972280575594992, 0.08921054706372145, 0.11418706642069043, 0.050772765176697376, 0.43625335212714367, 0.41047494128566486, 0.41432820012506744, 0.38498691915535643, 0.4033243063361214, 0.4277694041468507, 0.4285959612906701, 0.3921284599934308, 0.41313160460436427, 0.13186350844861627, 0.0693517291837854, 0.08557249756932905, 0.09199863119030016, 0.04658635487951157, 0.1192246764428413, 0.13588772079078792, 0.12612378926179868, 0.16446907199808047, 0.18687498693417326, 0.21901480936085715, 0.1801956103356278, 0.24168243894517172, 0.2092979209158884, 0.2556055130887316, 0.15673121981293536, 0.27819623027400064, 0.17319107990116445, 0.2243378397043969, 0.26423071944833465, 0.28973674586100406, 0.29345737606385003, 0.24193618300544717, 0.2877560545881451, 0.2906307364370905, 0.28673178026072077, 0.2814510917487373, 0.2072554079962905, 0.09519494066853473, 0.24223138396166743, 0.18334672335002233, 0.23587259645986192, 0.18949162453071045, 0.18123716806932488, 0.2425508955396417, 0.21920276499554325, 0.22588635429691983, 0.19573245410002793, 0.2428837932922091, 0.2115815252474751, 0.20846675714702068, 0.21927065358111053, 0.21723583845849248, 0.24396822804365526, 0.23978239807479618, 0.21036652474950734, 0.2141374000893831, 0.1999109015529178, 0.20261371003110606, 0.227123757412515, 0.21505860477252525, 0.20474025228665338, 0.18207074442803473, 0.24002425058778332, 0.1231374804380706, 0.1573735342679281, 0.16634435102652356, 0.608649969585589, 0.20153996866369184, 0.16214605349593836, 0.6788086562233542, 0.17679622043666354, 0.6649379991685671, 0.5471590232156287, 0.21049808199060527, 0.616693763558013, 0.1563607596940506, 0.21051284541319715, 0.15397910539283166, 0.09392219257613232, 0.15652862016789093, 0.21296975342552737, 0.19186022289021587, 0.18160780903969143, 0.17916914993014976, 0.18787721913238697, 0.19949826631666967, 0.17842125227767824, 0.18132079195526063, 0.17328624056632247, 0.18049700737553342, 0.09562223056793828, 0.08773862380842423, 0.0945935256972198, 0.10186687762836444, 0.08953533437030725, 0.09859471056536917, 0.0971677518324282, 0.08802998127534323, 0.08056306015878012]}, "mutation_prompt": null}
{"id": "04395e34-075b-4f33-8f9e-49d414f93bf8", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.initial_temperature = 1.0\n        self.temperature_decay = 0.95\n        self.c1 = 1.5\n        self.c2 = 1.5\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            temperature = self.initial_temperature * (self.temperature_decay ** (self.func_evals / self.budget))\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] *= (1 - temperature)\n                self.velocities[island_start:island_end] += (\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n            if self.func_evals % (self.budget // 5) == 0:\n                island_comm = np.random.randint(0, self.population_size, self.island_size)\n                for i in island_comm:\n                    if np.random.rand() < temperature:\n                        self.positions[i] = self.global_best\n                \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "An adaptive island-based PSO with simulated annealing-inspired temperature regulation and dynamic communication for improved exploration and exploitation balance.", "configspace": "", "generation": 49, "fitness": 0.08517294508320555, "feedback": "The algorithm EnhancedIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "286ff4f7-8a43-45da-b2b3-1d8b70c61af8", "metadata": {"aucs": [0.18018480839350048, 0.19040839501706164, 0.14357892140784312, 0.1442784904577491, 0.09447260028949223, 0.09052656922667879, 0.08241656854954527, 0.16903576323831548, 0.12421114522510013, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04452213180416442, 0.03665794215465157, 0.058191989384206, 0.05280832856270701, 0.02682495421424369, 0.024287277022349008, 0.039424013275721204, 0.05728403935084081, 0.016013583813962895, 0.02634566987233955, 0.016968097070729327, 0.031501870115449804, 0.035381471588652125, 0.014250266082004637, 0.02615918261453154, 0.04545547243906167, 0.047596117596044096, 0.019034896934042256, 0.07379341463183442, 0.17786966689156436, 0.029498696145962122, 0.10644369656810082, 0.04057747641562759, 0.07744987310320917, 0.07316885828307895, 0.05570135491697126, 0.11794882805805751, 0.1064855213778767, 0.027419554708875138, 9.999999999998899e-05, 0.009627659620595863, 0.004764600733567548, 0.013235923536860317, 9.999999999998899e-05, 0.061581906387360275, 0.08060073240588972, 0.13841996665420975, 0.14049947246190442, 0.10648325120645152, 0.28599444792039175, 0.17642059473700922, 0.04109928093331039, 0.06326173474242569, 0.047874839239715805, 0.11828277158681999, 0.016684385606341334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023141165921797047, 9.999999999998899e-05, 0.10306917943019633, 9.999999999998899e-05, 9.999999999998899e-05, 0.09465166721700757, 9.999999999998899e-05, 9.999999999998899e-05, 0.03869877288695056, 9.999999999998899e-05, 0.06747798860366216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02800341275518381, 0.035583220200073096, 0.06079640309625045, 0.011536488396726274, 9.999999999998899e-05, 0.03987501867218801, 0.028540878364236577, 0.12659057401975993, 0.08682624256899585, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15480049321020994, 0.34419621484936225, 0.21491682302446213, 0.13162528738482304, 0.15351760235444967, 0.13603123852590393, 0.26687462470406176, 0.1462540602872503, 0.17369313053847368, 0.05726213468261376, 0.003667743486125641, 0.04189385358042341, 0.06308688762305426, 0.020967172592746053, 0.041057322500642424, 0.042926376703884994, 0.021129094207564036, 0.008497885540975636, 0.09802348760537771, 0.1087990390036353, 0.1557558894128248, 0.10251263362494378, 0.12485415891654461, 0.08560980747944558, 0.15102307657850111, 0.12712347558801174, 0.07308324135180211, 0.1481275361320491, 0.1280291239524144, 0.1637049756660479, 0.1630186938417828, 0.16324947336143503, 0.18056349370856006, 0.15438023891696862, 0.20334795868089683, 0.199464245007143, 0.12148074866611336, 0.05139638461189555, 0.10869521140065064, 0.15031402287630113, 0.10715775891173929, 0.10985761246059844, 0.12383601625803675, 0.15476858444380237, 0.09452280659052181, 0.2271008642540846, 0.1550929347762221, 0.19454256252644908, 0.23219800890789188, 0.2397803705499577, 0.2076637206381784, 0.20758965906295312, 0.1840717899899409, 0.229195878636119, 0.15530414472899212, 0.1697534748489603, 0.16314908307617204, 0.1587183887397614, 0.14786634834766665, 0.0611588751170592, 0.15379864373113683, 0.15837032867677248, 0.18094389488987805, 0.09869059047488105, 0.07424941327907142, 0.12216849583116074, 0.10565409552280458, 0.17977552850154133, 0.09920070196616504, 0.1265610724797117, 0.10262792624446049, 0.2940371824082455, 0.316798577139075, 0.15691775440257572, 0.10907341491730571, 0.106476124008127, 0.10128536443355673, 0.0953057737117029, 0.06663116624725207, 0.16112172322566398, 0.07941674582066083, 0.2095205764344632, 0.21852770514513886, 0.2123383951849862, 0.2672844117417954, 0.18771510589627582, 0.2154096379017566, 0.20358628430866121, 0.17257668243887414, 0.17569843454863454, 0.04285145696539838, 0.04516612559494715, 0.05922522160344945, 0.08071128980880948, 0.07476086718011699, 0.058425399421131674, 0.07632173891089455, 0.05792539135108632, 0.0630230638707222]}, "mutation_prompt": null}
{"id": "9166247e-ace8-4537-8c54-6efd54652134", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n            # Elitism: preserve the global best position periodically\n            if self.func_evals % (self.budget // 10) == 0:\n                self.positions[np.random.randint(0, self.population_size)] = self.global_best\n        \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "An enhanced cooperative island model-based PSO with adaptive learning factors and elitism strategy for improved convergence.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "286ff4f7-8a43-45da-b2b3-1d8b70c61af8", "metadata": {"aucs": [0.8452352512567061, 0.8732471297406627, 0.8201033884952769, 0.8445441280203818, 0.18889881986623325, 0.46478167756088873, 0.7512495152192662, 0.8550548140728971, 0.8635382804929148, 0.08613833675792959, 9.999999999998899e-05, 0.6047929381706582, 0.09369503551136316, 0.20848401555510787, 0.30772186997526074, 0.37660774526301055, 0.013813149382998602, 0.048440527149330226, 0.11105931878052488, 0.12982304470019257, 0.14402874071350247, 0.1429401455588557, 0.06323550542062295, 0.11521784905599419, 0.13629613233975446, 0.12375360839582772, 0.09104033709969916, 0.0863648686134233, 0.08609686559953023, 0.1077825365179167, 0.09446422454830405, 0.09461414432403636, 0.11452755867522624, 0.1039107922495286, 0.09603937099586435, 0.13516499330578968, 0.9812889979407771, 0.9940281379629268, 0.9895757548982482, 0.9930896133732936, 0.09948218843800238, 0.9710744442583739, 0.9728266953658994, 0.9842374486911297, 0.993283702298299, 0.6965082772817854, 0.6338616109186406, 0.05734450734076402, 0.15442930727124116, 0.3425595309785048, 0.6185351808159532, 0.12413413761453318, 0.24294691309061822, 0.41943220412545645, 0.8746657857001743, 0.3618914942762188, 0.1536754548183784, 0.2807610302492972, 0.19363776057928428, 0.19278632026904174, 0.1511059720459178, 0.15133637070506034, 0.22359027020389233, 0.2586351952239332, 0.12931615436231336, 0.2836282772048375, 0.12880277718962319, 0.21735803801925402, 0.3621445104328904, 0.1262565964404142, 0.22541888640429453, 0.18019243501723303, 0.19405486840466124, 0.20818240616298966, 0.16197463593550143, 0.16137656346374496, 0.15340045360956467, 0.12839417710329093, 0.23082806171919068, 0.30638275433379003, 0.23863904325488328, 0.0016597980386937605, 0.002192029853579358, 0.02107117054381502, 0.10966344879520507, 0.045969656358515576, 0.012261177629646403, 9.999999999998899e-05, 0.0033962109680160113, 0.007108645657914359, 0.06828902544672366, 0.0758085568802861, 0.2117441669122675, 0.057286524149775864, 0.009116852830322375, 0.1225874556635439, 0.10510457864327216, 0.055859725822329676, 0.04040304429041697, 0.04627763896141679, 0.13244673553853858, 0.037789380871174894, 0.11203846385961547, 0.0773931863378493, 0.06609680814940311, 0.06798481377677112, 0.09856585495752501, 0.07098402926754299, 0.32017140265096833, 0.04318392178612651, 0.05419001426286063, 0.07416614532815802, 0.05395164155800225, 0.08112843328139241, 0.12357492865494657, 0.08329628469546457, 0.07967908823093495, 0.5977763927831088, 0.5077290716670403, 0.5494399125529227, 0.49168858535834326, 0.5659841665942755, 0.4282481108094326, 0.5719260933914561, 0.5520138782660812, 0.5433479250528757, 0.10650023255620966, 0.08243842743987784, 0.09831298752885576, 0.10109340349584639, 0.07690531791799893, 0.12184020157100672, 0.09086783253843589, 0.10572437760962261, 0.10834115306648673, 0.3821410476792687, 0.22500247732278644, 0.25586648080826446, 0.18446663259104656, 0.19796080641510838, 0.2807949834629728, 0.23329626504110135, 0.23688956437268427, 0.3048428444351259, 0.23744747293498958, 0.2565940034986154, 0.3796404568998799, 0.21521264938073914, 0.35945297350433736, 0.28231206054292, 0.21382896686979125, 0.34774049689883624, 0.2745500575027304, 0.1732542375706133, 0.08422496935196377, 0.28847084803953826, 0.2576504231952521, 0.148982193213959, 0.2055221835419221, 0.18701809397655866, 0.23758290262305992, 0.15914028134922542, 0.2482166838246347, 0.26564331946233366, 0.23737658147023488, 0.20583174761036793, 0.22892729942625012, 0.20152702390673782, 0.21171550612175505, 0.23291702306026074, 0.23213442542584606, 0.21411149930755813, 0.2147357515332502, 0.1903666932525646, 0.22633997482230483, 0.19943533135957192, 0.20669096789193075, 0.2105847042527672, 0.25203177521746567, 0.18103194774730658, 0.21213649948256652, 0.1437900005592333, 0.16698945104465734, 0.17315777459660897, 0.20099053804271594, 0.16673628810372376, 0.14280489880088698, 0.17810255289837296, 0.840610541282619, 0.818782101139474, 0.2111028518349164, 0.9207929999560923, 0.16236502665385155, 0.21240726700841905, 0.15126642361610376, 0.09404769049657391, 0.10389703187055455, 0.20277450141180975, 0.1920447088774857, 0.19295638529393544, 0.2021103290562979, 0.19924848792433603, 0.1967449643364334, 0.19911383641571911, 0.21328159729905827, 0.20936596640783733, 0.19853402215782312, 0.10481487431543124, 0.08908219160157371, 0.10146337739025335, 0.08712765026912983, 0.10312582893191846, 0.07121852415800134, 0.09328562046585653, 0.09700810878862909, 0.10773881602902569]}, "mutation_prompt": null}
{"id": "91d054a6-b8ae-41b7-afd9-271659d0ceb3", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                dynamic_factor = np.sin(np.pi * self.func_evals / self.budget)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    dynamic_factor * (self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions)))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.3  # increased probability\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n            # Elitism: periodically introduce noise to explore new areas\n            if self.func_evals % (self.budget // 5) == 0:  # more frequent elitism\n                noise = np.random.uniform(-0.1, 0.1, self.dim)\n                self.positions[np.random.randint(0, self.population_size)] = np.clip(self.global_best + noise, -5.0, 5.0)\n        \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "An enhanced cooperative island model-based PSO with adaptive learning factors, elitism strategy, and dynamic island interaction for improved convergence.", "configspace": "", "generation": 51, "fitness": 0.16469380748759047, "feedback": "The algorithm EnhancedIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.15.", "error": "", "parent_id": "286ff4f7-8a43-45da-b2b3-1d8b70c61af8", "metadata": {"aucs": [0.6297212550452359, 0.3679760349139556, 0.4747700064941247, 0.4790791912567405, 0.24442796713864368, 0.38650278188147014, 0.37255784031878103, 0.47498171896886965, 0.3749766902258582, 0.00943151514683882, 0.028263891195012714, 9.999999999998899e-05, 9.999999999998899e-05, 0.09241207726594403, 9.999999999998899e-05, 0.009636004607186832, 0.10823780976438069, 9.999999999998899e-05, 0.08629552277818708, 0.06381148904449496, 0.0930038501506637, 0.10499544882693557, 0.03416151783043064, 0.05921472912019765, 0.06384198001006225, 0.08559287775095148, 0.06752189835389566, 0.04665305159159194, 0.03259046990857806, 0.06973306603509632, 0.044199236980723255, 0.04496406712297407, 0.07169185919982846, 0.09366364343321143, 0.07154763577456702, 0.01917616997919691, 0.6488560963640361, 0.7178620133369052, 0.6965574675968036, 0.6782010628854638, 0.7145603143974631, 0.6608217502394502, 0.6448429571504413, 0.7210294017443492, 0.614039516258023, 0.1742134228875497, 0.06577712407896397, 0.1777419334367074, 0.10680163966319345, 0.1119781949212807, 0.07809292807226653, 0.028095371398779045, 0.04662716007071599, 0.19371332370309924, 0.12323283050250011, 0.139819345526924, 0.09901093035551112, 0.17261251324778148, 0.05079708838754882, 0.16138798716842517, 0.06746167834648842, 0.2269222731349234, 0.17476753436205616, 0.28861621126346193, 0.07643496564380314, 0.007126925579381882, 0.11470869092400682, 9.999999999998899e-05, 0.20024431452861446, 0.11499614045769135, 0.13450755845905582, 0.09018376457098676, 0.23377120715986754, 0.12937468063403834, 0.10921571684723363, 0.04043214901967673, 0.06765829220470809, 0.10480362165468926, 0.12871815615272097, 0.09827473266647735, 0.1262112736742691, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02642819859612411, 9.999999999998899e-05, 9.999999999998899e-05, 0.12978532433677847, 0.10353343313423014, 0.10953054524150485, 0.051287131071171665, 0.03739671845623049, 0.05062657233374557, 0.08662211800503061, 0.11273344864394008, 0.10019044937891908, 0.09231880661223735, 0.036880430583771884, 0.06357497400423584, 0.05937069168654885, 0.05535629147551213, 0.0319836966411996, 9.999999999998899e-05, 0.22695466386183405, 0.08839245634704929, 0.06225332855522048, 0.1194950164651446, 0.05208233406583973, 0.024165002303493166, 0.05052038955231086, 0.05225935701693485, 9.999999999998899e-05, 0.07251493019995381, 0.05419829096675899, 0.3422105291280345, 0.45605757150575166, 0.28258382013268557, 0.23768854744516, 0.3262993105651949, 0.3954501267970363, 0.2975230081907675, 0.3373207305271382, 0.4590136016193074, 0.07042622873524595, 0.06565957357176433, 0.12193172921424045, 0.0829607933912816, 0.0644647211537338, 0.13088991398925787, 0.05113354816962978, 0.0976361700499272, 0.05837243683319593, 0.19123726628123072, 0.1468704691834315, 0.2570509126893389, 0.2510871297020105, 0.29821211818123516, 0.19386773534002366, 0.18065025340157603, 0.22884232061577747, 0.20592415556110932, 0.14735341405429225, 0.14966466002822143, 0.18162600277563834, 0.2354455619668282, 0.2149042244063718, 0.1684826059280018, 0.25021972695036077, 0.162546152211136, 0.1470428878694865, 0.14114986905690075, 0.1118020522703782, 0.14423085635154476, 0.151940593448061, 0.14844175632521706, 0.13939797929482434, 0.17285315740223595, 0.12224265229079867, 0.16622855552107763, 0.19118941022249714, 0.22860180722738366, 0.19816961993511728, 0.23008359815353852, 0.21970782589875826, 0.20445873221699107, 0.2263524857382211, 0.2188462235456935, 0.2026924053122272, 0.16605348797969743, 0.2009916026842411, 0.15374514773665127, 0.16135120720222462, 0.15568396753205893, 0.11961300888000737, 0.18263672472735282, 0.18519487720006622, 0.17553963964001995, 0.1214843559076988, 0.1811795976413928, 0.16387554218906952, 0.1615551221722048, 0.19200236102600055, 0.1137868698329777, 0.13895799518861263, 0.16347787616427378, 0.16605054396997732, 0.5277458396335357, 0.2087358655164534, 0.14345987212070355, 0.16695719795330966, 0.19993080922239903, 0.14597901256673085, 0.15637220620498515, 0.14842281607100338, 0.18870564415174407, 0.19701161426428448, 0.18779053533505008, 0.20062563984398363, 0.22317788632039648, 0.1920125259934764, 0.1940965125819406, 0.21897305454936467, 0.2316845035808235, 0.21888601271615382, 0.07623481914507124, 0.06904716663524779, 0.06636605570077225, 0.11534381450839504, 0.09068653896572254, 0.06446658612626377, 0.07926621339437356, 0.04941657911381825, 0.08355747072343822]}, "mutation_prompt": null}
{"id": "780b0396-7e81-4699-8636-38d4a757ca3c", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_start in range(0, self.population_size, self.island_size):\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n            # Elitism: preserve the global best position periodically\n            if self.func_evals % (self.budget // 10) == 0:\n                self.positions[np.random.randint(0, self.population_size)] = self.global_best\n        \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "An enhanced cooperative island model-based PSO with adaptive learning factors and elitism strategy for improved convergence.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "286ff4f7-8a43-45da-b2b3-1d8b70c61af8", "metadata": {"aucs": [0.8452352512567061, 0.8732471297406627, 0.8201033884952769, 0.8445441280203818, 0.18889881986623325, 0.46478167756088873, 0.7512495152192662, 0.8550548140728971, 0.8635382804929148, 0.08613833675792959, 9.999999999998899e-05, 0.6047929381706582, 0.09369503551136316, 0.20848401555510787, 0.30772186997526074, 0.37660774526301055, 0.013813149382998602, 0.048440527149330226, 0.11105931878052488, 0.12982304470019257, 0.14402874071350247, 0.1429401455588557, 0.06323550542062295, 0.11521784905599419, 0.13629613233975446, 0.12375360839582772, 0.09104033709969916, 0.0863648686134233, 0.08609686559953023, 0.1077825365179167, 0.09446422454830405, 0.09461414432403636, 0.11452755867522624, 0.1039107922495286, 0.09603937099586435, 0.13516499330578968, 0.9812889979407771, 0.9940281379629268, 0.9895757548982482, 0.9930896133732936, 0.09948218843800238, 0.9710744442583739, 0.9728266953658994, 0.9842374486911297, 0.993283702298299, 0.6965082772817854, 0.6338616109186406, 0.05734450734076402, 0.15442930727124116, 0.3425595309785048, 0.6185351808159532, 0.12413413761453318, 0.24294691309061822, 0.41943220412545645, 0.8746657857001743, 0.3618914942762188, 0.1536754548183784, 0.2807610302492972, 0.19363776057928428, 0.19278632026904174, 0.1511059720459178, 0.15133637070506034, 0.22359027020389233, 0.2586351952239332, 0.12931615436231336, 0.2836282772048375, 0.12880277718962319, 0.21735803801925402, 0.3621445104328904, 0.1262565964404142, 0.22541888640429453, 0.18019243501723303, 0.19405486840466124, 0.20818240616298966, 0.16197463593550143, 0.16137656346374496, 0.15340045360956467, 0.12839417710329093, 0.23082806171919068, 0.30638275433379003, 0.23863904325488328, 0.0016597980386937605, 0.002192029853579358, 0.02107117054381502, 0.10966344879520507, 0.045969656358515576, 0.012261177629646403, 9.999999999998899e-05, 0.0033962109680160113, 0.007108645657914359, 0.06828902544672366, 0.0758085568802861, 0.2117441669122675, 0.057286524149775864, 0.009116852830322375, 0.1225874556635439, 0.10510457864327216, 0.055859725822329676, 0.04040304429041697, 0.04627763896141679, 0.13244673553853858, 0.037789380871174894, 0.11203846385961547, 0.0773931863378493, 0.06609680814940311, 0.06798481377677112, 0.09856585495752501, 0.07098402926754299, 0.32017140265096833, 0.04318392178612651, 0.05419001426286063, 0.07416614532815802, 0.05395164155800225, 0.08112843328139241, 0.12357492865494657, 0.08329628469546457, 0.07967908823093495, 0.5977763927831088, 0.5077290716670403, 0.5494399125529227, 0.49168858535834326, 0.5659841665942755, 0.4282481108094326, 0.5719260933914561, 0.5520138782660812, 0.5433479250528757, 0.10650023255620966, 0.08243842743987784, 0.09831298752885576, 0.10109340349584639, 0.07690531791799893, 0.12184020157100672, 0.09086783253843589, 0.10572437760962261, 0.10834115306648673, 0.3821410476792687, 0.22500247732278644, 0.25586648080826446, 0.18446663259104656, 0.19796080641510838, 0.2807949834629728, 0.23329626504110135, 0.23688956437268427, 0.3048428444351259, 0.23744747293498958, 0.2565940034986154, 0.3796404568998799, 0.21521264938073914, 0.35945297350433736, 0.28231206054292, 0.21382896686979125, 0.34774049689883624, 0.2745500575027304, 0.1732542375706133, 0.08422496935196377, 0.28847084803953826, 0.2576504231952521, 0.148982193213959, 0.2055221835419221, 0.18701809397655866, 0.23758290262305992, 0.15914028134922542, 0.2482166838246347, 0.26564331946233366, 0.23737658147023488, 0.20583174761036793, 0.22892729942625012, 0.20152702390673782, 0.21171550612175505, 0.23291702306026074, 0.23213442542584606, 0.21411149930755813, 0.2147357515332502, 0.1903666932525646, 0.22633997482230483, 0.19943533135957192, 0.20669096789193075, 0.2105847042527672, 0.25203177521746567, 0.18103194774730658, 0.21213649948256652, 0.1437900005592333, 0.16698945104465734, 0.17315777459660897, 0.20099053804271594, 0.16673628810372376, 0.14280489880088698, 0.17810255289837296, 0.840610541282619, 0.818782101139474, 0.2111028518349164, 0.9207929999560923, 0.16236502665385155, 0.21240726700841905, 0.15126642361610376, 0.09404769049657391, 0.10389703187055455, 0.20277450141180975, 0.1920447088774857, 0.19295638529393544, 0.2021103290562979, 0.19924848792433603, 0.1967449643364334, 0.19911383641571911, 0.21328159729905827, 0.20936596640783733, 0.19853402215782312, 0.10481487431543124, 0.08908219160157371, 0.10146337739025335, 0.08712765026912983, 0.10312582893191846, 0.07121852415800134, 0.09328562046585653, 0.09700810878862909, 0.10773881602902569]}, "mutation_prompt": null}
{"id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n                self.adaptive_memory[island_idx] = np.mean(island_positions, axis=0)\n            \n            # Dynamic island restructuring\n            if self.func_evals % (self.budget // 5) == 0:\n                self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape) * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n        \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "Enhanced multi-island PSO with dynamic swarm partitioning and adaptive memory to improve exploration and exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.2705237474450398, "feedback": "The algorithm EnhancedIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "286ff4f7-8a43-45da-b2b3-1d8b70c61af8", "metadata": {"aucs": [0.8486610616994462, 0.6997913604342509, 0.8224580498523472, 0.6579670430749722, 0.713806350009724, 0.5778481736604302, 0.8005932487778453, 0.8345722519179135, 0.8025503318266058, 0.27499060879063464, 0.0932519045603547, 0.35200694596616444, 0.2569024971610786, 0.1329281473231142, 0.23043976862994842, 0.09363304258367533, 0.19135159394940715, 0.23535274786850802, 0.1388632045570508, 0.1815253352917241, 0.11615784660705053, 0.1267918542383215, 0.1059170968088674, 0.13142298225448845, 0.13364913723762406, 0.16114087157561408, 0.08549213197856809, 0.11499901447876837, 0.1414266410700833, 0.15480208145270224, 0.07233539273611789, 0.06788447466839476, 0.07874880487494307, 0.13038823136632982, 0.11555532936411073, 0.06627115973554698, 0.8104319828770038, 0.9939609114451442, 0.8016938553435357, 0.9928337109555695, 0.981074834757312, 0.8054473491673537, 0.8007869747892724, 0.9866882335218566, 0.9877753573303082, 0.43211934334798785, 0.47006457901974774, 0.3345742725790025, 0.5363614193159698, 0.32819576224791946, 0.48537338980914413, 0.35053335769694494, 0.3696405574139999, 0.4166843762333913, 0.22632831711207424, 0.6677067069224586, 0.22875216750038163, 0.2810631631532259, 0.19529520426025904, 0.18517373538201432, 0.33022775385240033, 0.17638447352690712, 0.1977411527649915, 0.21929283037274439, 0.3151030251667284, 0.2169733938837598, 0.14790887607535297, 0.27022976115679476, 0.10902753369717211, 0.17642026601224914, 0.1167083828980443, 0.19242527048826286, 0.13120502922468746, 0.18708654377470446, 0.3208477323608938, 0.16454786398584598, 0.17985352435862245, 0.13008299044007876, 0.1921257867044429, 0.27037268861661445, 0.2443421091047323, 0.00019586339947963438, 9.999999999998899e-05, 0.1343888612047578, 9.999999999998899e-05, 0.042278878351492466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017653178341428988, 0.10580171242289216, 0.07706729091952147, 0.045938899185590354, 0.05526858431293591, 0.020029675102738675, 0.10405165983745668, 0.10128091951297935, 0.1292687831973528, 0.09376009999544543, 0.11741876133015017, 0.04262301797560453, 0.05832386239749798, 0.08618193044899725, 0.12926717340916327, 0.15093199656826872, 0.06921470161606047, 0.20596969074751226, 0.09810100715019487, 0.1375221233556866, 0.05333153004292435, 0.07623862140884108, 0.011550484201022115, 0.15581979477723396, 0.05494076102185941, 0.03994951878493447, 0.0476177308768343, 0.0826939010190394, 0.5035810347732642, 0.5240751003258838, 0.5567774850436427, 0.4263539918853301, 0.49213529612576035, 0.48656651673270246, 0.6108788714094597, 0.5432047336210882, 0.6257229329748322, 0.10229134713792742, 0.09317329770843519, 0.07920837506099365, 0.13194297096910323, 0.14335763442751925, 0.1334614655455172, 0.07010615126507747, 0.1054619097588071, 0.08515590309982402, 0.16303960954517793, 0.24965563112866862, 0.1952307112304109, 0.24333005424090592, 0.33381307714128916, 0.23206603558298888, 0.18231955192297433, 0.3701632489821993, 0.35813609443824623, 0.2895166532642599, 0.25586405517870625, 0.3446825548957889, 0.4430783184734255, 0.42358347264239204, 0.32920742925545265, 0.2882717599623267, 0.37332069065421036, 0.41175588979523214, 0.185276156654829, 0.19818728127398677, 0.39425006525745976, 0.23199335923535158, 0.33298002722061415, 0.2942225530104099, 0.32154897687933337, 0.3216099647395695, 0.26221472014633307, 0.2454832173057856, 0.18207677256990307, 0.2577774197230681, 0.2302215028981044, 0.2309274984667864, 0.24856116353965618, 0.28794291112125225, 0.1726989017741083, 0.2219952783415854, 0.18031914049767583, 0.19811844622919106, 0.20075359616854493, 0.1881334715060653, 0.2197512130735788, 0.22553786423745736, 0.21666173468562133, 0.1969602665292186, 0.217533087015506, 0.21344282834190553, 0.18699793375949136, 0.16756365091097847, 0.8426943661194097, 0.20113654275270942, 0.15002435324344665, 0.14281368618206902, 0.14244993307635467, 0.8993706775432494, 0.6624416969918248, 0.21277891738641974, 0.8352353681827382, 0.11220064614494207, 0.08274647567789162, 0.15537882786838997, 0.7579100099221717, 0.5878889102922775, 0.21298982403095335, 0.22441000673935407, 0.21282106605183715, 0.24209742948275115, 0.19416093747535645, 0.1937834990686259, 0.23245577040494503, 0.22858833860484717, 0.23242658304331654, 0.2615259639073175, 0.152323170191198, 0.0845997774439411, 0.10606109624305915, 0.09499170808916146, 0.09021700962106949, 0.08058167525287063, 0.11374728253018151, 0.11701046278497329, 0.09591229451921424]}, "mutation_prompt": null}
{"id": "f4d3e835-70ef-4f81-9f92-74d548df530b", "solution": "import numpy as np\n\nclass QuantumInspiredIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n        self.chaos_factor = np.random.rand()\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                quantum_influence = np.random.uniform(-1, 1, (self.island_size, self.dim))\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions)) +\n                    self.chaos_factor * quantum_influence\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.1\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n                self.adaptive_memory[island_idx] = np.mean(island_positions, axis=0)\n            \n            if self.func_evals % (self.budget // 5) == 0:\n                self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape) * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n                self.chaos_factor = 4 * self.chaos_factor * (1 - self.chaos_factor)  # Logistic map for chaos\n            \n        return self.global_best", "name": "QuantumInspiredIslandPSO", "description": "Adaptive Quantum-Inspired Multi-Island PSO with enhanced exploitation and diversity through quantum-inspired update and chaotic maps.", "configspace": "", "generation": 54, "fitness": 0.20130026741200044, "feedback": "The algorithm QuantumInspiredIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.37339584186991515, 0.33159922996731195, 0.5575205185052534, 0.35776568427537847, 0.3210731172393052, 0.5961822651138471, 0.3946428819772827, 0.322392948763078, 0.4987190904032561, 0.01009470280101854, 9.999999999998899e-05, 0.012954353854823464, 0.01642076649210089, 9.999999999998899e-05, 0.04096758330821071, 0.011809457563962678, 0.0046587271905979, 0.005152236379767583, 0.09699620360405603, 0.10134395747582292, 0.11620644696667004, 0.1017111502621163, 0.09111991007760767, 0.09950320990876516, 0.0982788542829458, 0.08316557473904485, 0.13657825986314054, 0.07770567893678504, 0.07668581529157315, 0.12082815959727011, 0.08353641787713328, 0.0877048660410299, 0.10126117074737451, 0.0611398260999082, 0.08896261503084757, 0.09858621750241003, 0.9743859509344259, 0.993417044446689, 0.9629078065016868, 0.9928197981100124, 0.974840857466918, 0.9861615671678441, 0.9828316317286313, 0.9902133102852706, 0.9897144029282174, 0.22978224843775208, 0.20748549363228208, 0.31666310197209746, 0.18609314566209523, 0.2418116242958025, 0.2803449506678296, 0.23690227495461813, 0.21266365745941562, 0.2527311918941987, 0.21503668987146984, 0.2591596599866903, 0.21337561205753652, 0.290799573467157, 0.25772936430101867, 0.24776866078138227, 0.20428511551227635, 0.22247606996161517, 0.3162118972514535, 0.14451515005590587, 0.10293280044113817, 0.21524737881407596, 0.09641676859369963, 0.07083719315202652, 0.1050357329760151, 0.09641964474924203, 0.11284826055861086, 0.14374334734062633, 0.11141977220889931, 0.11664941591149014, 0.1774674069224106, 0.13956603873200546, 0.150556934630925, 0.13196385508392028, 0.14260149583302972, 0.10548357690260113, 0.13971018681279512, 9.999999999998899e-05, 9.999999999998899e-05, 0.05476017278201872, 0.0007577075928760779, 0.0032559723162753906, 0.02868113667054062, 0.00028509531001308375, 9.999999999998899e-05, 0.0036076640731474985, 0.09082311253703068, 0.04711454061136733, 0.12877671940498892, 0.08644785959181411, 0.056513382277328494, 0.05474513875728293, 0.10536022483491359, 0.03292662577717653, 0.08429020048662805, 0.004532655406043862, 9.999999999998899e-05, 0.021809362521111098, 0.009828602359349459, 9.999999999998899e-05, 0.11983227875499303, 0.004706926208497997, 9.999999999998899e-05, 0.03758924150495091, 0.07137067497692606, 0.05377023480034748, 0.09169541679146842, 0.06649871085635473, 0.05032844464235442, 0.07298617203887225, 0.04470069455076375, 0.039199206746872606, 0.07659766657267741, 0.34678218421130336, 0.32234605596437027, 0.3862205328486221, 0.34529101759676506, 0.30639188714716314, 0.4072171574245558, 0.34044773822335195, 0.3262825164275748, 0.46763375268936447, 0.1006267311746456, 0.083718273137257, 0.1257238109742963, 0.09291312735184332, 0.08046553921466293, 0.1011601661411653, 0.07861574823634143, 0.11013814334609429, 0.10622305546346611, 0.21997649393076357, 0.18648712785507882, 0.1808521036489913, 0.17648826987498745, 0.171506868724296, 0.22203394830168643, 0.1988483500576672, 0.16964035350259166, 0.21178423070491514, 0.2124725845068438, 0.2503773658409826, 0.2876038578890522, 0.24615823546958426, 0.2576494025087588, 0.3272666070145531, 0.24919867176429866, 0.23318795508051704, 0.33920035134744053, 0.17648283103610607, 0.1824694248263351, 0.24587711516053956, 0.21018097706883354, 0.16810227567731584, 0.2315824887535719, 0.1934636874994825, 0.1900847019894646, 0.21724116144729055, 0.19888026476605036, 0.21275553470089725, 0.21104096997960353, 0.21847831607115997, 0.16328867436063033, 0.22557023737819903, 0.20219860605742812, 0.19312013037076592, 0.1972531886737524, 0.20357172190150274, 0.18613926861108787, 0.18723159503090325, 0.17695703252516182, 0.18013264210151514, 0.1834045821466178, 0.16918567921534355, 0.17809798594339377, 0.19055100145620651, 0.2012517633482439, 0.12536981956346993, 0.165023792965294, 0.430188635322973, 0.4679841583523383, 0.16080499606964238, 0.1808120485439817, 0.13842916460467714, 0.17122428834499692, 0.3940403734136231, 0.266316856482822, 0.530536397667617, 0.25803741870271835, 0.20153053728021986, 0.14992113288591769, 0.4048426508709968, 0.33494233788913663, 0.17651007272124808, 0.17964968967631523, 0.18340188812347358, 0.1976969527260386, 0.18802308219674202, 0.1852315042593251, 0.1808186980375931, 0.18903241684983674, 0.18376428350092078, 0.21438209710938505, 0.08800160073669994, 0.07768912861362065, 0.09319462469796724, 0.09547168255193994, 0.08479098268967222, 0.08682443429671205, 0.10484408675575574, 0.08641405073664044, 0.0783045588381277]}, "mutation_prompt": null}
{"id": "4e5e1ad3-e454-4f41-bb40-bacea1f35335", "solution": "import numpy as np\n\nclass EnhancedIslandGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.5\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.where(np.random.rand(self.island_size, self.dim) < self.crossover_rate,\n                                                                   island_best_position, self.positions[island_start:island_end])\n                mutation_mask = np.random.rand(self.island_size, self.dim) < self.mutation_rate\n                mutation_values = np.random.uniform(-0.1, 0.1, (self.island_size, self.dim))\n                self.positions[island_start:island_end] += mutation_mask * mutation_values\n\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                self.adaptive_memory[island_idx] = np.mean(island_positions, axis=0)\n\n            if self.func_evals % (self.budget // 5) == 0:\n                self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape) * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n\n        return self.global_best", "name": "EnhancedIslandGA", "description": "EnhancedIslandGA: Introduce genetic algorithm-inspired operators (mutation and crossover) within island-based PSO to improve diversity and convergence.", "configspace": "", "generation": 55, "fitness": 0.23781799294883785, "feedback": "The algorithm EnhancedIslandGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.5627936934953546, 0.5510457620069371, 0.5755484594146623, 0.5183086677517821, 0.553355753268995, 0.5406510361344317, 0.5735982295498554, 0.5723494723713685, 0.5849852082544245, 0.03789717314743479, 0.012046119594689153, 0.17843589015548877, 0.10646228601220287, 0.07611433605783458, 0.04423833800005028, 0.0405692979015595, 0.029516768304437946, 0.07143353000191932, 0.09098106884065238, 0.13131488112927636, 0.14189060965343048, 0.1528834551126803, 0.1009070445529846, 0.15166905850461354, 0.10999191256226404, 0.13411134571340677, 0.11019995629972923, 0.12027750742340382, 0.12893346429329344, 0.1385001304886062, 0.10687097682859381, 0.14516308455346938, 0.09575674807828505, 0.11108638311562735, 0.1256674250808948, 0.112336159879313, 0.9810763863524238, 0.9919347836833359, 0.9782269662423186, 0.9905749245405008, 0.9735347912219048, 0.9195422748803411, 0.9610096203629306, 0.9875173211807299, 0.9839441969582756, 0.3736976778192176, 0.3485260912664232, 0.29365485135751257, 0.3236584578570758, 0.3445850050559197, 0.3225768086537475, 0.3367861699307527, 0.370255072160356, 0.3948627353358979, 0.8566970046091654, 0.17055794383365752, 0.8072110998023455, 0.2781428980021162, 0.3741293126113441, 0.2699525877399924, 0.17555777577553577, 0.1369877442143954, 0.23823859657421587, 0.23041316247649823, 0.1330772248916916, 0.17870116700206162, 0.10207053748781858, 0.14789992221618808, 0.1306421827632428, 0.16313247614892756, 0.16396602039325991, 0.18010700473130947, 0.20518463605174442, 0.19327614092558643, 0.2325523231562463, 0.19316517700819236, 0.19247818324996757, 0.2720122659313422, 0.09993898591363837, 0.22836249450025303, 0.19799973554260697, 9.999999999998899e-05, 0.026829888840149918, 0.023586141551393713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031966497193514076, 0.008824755056430544, 0.0027923555052153937, 0.09243687735583395, 0.06931136410446526, 0.10232874744244091, 0.052933164838231406, 0.00249840329346529, 0.08036324528871297, 0.0581428844201759, 0.05783389852767795, 0.08407034914377987, 0.017754062654132374, 0.059732697052303774, 0.014904230404554464, 0.044423627600873594, 0.034901652866858424, 0.031025368265841236, 0.02720000658989974, 0.021153145435855003, 0.025682973443806656, 0.1653101267895568, 0.17163053574843157, 0.12498754180325045, 0.03706293518580184, 0.06312371699932151, 0.09572859846653936, 0.05527257893881832, 0.1566522482648588, 0.1686636353299107, 0.4831301745251593, 0.47120608504300476, 0.48311426420203496, 0.5121965552911452, 0.46326656179647174, 0.46935366789876676, 0.5032338161933205, 0.4636829860004925, 0.48164934661688474, 0.1239864938672316, 0.06571907245998643, 0.09133398396222803, 0.08806772218860948, 0.10802424220010476, 0.07692119295540356, 0.0829642783014557, 0.11871816214833542, 0.08710218733970565, 0.17575488903623204, 0.18174234023939762, 0.2110858610341685, 0.40006765471646033, 0.19398686948280597, 0.3053769860801042, 0.24290582151588025, 0.16536679264930243, 0.2102547863909876, 0.2565205020670295, 0.2833280756980503, 0.3308147222739686, 0.21542365659648244, 0.332366119991795, 0.3156533471298547, 0.27044074645695415, 0.3495804259699432, 0.31009157185274394, 0.21296425696828414, 0.2633766006078522, 0.2325961726472089, 0.22973290708667848, 0.25683633697136654, 0.26857726282148575, 0.19455900584470665, 0.22883094505624046, 0.21475683235525445, 0.24218519592267618, 0.25337189812563443, 0.23549399605016863, 0.2106391565607798, 0.20816352492699086, 0.21515227432653605, 0.21908487026617984, 0.23595848808866426, 0.20531927182050524, 0.1907681064077269, 0.21133694752097798, 0.18718350879196466, 0.19849417465795816, 0.21095787309530123, 0.1836253483120004, 0.24526016893460212, 0.2248960690390509, 0.19228331724632175, 0.21100556982692864, 0.16574719526042858, 0.1674463837574962, 0.1738245199404913, 0.1703875157682111, 0.19767709820765533, 0.14302688711200628, 0.17757090391770103, 0.8491488880299415, 0.5874498368517079, 0.21111545325242786, 0.6411148030826351, 0.16886029858731888, 0.2113188293790217, 0.15347513207540253, 0.09352264984192293, 0.15650915730006176, 0.21247916008247503, 0.1845238625725376, 0.19836251812258332, 0.1839422880725402, 0.20214013254880925, 0.19312275613974883, 0.1917568426158598, 0.19414489020078585, 0.19416077774513307, 0.19220598538389855, 0.0805984089026891, 0.06969891656682281, 0.10453301273197446, 0.08370170928694676, 0.10383238569031072, 0.09055601237288213, 0.08624421203662846, 0.09131709158256163, 0.09113652534932737]}, "mutation_prompt": null}
{"id": "54f4fea3-664b-4a6d-81a0-51f077c2d21e", "solution": "import numpy as np\n\nclass HybridIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.velocity_bounds = 0.2 * np.ones((self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = self.personal_best_positions[island_start + island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.velocities[island_start:island_end] = np.clip(self.velocities[island_start:island_end], -self.velocity_bounds, self.velocity_bounds)\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n            if self.func_evals % (self.budget // 5) == 0:\n                random_indices = np.random.choice(self.population_size, self.island_size, replace=False)\n                self.positions[random_indices] = np.random.uniform(-5.0, 5.0, (self.island_size, self.dim))\n        \n        return self.global_best", "name": "HybridIslandPSO", "description": "Hybrid Island PSO with adaptive velocity boundary adjustment and periodic global reinitialization for enhanced global exploration and fine-tuned exploitation.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (4,5) (20,5) (20,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (4,5) (20,5) (20,5) ')", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {}, "mutation_prompt": null}
{"id": "34be6a12-9338-4b76-884b-a63dbda8ba4f", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                # Differential Evolution crossover\n                rand_idx = np.random.choice(self.population_size, 3, replace=False)\n                crossover_mask = np.random.rand(self.island_size, self.dim) < self.crossover_rate\n                mutant_vector = (self.positions[rand_idx[0]] \n                                 + self.mutation_factor * (self.positions[rand_idx[1]] - self.positions[rand_idx[2]]))\n                self.positions[island_start:island_end] = np.where(crossover_mask, mutant_vector, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n                self.adaptive_memory[island_idx] = np.mean(island_positions, axis=0)\n            \n            # Dynamic island restructuring\n            if self.func_evals % (self.budget // 5) == 0:\n                self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape) * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n        \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "Hybrid Adaptive Differential Evolution and Island-based PSO with dynamic topology adjustment for improved convergence and diversity.", "configspace": "", "generation": 57, "fitness": 0.11584951487691786, "feedback": "The algorithm EnhancedIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.15755621637985717, 0.14150187159900707, 0.13156944226921263, 0.1735056271904849, 0.17066030648159614, 0.2032768669546342, 0.16758008110599676, 0.17081648171984853, 0.17594914033521813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034560603682216806, 0.028236141553267813, 0.03570102506078876, 0.030912343640912665, 0.03867641626891294, 0.035975864466237684, 0.05606097989712655, 0.04115493099481027, 0.03707048884907327, 0.028381676881639728, 0.015865301620381467, 0.046170709431374246, 0.01416113641898642, 0.009626273348897652, 0.026240059197797372, 0.02246903212671625, 0.029548451818854793, 0.024206298944394078, 0.9593147476509374, 0.994617004427563, 0.9199169097220243, 0.9759349523179498, 0.9482576508112838, 0.9798458140069893, 0.9869720189044282, 0.9736206236256124, 0.9792753434808421, 0.06697217524155641, 0.06554192967849215, 0.07325555180207033, 0.04641786646956858, 0.07755992984380067, 0.1090895361284755, 0.08479563156246517, 0.0640170333266773, 0.06449235944749876, 0.11918676103738768, 0.09593947531349989, 0.10837565374329983, 0.09941747454240957, 0.09872820453406439, 0.13079137013066433, 0.1152660591378899, 0.11653537484684562, 0.1164673679627185, 0.0015717126616869859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017160813414744958, 0.006379878599698685, 9.999999999998899e-05, 0.0253222595369873, 0.0190129760463722, 0.010827393115522277, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010941421279136332, 0.09740558776874553, 0.058966573632255104, 0.045684345058933484, 0.02995412633406691, 0.008091408142345102, 0.019016032335229083, 0.011103923106327462, 0.012316328432757873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008940252134925664, 9.999999999998899e-05, 9.999999999998899e-05, 0.16371133406875282, 0.1655445267479161, 0.1625890988019344, 0.19755115662172162, 0.212500960527642, 0.18322269242775435, 0.1721789241061391, 0.21728176102834162, 0.18198674666018366, 0.05173510219098043, 0.08989170474711172, 0.06287982688786664, 0.03272204048264138, 0.03802549870474614, 0.03793877059756834, 0.03842077678594358, 0.027615637360986156, 0.04010116595475499, 0.12797174685431567, 0.13549422173032577, 0.13353644697240397, 0.15719410837142023, 0.14473953290220742, 0.11906284836771464, 0.14239215893814294, 0.1241178493882571, 0.1232796454587497, 0.15661627482504303, 0.14610271813062392, 0.15034916642180562, 0.14473502499977675, 0.1407840649764296, 0.1471406606239556, 0.14022568285924863, 0.17169306369210025, 0.14906959436208467, 0.08420191537942445, 0.09545244316853607, 0.08872178970813016, 0.0868291966169501, 0.10544886903350237, 0.1092146549841907, 0.10529766458578049, 0.10897645091659414, 0.09292250474174346, 0.14545953395798683, 0.1438717698612818, 0.1400284770197222, 0.1492425769477359, 0.13341219704890883, 0.1269167918050429, 0.14624562811864872, 0.1428470902919977, 0.13041100025853958, 0.08295065476049146, 0.128273832656569, 0.16322357471445337, 0.14189654090788317, 0.13525432530987402, 0.09679124810796924, 0.10059532841793639, 0.10946026987429835, 0.07823069030299701, 0.12930931731036688, 0.12251710659530546, 0.12222567768913772, 0.1414164090235709, 0.15401383754177567, 0.15762036552916803, 0.15493583333770256, 0.11856401851418086, 0.14444426342718542, 0.1337096645267235, 0.12115602463653286, 0.11427880435805415, 0.10416460544196304, 0.11914197784104907, 0.10566022608939873, 0.14112647990841798, 0.17279962032735097, 0.14716727092855852, 0.18380088144520668, 0.1671837115699163, 0.18066161946520443, 0.17037955149341155, 0.1949038609382564, 0.1840124080205403, 0.1827592312972347, 0.18471090487235375, 0.18508250455308273, 0.03829050032733172, 0.04581177285040772, 0.042198073542687786, 0.03716683351584538, 0.05848682813877093, 0.0462299361238222, 0.0363713084862205, 0.056304607544127805, 0.03232073466689467]}, "mutation_prompt": null}
{"id": "bf5bf270-b628-49cc-a252-445a99f1d709", "solution": "import numpy as np\n\nclass HybridAdaptiveIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5  # Changed island size for better diversity\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n        self.levy_alpha = 1.5  # Parameter for Levy flight\n\n    def levy_flight(self, size):\n        return np.random.standard_cauchy(size) ** (1 / self.levy_alpha)\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                # Introduce Levy flight for additional exploration\n                levy_step = self.levy_flight((self.island_size, self.dim)) * self.adaptive_memory[island_idx]\n                self.positions[island_start:island_end] += levy_step * (self.func_evals / self.budget)\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n                self.adaptive_memory[island_idx] = np.mean(island_positions, axis=0)\n            \n            # Adjust dynamic restructuring to account for levy flight\n            if self.func_evals % (self.budget // 5) == 0:\n                noise = np.random.uniform(-0.5, 0.5, self.positions.shape)\n                self.positions += noise * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n        \n        return self.global_best", "name": "HybridAdaptiveIslandPSO", "description": "Hybrid Adaptive Island PSO with Levy Flight for enhanced exploration and convergence capabilities.", "configspace": "", "generation": 58, "fitness": 0.035372271549842516, "feedback": "The algorithm HybridAdaptiveIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.1187022659360959, 0.08099758977961624, 0.06768055653980942, 0.09423008089102591, 0.06126016304290893, 0.05144441818339651, 0.04956657028538758, 0.06378425956062217, 0.0685268477058909, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.005286213174769516, 0.0, 0.006502668427547875, 0.0, 0.0026207988730635456, 0.007708604571193933, 0.0009007994253763529, 0.0, 0.0, 0.0, 0.0, 0.0003960783445856597, 0.0, 0.0, 0.0, 0.0, 0.03819943077576737, 0.0421201232737094, 0.01348508456378461, 0.034298957754437476, 0.021260463331832735, 0.030732643402618498, 0.027978947934207632, 0.027035691849573995, 0.03868485768384888, 0.06278000668205241, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05158925608711562, 0.02712622323598446, 0.05983987785995526, 0.06674076804341, 0.0, 0.0, 0.020618038924203552, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0455331391122743, 0.1425350615363855, 0.11132487582402206, 0.10271055943344376, 0.0824982080542832, 0.08607060905959607, 0.19888457630479162, 0.08681865595910387, 0.08751681639293496, 0.0, 0.0, 0.021930265912080582, 0.03262530863912727, 0.0, 0.0038117670133144266, 0.0, 0.0, 0.0024927070436866483, 0.045995014807070245, 0.08600148673669195, 0.11842529216528652, 0.08759387812643527, 0.053410823927113604, 0.04855836258363344, 0.06081810985212144, 0.08096701540025575, 0.051598232378799236, 0.08929264159666983, 0.08778981319018075, 0.14351766824581536, 0.1379792730102457, 0.11377214296883031, 0.10440290270472274, 0.12019313455660086, 0.12445820382690598, 0.11382122880411971, 0.03803746611529546, 0.021830106331719668, 0.05457770711417764, 0.056883112337181796, 0.0420498558878164, 0.06338167801895, 0.08368465771327316, 0.09974258921483548, 0.06412049254767282, 0.11940040774994665, 0.09386181345754196, 0.07764174488320974, 0.12739257236587942, 0.08645366518799324, 0.10892358407313474, 0.10175904557731463, 0.07867716495588362, 0.0791881050879698, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.052214009801514694, 0.055372518291250006, 0.06753588847158531, 0.07316706129092165, 0.06514301510588016, 0.050736290811121076, 0.1070249233569932, 0.05160569271352322, 0.06929463243041423, 0.11044398788874843, 0.10267089674774343, 0.024750112458852946, 0.018145024137544485, 0.019224513782252872, 0.05892496850407092, 0.043794983519444, 0.04013528071281469, 0.03272413848775646, 0.129857089920149, 0.1062392210242662, 0.13366635512896008, 0.1103823733587791, 0.1224541367139429, 0.1322380704756977, 0.14970316365599134, 0.12501375726807984, 0.13226204355029292, 0.008567778131358894, 0.015830758176725745, 0.014233848204057709, 0.0049527212256005315, 0.03418885728387033, 0.019974850557524237, 0.01614351913936085, 0.011201185332542773, 0.017541157176218958]}, "mutation_prompt": null}
{"id": "f7f198d5-edaf-4240-a0fd-ed12c1f64104", "solution": "import numpy as np\n\nclass EnhancedIslandPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n        self.F = 0.5  # Differential evolution factor\n        self.CR = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                mutant_vectors = (self.positions[np.random.randint(island_start, island_end, self.island_size)]\n                                  + self.F * (self.positions[np.random.randint(0, self.population_size, self.island_size)]\n                                  - self.positions[np.random.randint(island_start, island_end, self.island_size)]))\n                crossover_mask = np.random.rand(self.island_size, self.dim) < self.CR\n                self.positions[island_start:island_end] = np.where(crossover_mask, mutant_vectors, island_positions)\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                r3 = np.random.rand()\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (self.velocities[island_start:island_end] +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r3 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n            if self.func_evals % (self.budget // 5) == 0:\n                self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape) * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n\n        return self.global_best", "name": "EnhancedIslandPSO_DE", "description": "A hybrid adaptive PSO strategy incorporating island-based differential evolution for enhanced diversity and convergence.", "configspace": "", "generation": 59, "fitness": 0.13594848159006295, "feedback": "The algorithm EnhancedIslandPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.23114891403978044, 0.22499605621408092, 0.1918211870412706, 0.275873768782645, 0.23864473649451545, 0.2133716774880392, 0.2558406996978172, 0.2304727633236271, 0.2624534396314877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04904405862360073, 0.038918894745426535, 0.04843816050037897, 0.04547919488572916, 0.0508114211357209, 0.04782227678566198, 0.06256150949823436, 0.054842984412875384, 0.0515597663374745, 0.043797873787574604, 0.03134565031394654, 0.040681152049781066, 0.04992508365568282, 0.03787957799646169, 0.033188118851906756, 0.04513186212665021, 0.03695748345351657, 0.03558372245960906, 0.987575794758688, 0.9920974458096938, 0.9790635567341575, 0.9929432134880134, 0.9886197290309248, 0.9921286354410624, 0.9893259338506135, 0.983928520489392, 0.9863699946610038, 0.10892783998381894, 0.0928487546115111, 0.08616719331658773, 0.10707633526468363, 0.09905573484912689, 0.10284020283448791, 0.09017168778879259, 0.09960569913732176, 0.10511432401328824, 0.14750426203889344, 0.13780465062799907, 0.16794210316254643, 0.16656097229546007, 0.15841449082937487, 0.12946625480826757, 0.1399747768899524, 0.1402878810348801, 0.15330337849179176, 0.03441771002605931, 0.04030937769571685, 0.03826208735044634, 0.020762451389448877, 0.005815524182649412, 0.0014687900927007336, 0.0110360663486061, 0.002286594098893535, 0.029362302624551417, 0.0655090934893231, 0.04518144296324389, 0.05451097660601323, 0.003302561329530773, 0.0006780259909102693, 0.01932240153794995, 0.012055925092176789, 0.016122148396075286, 0.06946349906605032, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037107025903465596, 0.02606724195844179, 0.019176392975691847, 0.02397885773522157, 0.03838219379862151, 0.024990331880475614, 0.03299333335992194, 0.04104978327149933, 0.04669886374806809, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013921189896994868, 0.0027598384676963406, 0.0028142234671777455, 0.0005307242416376923, 0.022135387425512687, 0.007200145755740239, 0.02058873130087091, 0.020253106079250793, 0.012450336190256373, 0.20787565662125596, 0.23483000914623564, 0.20506217014685257, 0.22660918864963786, 0.20772118868198342, 0.20931479606897152, 0.21187467883389932, 0.19588173376071905, 0.21111053833079696, 0.06868377588042207, 0.06101643780398003, 0.06895139941832928, 0.048893329681971576, 0.060394068623727204, 0.05039323802672002, 0.05603062307424389, 0.06224200913957778, 0.04764687560484182, 0.13914472381273246, 0.14235260105234304, 0.14234627443765202, 0.14668264893512983, 0.12695442938389734, 0.1480398243781299, 0.12785525279336873, 0.13889076287282098, 0.12593005505368515, 0.17766466076701604, 0.17065535102768503, 0.17756734288642406, 0.1882927899286586, 0.1748420403540062, 0.19208086296041815, 0.20141633803305403, 0.19501581327080153, 0.17342198861473002, 0.12407017731643322, 0.10846037547363718, 0.12163857004438428, 0.14062397970955587, 0.11362597899682603, 0.12927422819053314, 0.133386075298092, 0.1323510434539239, 0.12646110797781962, 0.18564258359589436, 0.17362191178455633, 0.15810698535114986, 0.15042648152405436, 0.16038741344064378, 0.16390283028641772, 0.18728804705214674, 0.19611928546373114, 0.14950925135736648, 0.1681481670128896, 0.14306825741826856, 0.15361242868735714, 0.15321033533283612, 0.14484973367015097, 0.1585514424077371, 0.16642245765999708, 0.16816504218340056, 0.15157412276946125, 0.16464888690074242, 0.15978259079320034, 0.13527901643431528, 0.17871175617566792, 0.1232068680410342, 0.1636918805850286, 0.15341367403234762, 0.1971209941073414, 0.21629792970223305, 0.15840359921823677, 0.1511364638979389, 0.13124854030764166, 0.12715147305012742, 0.11155873996303778, 0.16186840121280544, 0.1900634290315366, 0.1972912766205892, 0.20659904075175095, 0.18488740434509132, 0.19465048111129646, 0.18647854870518876, 0.1981394377653345, 0.1900373033656546, 0.17872416874113173, 0.18224517398310103, 0.1761197528189581, 0.17708477398103184, 0.05173779983104032, 0.052417208751241784, 0.055031095757605675, 0.050009897312353724, 0.05601556226648641, 0.04759207465380677, 0.04971243871701314, 0.05140919088327378, 0.0620743427170064]}, "mutation_prompt": null}
{"id": "8fdadb25-d481-4665-8048-39aabfef193f", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.learning_rate = 0.729  # Adaptive learning rate\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] = (\n                    self.learning_rate * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                stochastic_disturbance = np.random.normal(0, 0.1, self.positions[island_start:island_end].shape)\n                self.positions[island_start:island_end] += stochastic_disturbance\n                crossover_mask = np.random.rand(self.island_size, self.dim) < 0.15  # Increased crossover rate\n                self.positions[island_start:island_end] = np.where(crossover_mask, island_best_position, self.positions[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                self.adaptive_memory[island_idx] = np.mean(island_positions, axis=0)\n\n            if self.func_evals % (self.budget // 4) == 0:  # Increased restructuring frequency\n                self.learning_rate *= 0.97  # Decreasing learning rate\n                self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape) * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n\n        return self.global_best", "name": "EnhancedIslandPSO", "description": "EnhancedIslandPSO with adaptive learning rate and stochastic disturbance to improve convergence speed and solution quality.", "configspace": "", "generation": 60, "fitness": 0.21046766350485513, "feedback": "The algorithm EnhancedIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.40166290206318844, 0.39082449088548843, 0.39340521379215787, 0.40708875243184084, 0.4030878959752221, 0.3906064852326865, 0.40195075268794656, 0.40719875749780166, 0.3892639415918805, 0.012697032785147555, 0.03099227380876146, 9.999999999998899e-05, 0.02198626388356406, 0.0006871031478472567, 0.01988071415491799, 9.999999999998899e-05, 0.0013706318926808292, 9.999999999998899e-05, 0.12465219562322505, 0.13014234785686152, 0.11860576177477411, 0.14466172068379124, 0.06824335502391332, 0.11335259514144014, 0.08381418218737324, 0.08376939618576185, 0.091191507875505, 0.08681623284877948, 0.11027333569475573, 0.09751273855759335, 0.12134788493752935, 0.10000734660644117, 0.08833311478254613, 0.09828905743982053, 0.09652312397160423, 0.1132857194325626, 0.9760459627654046, 0.9936372529468227, 0.9798663791153465, 0.9941411823548694, 0.9685297544303624, 0.9919441640728619, 0.991559422875213, 0.9824324227292487, 0.9897296629705661, 0.2858445033597522, 0.2495375143159997, 0.2847650162028377, 0.27063659199765067, 0.28252244969138174, 0.24903644373944012, 0.3098279313661815, 0.2421847091753342, 0.2633310917467835, 0.34495394310521266, 0.2809525564412607, 0.27938608054404634, 0.31170604137309743, 0.3535699933223707, 0.26275466520055046, 0.3166801836689843, 0.2055724630303145, 0.3179566659220202, 0.11552706969417537, 0.1394623462024096, 0.12947191069023534, 0.15160519219558033, 0.09643029690692817, 0.14100860482759958, 0.16117690632326853, 0.1176208395316517, 0.1884338496512108, 0.16602822014801022, 0.15099011471878399, 0.16528117181266733, 0.14239748463288293, 0.15588269146477773, 0.10545529950732668, 0.18245235175902486, 0.11557438113959195, 0.16485600259076383, 0.025363518025992238, 9.999999999998899e-05, 0.050906792548616075, 0.03318903683368846, 0.018386416553487606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006312512453718999, 0.14393591068497058, 0.04254773444574966, 0.12311957723782052, 0.02763106798948245, 0.004339650865562539, 0.05905672293490116, 0.1449019668073399, 0.11477703639006287, 0.050081205101861426, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1142734879963847, 0.0573574130945792, 0.10011359887278337, 0.07347960154660338, 0.08648121494201189, 0.09275970621005014, 0.07814944811767455, 0.09942351878531952, 0.08973110106365934, 0.39254188410426805, 0.3772199656318348, 0.3800744737356606, 0.38384673407479264, 0.387715798080563, 0.3851257581849491, 0.4207683517619475, 0.3656166692652527, 0.37628985998253317, 0.0977791228301419, 0.08124858099075005, 0.07865416290059002, 0.11470994952191071, 0.059419836124116054, 0.11009176003820798, 0.09486838298608657, 0.11152433272870732, 0.10026240700301114, 0.19059830214412354, 0.24589909183512237, 0.27424426908685295, 0.2117845466268573, 0.24492774521298266, 0.15692136278989943, 0.23439307647284224, 0.24329989932368168, 0.16063917408614303, 0.2874540318846138, 0.27956199856014785, 0.2931803855399455, 0.27199615904048846, 0.28469930618572226, 0.2790689886531271, 0.20905742904438906, 0.2756914934006882, 0.2652840386777844, 0.2212510988611498, 0.20472291936860032, 0.20538927924218242, 0.16413844371853048, 0.1443291611822235, 0.17086815919356269, 0.18873392026257474, 0.2045726148215572, 0.22197899071631944, 0.21078558294081162, 0.2010436277311779, 0.18521852605103728, 0.21785756134600742, 0.25309811745471, 0.20631231003078543, 0.21512723377457554, 0.20708162817173748, 0.21390102233643948, 0.195957388480125, 0.18915817754856712, 0.17547230908725797, 0.20024447837114978, 0.19612837313801879, 0.21091460981280807, 0.2420597991113551, 0.2252711103687962, 0.18301179528319245, 0.21176695840010495, 0.13095952396256216, 0.16661028690911184, 0.17228734115443, 0.19959516144877565, 0.5873984411854855, 0.14219420501684144, 0.19512268851201875, 0.6081203024998891, 0.46696096870243076, 0.15731726232709642, 0.20327445559240487, 0.4346552388196664, 0.11206945286376635, 0.20531270764125287, 0.40098495389904076, 0.44806451862602403, 0.21318612791574765, 0.1737917144396659, 0.18348948124313025, 0.1847483085639855, 0.18301763979105257, 0.17710551860326995, 0.18071449957225283, 0.18997177324700887, 0.20193184005505527, 0.19476149242014318, 0.08677016702979456, 0.08076930920599845, 0.0858390966270588, 0.08299239121514379, 0.0824073747337769, 0.08592304560687147, 0.09583309601263501, 0.11118302262686008, 0.09259453344382729]}, "mutation_prompt": null}
{"id": "34e9d412-d72c-46cd-b9cb-25570547ca0f", "solution": "import numpy as np\n\nclass EnhancedIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.adaptive_memory = np.zeros((self.num_islands, self.dim))\n        self.levy_flight_probability = 0.1\n\n    def levy_flight(self):\n        step = np.random.standard_normal(self.dim) * (np.random.uniform(0, 1, self.dim) ** (-1.0 / 3))\n        return step\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                inertia_weight = 0.5 + np.random.rand() / 2.0  # Dynamic inertia weight\n                self.velocities[island_start:island_end] = (\n                    inertia_weight * self.constriction_factor * island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                \n                if np.random.rand() < self.levy_flight_probability:\n                    self.positions[island_start:island_end] += self.levy_flight()\n                    \n                mutation_strength = 0.05 * np.random.randn(self.island_size, self.dim)\n                self.positions[island_start:island_end] += mutation_strength * np.abs(self.positions[island_start:island_end])\n\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n                \n                self.adaptive_memory[island_idx] = np.mean(island_positions, axis=0)\n            \n            if self.func_evals % (self.budget // 5) == 0:\n                self.positions += np.random.uniform(-0.5, 0.5, self.positions.shape) * self.adaptive_memory[np.random.randint(0, self.num_islands)]\n        \n        return self.global_best", "name": "EnhancedIslandPSO", "description": "Hybrid Island PSO with Lévy flights and adaptive mutation for enhanced exploration and exploitation in optimization tasks.", "configspace": "", "generation": 61, "fitness": 0.20553377864816338, "feedback": "The algorithm EnhancedIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.40942938926375305, 0.4072714024892361, 0.41370274494148973, 0.35302200679253304, 0.3806983311547215, 0.37134873952756176, 0.35524912973383305, 0.41003307845380954, 0.36962593937832466, 9.999999999998899e-05, 0.007375172992260204, 9.999999999998899e-05, 9.999999999998899e-05, 0.09793602897985454, 9.999999999998899e-05, 9.999999999998899e-05, 0.022293784811216022, 9.999999999998899e-05, 0.10038848994740057, 0.11838525123251697, 0.08098947129422485, 0.08938842204766584, 0.10233850451551929, 0.11096357174556704, 0.10246611219229285, 0.1245372386380793, 0.10148808794059005, 0.0900204100283627, 0.10520053159457199, 0.08558574513690909, 0.08861982051702055, 0.0657635852614481, 0.08590288412892111, 0.07874366046328929, 0.07086506428866779, 0.09198358418636965, 0.966950031864099, 0.9938182827672338, 0.9672703628741003, 0.9930417354202432, 0.9728895705426737, 0.9687899930812802, 0.9804807081602088, 0.9812322683226632, 0.9915921201271976, 0.24468353448441782, 0.28161099793019806, 0.23381460751554128, 0.2474507943904145, 0.25069386186688036, 0.234964656916004, 0.21870412888063806, 0.22668211910288538, 0.24515233760309252, 0.32389088528355436, 0.3542852320895262, 0.6404654123476196, 0.25341503668457066, 0.5186973745715118, 0.20655749302734372, 0.19284022902242381, 0.33174008505047914, 0.2528136823156627, 0.14652103361429525, 0.11275647558473556, 0.13355784842157226, 0.13323485603610807, 0.10066445624487619, 0.1576817539772286, 0.1287718248596349, 0.16144537510237822, 0.17211628543562307, 0.24380560660012074, 0.18272033868797233, 0.22118170440899998, 0.19409088614445646, 0.16387423146112345, 0.18227972969403639, 0.17127106466933728, 0.12813889726222716, 0.1333366630789986, 0.012611826439523743, 0.011092140326206756, 9.999999999998899e-05, 0.002705999094992917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008910690531026, 9.999999999998899e-05, 0.0598803625146751, 0.038004564680939046, 0.10554337388095991, 0.03613991837052832, 0.05228808879450242, 0.07034927471684371, 0.07670158060614907, 0.12382645673144121, 0.1510014513545822, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06537968558544094, 0.07914657871188169, 0.06810943364519484, 0.080295334242098, 0.0701088613752947, 0.07098830786999188, 0.07558455771747175, 0.0735699082967678, 0.06469832745830717, 0.38578282242174966, 0.39710514029450616, 0.36210483553352846, 0.4048958680518854, 0.35955868706655736, 0.3509922288823354, 0.37445040599073287, 0.4106163761247259, 0.3922370417688149, 0.09340060981713216, 0.10417875414658884, 0.09314397849889433, 0.12015657332636309, 0.07438769861452588, 0.0904682822399393, 0.08367818292672924, 0.09694955267625516, 0.1480781243711261, 0.20754422662151928, 0.24897297341951485, 0.15311062735901793, 0.23985445159469276, 0.21232847699453072, 0.2480429083506357, 0.20659624865127346, 0.15850837980869148, 0.1835641050521103, 0.24661795238301532, 0.2534625543005333, 0.28038012449717253, 0.29935778542566316, 0.29564952092694863, 0.2805212639377549, 0.2477970489006509, 0.2753392019369151, 0.2523238145064831, 0.20516860632170453, 0.19468399269307424, 0.2227024023101679, 0.1557211692089755, 0.16716549022990623, 0.19908076315626144, 0.17343633892652155, 0.2084739694073916, 0.18439302287817805, 0.20902768848572628, 0.19976730689476196, 0.2281822444371845, 0.21231097605975469, 0.2100147317159975, 0.2343947437770093, 0.20207332515020693, 0.2133391723272644, 0.24409310580834453, 0.18040777716868783, 0.18239557255825178, 0.18675651329052645, 0.17608328343134672, 0.22447042674127937, 0.194879325492594, 0.19215436575075473, 0.20145206415055772, 0.1744129279238923, 0.19236572384581385, 0.18650909311705377, 0.16596233780413983, 0.6055196360495927, 0.20040364842801262, 0.15837157044771266, 0.14179207926103898, 0.14206641821929533, 0.5894447891913832, 0.4355165885231891, 0.2125117131452905, 0.1116215121155576, 0.1993618660215889, 0.20657241348843913, 0.15415326219423386, 0.31263835229875214, 0.10510477768916027, 0.2104526032494668, 0.1859766409382395, 0.18339839649989897, 0.1765395736529941, 0.18213859007269406, 0.1716520864943728, 0.18603860103469305, 0.17980285394480922, 0.19353102641666253, 0.18102203960256613, 0.10099369883142884, 0.07833813307210058, 0.07903207621398545, 0.08178237414995215, 0.0985696725194064, 0.09426261472025277, 0.08612013593519219, 0.07808357464874949, 0.08591810030072178]}, "mutation_prompt": null}
{"id": "f96d1201-f0cb-4116-ab68-db735a33d42a", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.8  # Differential evolution factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Differential Evolution inspired local search\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Hybridized multi-island PSO with differential evolution-inspired local search to enhance convergence speed and solution quality.", "configspace": "", "generation": 62, "fitness": 0.27766721270377487, "feedback": "The algorithm HybridEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "51cff755-4de3-4b65-be42-cbe5301f17f6", "metadata": {"aucs": [0.6139791799937087, 0.7208856135804765, 0.7132183416914695, 0.739519091947551, 0.7381713776729739, 0.18871982877732707, 0.6600808441700668, 0.1820449469142339, 0.6484307334133115, 0.3001764735292376, 0.27254008050062617, 0.18318821738251667, 0.24389789793830885, 0.29377059717000376, 0.20077230175277927, 0.11948770666082742, 0.004440037421857723, 9.999999999998899e-05, 0.11533974326536645, 0.11456262125283323, 0.11199852419020428, 0.16662039786891913, 0.1504640277170598, 0.1013399432017783, 0.12576858155263526, 0.1409931999557339, 0.05003051427907046, 0.09448410553335795, 0.09191529245622554, 0.10694400124100845, 0.12519440440513607, 0.09820772696809832, 0.09843049502935775, 0.1268573669211137, 0.11088876684289517, 0.08634076058947615, 0.969165354742381, 0.9884855949116218, 0.9724802823148813, 0.9896192028789846, 0.962878462118595, 0.9735131948720879, 0.9623296271236098, 0.9787843448150815, 0.9881339483865772, 0.511849979611442, 0.40026242536457846, 0.036833882577495536, 0.3802430659014646, 0.4108026735620386, 0.5018530424678428, 0.43001869274504123, 0.08509175336900243, 0.46044330421960533, 0.35035466565807427, 0.7749666195142408, 0.20404117858312643, 0.3533122601206481, 0.6451755489263746, 0.21302613281281535, 0.5289431544358207, 0.7855337469151538, 0.22323143240085574, 0.37675185955032797, 0.1277149232231537, 0.22895085466278675, 0.11363874906431337, 0.2017168490829062, 0.18385695932223234, 0.23220236611570222, 0.2578395919520061, 0.19221841313202703, 0.1253488416148426, 0.14400995035612485, 0.2517115507852721, 0.18374728839765453, 0.18476394388479545, 0.4085135118337203, 0.1993126305034283, 0.22130559068519096, 0.21328964002404083, 0.05374391808903545, 0.03374215730730734, 0.0327971480851631, 0.03358959357798763, 0.03402121484663945, 0.05383815113847501, 0.03911585299534004, 0.04871477048784878, 0.08728895572145101, 0.07643118592048703, 0.16871954721482907, 0.2563517070244361, 0.12556414755773404, 0.06430694951064975, 0.15004108997830023, 0.13138938079989781, 0.36052858760279227, 0.15473358548853344, 0.03579254705106272, 0.051259191566393025, 0.0590214987515425, 0.0697807071384492, 0.0530560781827869, 0.08735700191920093, 0.05113917808601132, 0.1914706348130546, 0.09453329892667639, 0.12844838575583784, 0.04280426288337036, 0.22018033748345156, 0.15186807910230327, 0.2207341424030156, 0.16038485178257922, 0.07221263825870594, 0.19400854906777998, 0.07825704721448745, 0.5248754520080949, 0.5685774211748562, 0.5639961925319747, 0.5252839669461506, 0.5936473754300771, 0.5174708111989013, 0.5242568648790162, 0.4694226778559275, 0.5917239992092296, 0.11137970741135572, 0.12962482787239882, 0.10981213782872568, 0.12440941851750376, 0.10214592550350243, 0.1455731129772232, 0.13845335928811486, 0.10449080085726836, 0.13724624753895098, 0.23028056586221213, 0.26686629879547497, 0.17118915369510201, 0.30079134831917465, 0.18962500904366553, 0.17256282375091336, 0.1743704328603668, 0.35805609260900706, 0.28014388385840816, 0.3077965433573375, 0.16937522688644024, 0.37130049782083574, 0.42357258265846853, 0.3870374960542853, 0.24820582316227102, 0.23530801612179653, 0.3584887816926664, 0.36734188193288664, 0.17653108317801247, 0.1964956842596013, 0.1836475993784087, 0.18495738996523037, 0.24586155923687025, 0.27693749237542553, 0.20370073932255406, 0.253628633329137, 0.25162312797481, 0.24915356173826742, 0.18908140116789263, 0.23600829921999278, 0.20039040767899519, 0.22569092223396892, 0.21631098572639118, 0.26726761532180776, 0.20414630480806395, 0.20924342851172018, 0.19674011970863192, 0.218022540789637, 0.2209597550055128, 0.2156385181406476, 0.2137460236046681, 0.2056949521915833, 0.21783909484907904, 0.24029178866694823, 0.1904573429560361, 0.1986015144932083, 0.14717847217131153, 0.17049785025611475, 0.7638388363064523, 0.19671375646910716, 0.1599212108522814, 0.1410916906652443, 0.7316878065014978, 0.8176934722651196, 0.8048844926800451, 0.20722136433591865, 0.7308121805831348, 0.6970799677372925, 0.20719773539982977, 0.16184154755918756, 0.12924274903671795, 0.6864453440820715, 0.8160616253215512, 0.1926902507781879, 0.19970256261519392, 0.18765177601090288, 0.2202618563554074, 0.18715710505106342, 0.18119873908397466, 0.21726079364344852, 0.19176011003280768, 0.18627046922240154, 0.142751646190433, 0.09900744763782243, 0.09698761706694126, 0.11074035593506648, 0.08570713287934228, 0.1259114093426691, 0.09507918851742925, 0.08870963064824267, 0.07919190437634338]}, "mutation_prompt": null}
{"id": "7528725f-e179-4fb4-8819-a27c9d090cac", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.8  # Differential evolution factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Differential Evolution inspired local search\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Hybridized multi-island PSO with differential evolution-inspired local search to enhance convergence speed and solution quality.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f96d1201-f0cb-4116-ab68-db735a33d42a", "metadata": {"aucs": [0.6139791799937087, 0.7208856135804765, 0.7132183416914695, 0.739519091947551, 0.7381713776729739, 0.18871982877732707, 0.6600808441700668, 0.1820449469142339, 0.6484307334133115, 0.3001764735292376, 0.27254008050062617, 0.18318821738251667, 0.24389789793830885, 0.29377059717000376, 0.20077230175277927, 0.11948770666082742, 0.004440037421857723, 9.999999999998899e-05, 0.11533974326536645, 0.11456262125283323, 0.11199852419020428, 0.16662039786891913, 0.1504640277170598, 0.1013399432017783, 0.12576858155263526, 0.1409931999557339, 0.05003051427907046, 0.09448410553335795, 0.09191529245622554, 0.10694400124100845, 0.12519440440513607, 0.09820772696809832, 0.09843049502935775, 0.1268573669211137, 0.11088876684289517, 0.08634076058947615, 0.969165354742381, 0.9884855949116218, 0.9724802823148813, 0.9896192028789846, 0.962878462118595, 0.9735131948720879, 0.9623296271236098, 0.9787843448150815, 0.9881339483865772, 0.511849979611442, 0.40026242536457846, 0.036833882577495536, 0.3802430659014646, 0.4108026735620386, 0.5018530424678428, 0.43001869274504123, 0.08509175336900243, 0.46044330421960533, 0.35035466565807427, 0.7749666195142408, 0.20404117858312643, 0.3533122601206481, 0.6451755489263746, 0.21302613281281535, 0.5289431544358207, 0.7855337469151538, 0.22323143240085574, 0.37675185955032797, 0.1277149232231537, 0.22895085466278675, 0.11363874906431337, 0.2017168490829062, 0.18385695932223234, 0.23220236611570222, 0.2578395919520061, 0.19221841313202703, 0.1253488416148426, 0.14400995035612485, 0.2517115507852721, 0.18374728839765453, 0.18476394388479545, 0.4085135118337203, 0.1993126305034283, 0.22130559068519096, 0.21328964002404083, 0.05374391808903545, 0.03374215730730734, 0.0327971480851631, 0.03358959357798763, 0.03402121484663945, 0.05383815113847501, 0.03911585299534004, 0.04871477048784878, 0.08728895572145101, 0.07643118592048703, 0.16871954721482907, 0.2563517070244361, 0.12556414755773404, 0.06430694951064975, 0.15004108997830023, 0.13138938079989781, 0.36052858760279227, 0.15473358548853344, 0.03579254705106272, 0.051259191566393025, 0.0590214987515425, 0.0697807071384492, 0.0530560781827869, 0.08735700191920093, 0.05113917808601132, 0.1914706348130546, 0.09453329892667639, 0.12844838575583784, 0.04280426288337036, 0.22018033748345156, 0.15186807910230327, 0.2207341424030156, 0.16038485178257922, 0.07221263825870594, 0.19400854906777998, 0.07825704721448745, 0.5248754520080949, 0.5685774211748562, 0.5639961925319747, 0.5252839669461506, 0.5936473754300771, 0.5174708111989013, 0.5242568648790162, 0.4694226778559275, 0.5917239992092296, 0.11137970741135572, 0.12962482787239882, 0.10981213782872568, 0.12440941851750376, 0.10214592550350243, 0.1455731129772232, 0.13845335928811486, 0.10449080085726836, 0.13724624753895098, 0.23028056586221213, 0.26686629879547497, 0.17118915369510201, 0.30079134831917465, 0.18962500904366553, 0.17256282375091336, 0.1743704328603668, 0.35805609260900706, 0.28014388385840816, 0.3077965433573375, 0.16937522688644024, 0.37130049782083574, 0.42357258265846853, 0.3870374960542853, 0.24820582316227102, 0.23530801612179653, 0.3584887816926664, 0.36734188193288664, 0.17653108317801247, 0.1964956842596013, 0.1836475993784087, 0.18495738996523037, 0.24586155923687025, 0.27693749237542553, 0.20370073932255406, 0.253628633329137, 0.25162312797481, 0.24915356173826742, 0.18908140116789263, 0.23600829921999278, 0.20039040767899519, 0.22569092223396892, 0.21631098572639118, 0.26726761532180776, 0.20414630480806395, 0.20924342851172018, 0.19674011970863192, 0.218022540789637, 0.2209597550055128, 0.2156385181406476, 0.2137460236046681, 0.2056949521915833, 0.21783909484907904, 0.24029178866694823, 0.1904573429560361, 0.1986015144932083, 0.14717847217131153, 0.17049785025611475, 0.7638388363064523, 0.19671375646910716, 0.1599212108522814, 0.1410916906652443, 0.7316878065014978, 0.8176934722651196, 0.8048844926800451, 0.20722136433591865, 0.7308121805831348, 0.6970799677372925, 0.20719773539982977, 0.16184154755918756, 0.12924274903671795, 0.6864453440820715, 0.8160616253215512, 0.1926902507781879, 0.19970256261519392, 0.18765177601090288, 0.2202618563554074, 0.18715710505106342, 0.18119873908397466, 0.21726079364344852, 0.19176011003280768, 0.18627046922240154, 0.142751646190433, 0.09900744763782243, 0.09698761706694126, 0.11074035593506648, 0.08570713287934228, 0.1259114093426691, 0.09507918851742925, 0.08870963064824267, 0.07919190437634338]}, "mutation_prompt": null}
{"id": "7f10d6af-d6f8-4ebd-a465-80e8fc35766e", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.8\n        self.CR = 0.9\n        self.chaos_factor = 0.5  # New chaos factor\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                chaotic_factor = np.tanh(self.chaos_factor * self.func_evals / self.budget)  # New chaotic factor\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions)) +\n                    chaotic_factor * np.random.uniform(-1, 1, (self.island_size, self.dim))  # Chaos\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Enhanced PSO with adaptive differential evolution and chaotic perturbation to improve exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.20220038004921045, "feedback": "The algorithm HybridEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "f96d1201-f0cb-4116-ab68-db735a33d42a", "metadata": {"aucs": [0.4379116434804119, 0.3879596849797695, 0.41388978798251985, 0.38630641780310715, 0.376588778591486, 0.35643544107919334, 0.4283023253867122, 0.3853736336463436, 0.3704623539869615, 9.999999999998899e-05, 9.999999999998899e-05, 0.009605341239904974, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031854393119212787, 9.999999999998899e-05, 0.1587037743676687, 0.14962857625982984, 0.09458445686961969, 0.08837252906022297, 0.0993978850644609, 0.1309708863736211, 0.08561623592820267, 0.08229612291224786, 0.08736744999800117, 0.08565923938642805, 0.08418808808481104, 0.07919130069631208, 0.08530962548168497, 0.07309730046881124, 0.09130415193981156, 0.08231017345846448, 0.0809573768994798, 0.05458345108587925, 0.9791785598375263, 0.9899458840410047, 0.9805827565466146, 0.9849764465374499, 0.9712065643353711, 0.9560099287606507, 0.9801765276672276, 0.9855949513096217, 0.9906062419715038, 0.2584147928302074, 0.2599439380678079, 0.23257686219581364, 0.20154726156345892, 0.20327071813158626, 0.2153087391554599, 0.23706345549856223, 0.2499169442854029, 0.2329363598309031, 0.31800526165752685, 0.3050781142741392, 0.24971731715639922, 0.2519992495922093, 0.3063467748621156, 0.2669940523208081, 0.26534151530267713, 0.2128057440367933, 0.24554417873086454, 0.1975156542876776, 0.10165461601650527, 0.11812139923204068, 0.10833714685451123, 0.12090942528514603, 0.09657785428566201, 0.09779034195027092, 0.1414321575033135, 0.12695968629128385, 0.1315427398203306, 0.1304064570160961, 0.1651057034320813, 0.15383998141404065, 0.12040936884855091, 0.1060290805917965, 0.13509498951722398, 0.125441921000633, 0.12821512664694112, 0.012892987363086306, 9.999999999998899e-05, 0.03649834361406068, 0.01725984050703333, 0.01929169509177553, 0.0010838400197944464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0856869389506606, 0.06941610819751731, 0.049779716933792795, 0.06651289458753107, 0.005683709426733019, 0.07186840717937726, 0.10474617410260723, 0.12552098342844076, 0.06680676437543642, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09677432769308159, 0.07542104133340144, 0.01769179943517707, 0.09225512288945137, 0.06789391510121823, 0.0608558067396181, 0.055367298639254825, 0.08587313002475472, 0.08106638674238387, 0.3838194135096985, 0.3545006394431556, 0.3638391034953151, 0.38000927294384723, 0.366585766293134, 0.35343841636475337, 0.3726559528878238, 0.35306192001955483, 0.37460898180351254, 0.08941904900214048, 0.08921969563427956, 0.06837434553085331, 0.12131713306874703, 0.12613946871361004, 0.10213941646053315, 0.0905001936020362, 0.13731797355604558, 0.13120111751645203, 0.25450069884473714, 0.1493379179506542, 0.1710978062072196, 0.23012480584356831, 0.24582514038859937, 0.20757084109310675, 0.20357270635278124, 0.1897809960220519, 0.1587861451102477, 0.2502815490250785, 0.2622658304031341, 0.249846209758131, 0.22851730697462003, 0.2678926831215398, 0.25137257911871447, 0.2634546325475795, 0.2829023985831003, 0.25683153563937744, 0.17626370969263438, 0.19089407870643227, 0.21904080629634382, 0.1732125606161844, 0.19525514450868575, 0.2060188395088498, 0.20548985410024845, 0.23065305955673743, 0.21467775060204808, 0.2200819565923714, 0.20146550901949933, 0.19965052243722348, 0.23008717381750154, 0.210176930389409, 0.20599679309406072, 0.22427733236333358, 0.18838323210899266, 0.20371494813332558, 0.18915557916181214, 0.18225400978782003, 0.20632058293724131, 0.18809620569105245, 0.19018280927109021, 0.18323753890181316, 0.1929202695518496, 0.1946432201351891, 0.18612946158221244, 0.13067494614365183, 0.18545124057069995, 0.16308226900233036, 0.5350462464164899, 0.19773316010489628, 0.15755646880253937, 0.14149263017410907, 0.5252508348311941, 0.5764383637034913, 0.40106528915800643, 0.20791447750856384, 0.48204939999287655, 0.43162479325083447, 0.20562251365017115, 0.15107095334358966, 0.11184100350728987, 0.30223429917279465, 0.20932030748396468, 0.19456807441368418, 0.2079432576323883, 0.1856326461770259, 0.19615549207222016, 0.19260944232860888, 0.1840905765058526, 0.1870907814907138, 0.17595908223320444, 0.19328763122518433, 0.10863471453406692, 0.09043562570003816, 0.09009634255654397, 0.08566275012305347, 0.07772409509127498, 0.08106357179210477, 0.0932361687246066, 0.08691188421937202, 0.08690863628516887]}, "mutation_prompt": null}
{"id": "614a0e63-c580-4f02-b6eb-130ecd3e3b76", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.8  # Differential evolution factor\n        self.CR = 0.9  # Crossover rate\n        self.alpha = 0.9  # Velocity damping factor\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            elite_idx = np.argmin(self.personal_best_values)\n            elite_position = self.positions[elite_idx]\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.velocities[island_start:island_end] *= self.alpha\n                self.velocities[island_start:island_end] += (\n                    self.constriction_factor * (self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n                # Elite migration to promote diversity\n                self.positions[island_start] = elite_position\n\n        return self.global_best", "name": "EnhancedAdaptivePSO", "description": "Enhanced multi-island PSO with adaptive velocity damping and elite migration for improved convergence and diversity.", "configspace": "", "generation": 65, "fitness": 0.1631682914138281, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "f96d1201-f0cb-4116-ab68-db735a33d42a", "metadata": {"aucs": [0.31934401921499744, 0.26735914635019575, 0.2679720705241455, 0.27716910128425065, 0.33829440122116816, 0.18543482099166408, 0.3319898118176968, 0.22688557101180817, 0.3385254887305713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053304507431560344, 9.999999999998899e-05, 0.08455130558435398, 0.07482718834410484, 0.07797630402528433, 0.08112434903558674, 0.0869245184938493, 0.10437390539724889, 0.0825055208376716, 0.08285841450230003, 0.07486892557114244, 0.06947946232781721, 0.06526752957971604, 0.05711515370971243, 0.06731967589538368, 0.05117657079142024, 0.07192808045729304, 0.08720947530582213, 0.07607096157915472, 0.06872387721791207, 0.98066179514056, 0.991285725151179, 0.9043801534840235, 0.9889053301663984, 0.9564774022972468, 0.982720755814514, 0.9749902592116895, 0.9742031524993647, 0.9866473921006519, 0.1590241907230857, 0.14096074947095294, 0.049162375018881876, 0.1619080682667694, 0.12633400393246597, 0.148345574325784, 0.11175930035033599, 0.08147966449301935, 0.1419474145336349, 0.19655989506048277, 0.17978121191245244, 0.17488171385513507, 0.19922175200945003, 0.21052779290069978, 0.17232151093444337, 0.121793318827491, 0.20617710663678213, 0.2169702456625512, 0.11314685768096022, 0.06734854402737167, 0.09548963888005635, 0.04770252601592362, 0.04463691737058162, 0.059548829498987654, 0.06225071264408466, 0.07012139525114691, 0.07197964222348752, 0.06041743667169153, 0.041710318073287955, 0.08424496526991476, 0.10993835318067213, 0.08215028177092898, 0.09409627485272487, 0.05040667035221269, 0.13745585917821224, 0.06209617078544616, 0.0219099206066643, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012406510633019341, 9.999999999998899e-05, 9.999999999998899e-05, 0.034659121977535734, 0.07104761149157346, 0.09185849880904373, 0.013126416804671082, 0.01137525018375729, 0.052647363588470775, 0.08985724684636975, 0.09206014625448711, 0.03673029444409481, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04409386892466338, 0.018937610039155728, 0.016977400777293594, 0.035534924279942426, 0.05497080212288297, 0.04494535412907552, 9.999999999998899e-05, 0.028155417110600656, 0.03328200371462575, 0.3127984564786864, 0.3169261961154316, 0.25879801123077084, 0.27783471729836773, 0.2685438659905891, 0.2988722277758258, 0.3615979479526821, 0.2808074163400732, 0.27021506601808687, 0.07781619990281818, 0.10601849620919146, 0.07779720677064816, 0.09110786041052288, 0.08366627148202299, 0.12441678045108606, 0.06835683863295794, 0.07716809030936078, 0.08324395088100356, 0.15237425138934835, 0.14537573819045957, 0.15726660974224482, 0.13120655281100557, 0.15051926245365543, 0.15095167436455526, 0.1687570387902344, 0.1306204585357036, 0.1530896865319904, 0.20392439308516452, 0.20254726609874274, 0.21850051820660088, 0.22002918610034217, 0.2192475250025876, 0.21533381358157622, 0.215116808272792, 0.24815971548981475, 0.21320202100677754, 0.1340450388700568, 0.1501106738895127, 0.1769038755310618, 0.17894708598062314, 0.1432268771210642, 0.15422911431412578, 0.14754362764279827, 0.1619668318077775, 0.15305056913623483, 0.1800346799725181, 0.15656774847794264, 0.18639243905058445, 0.19293502973320886, 0.18284673083841385, 0.16927936103127372, 0.19757215107726267, 0.18745808596370583, 0.20712934111359638, 0.17483978919840282, 0.16062514965016617, 0.1615262377896326, 0.175826122679553, 0.18644101802958635, 0.16355473713230417, 0.16995114917416632, 0.17816423553683092, 0.17190124013284058, 0.24221291023330838, 0.3470084475659029, 0.16043411462098411, 0.18256060940660823, 0.18351928347227908, 0.15578789335443, 0.13244158594456312, 0.1700924178717962, 0.32534324414429217, 0.2672811185843529, 0.17846334002778586, 0.17423517495388208, 0.44011413510304276, 0.170697509215317, 0.17541371889373458, 0.20679969875837823, 0.2042662172329559, 0.16973042183332054, 0.20442366821658153, 0.18624003729883798, 0.19299134607313495, 0.18795940338205575, 0.18737011445592044, 0.19819177754928796, 0.19471091369229376, 0.1869054629722059, 0.1900530180443487, 0.06627226354969229, 0.06268374590291115, 0.07633778726456952, 0.06942800609624189, 0.07693395676265558, 0.06486288890250058, 0.06953897664432718, 0.06453873013320122, 0.07140477797071221]}, "mutation_prompt": null}
{"id": "da0d10d0-d027-459e-b030-5405010a0836", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.8  # Differential evolution factor\n        self.CR = 0.9  # Crossover rate\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2, r3 = np.random.rand(3)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Differential Evolution inspired local search\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Hybridized multi-island PSO with differential evolution-inspired local search to enhance convergence speed and solution quality.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f96d1201-f0cb-4116-ab68-db735a33d42a", "metadata": {"aucs": [0.6139791799937087, 0.7208856135804765, 0.7132183416914695, 0.739519091947551, 0.7381713776729739, 0.18871982877732707, 0.6600808441700668, 0.1820449469142339, 0.6484307334133115, 0.3001764735292376, 0.27254008050062617, 0.18318821738251667, 0.24389789793830885, 0.29377059717000376, 0.20077230175277927, 0.11948770666082742, 0.004440037421857723, 9.999999999998899e-05, 0.11533974326536645, 0.11456262125283323, 0.11199852419020428, 0.16662039786891913, 0.1504640277170598, 0.1013399432017783, 0.12576858155263526, 0.1409931999557339, 0.05003051427907046, 0.09448410553335795, 0.09191529245622554, 0.10694400124100845, 0.12519440440513607, 0.09820772696809832, 0.09843049502935775, 0.1268573669211137, 0.11088876684289517, 0.08634076058947615, 0.969165354742381, 0.9884855949116218, 0.9724802823148813, 0.9896192028789846, 0.962878462118595, 0.9735131948720879, 0.9623296271236098, 0.9787843448150815, 0.9881339483865772, 0.511849979611442, 0.40026242536457846, 0.036833882577495536, 0.3802430659014646, 0.4108026735620386, 0.5018530424678428, 0.43001869274504123, 0.08509175336900243, 0.46044330421960533, 0.35035466565807427, 0.7749666195142408, 0.20404117858312643, 0.3533122601206481, 0.6451755489263746, 0.21302613281281535, 0.5289431544358207, 0.7855337469151538, 0.22323143240085574, 0.37675185955032797, 0.1277149232231537, 0.22895085466278675, 0.11363874906431337, 0.2017168490829062, 0.18385695932223234, 0.23220236611570222, 0.2578395919520061, 0.19221841313202703, 0.1253488416148426, 0.14400995035612485, 0.2517115507852721, 0.18374728839765453, 0.18476394388479545, 0.4085135118337203, 0.1993126305034283, 0.22130559068519096, 0.21328964002404083, 0.05374391808903545, 0.03374215730730734, 0.0327971480851631, 0.03358959357798763, 0.03402121484663945, 0.05383815113847501, 0.03911585299534004, 0.04871477048784878, 0.08728895572145101, 0.07643118592048703, 0.16871954721482907, 0.2563517070244361, 0.12556414755773404, 0.06430694951064975, 0.15004108997830023, 0.13138938079989781, 0.36052858760279227, 0.15473358548853344, 0.03579254705106272, 0.051259191566393025, 0.0590214987515425, 0.0697807071384492, 0.0530560781827869, 0.08735700191920093, 0.05113917808601132, 0.1914706348130546, 0.09453329892667639, 0.12844838575583784, 0.04280426288337036, 0.22018033748345156, 0.15186807910230327, 0.2207341424030156, 0.16038485178257922, 0.07221263825870594, 0.19400854906777998, 0.07825704721448745, 0.5248754520080949, 0.5685774211748562, 0.5639961925319747, 0.5252839669461506, 0.5936473754300771, 0.5174708111989013, 0.5242568648790162, 0.4694226778559275, 0.5917239992092296, 0.11137970741135572, 0.12962482787239882, 0.10981213782872568, 0.12440941851750376, 0.10214592550350243, 0.1455731129772232, 0.13845335928811486, 0.10449080085726836, 0.13724624753895098, 0.23028056586221213, 0.26686629879547497, 0.17118915369510201, 0.30079134831917465, 0.18962500904366553, 0.17256282375091336, 0.1743704328603668, 0.35805609260900706, 0.28014388385840816, 0.3077965433573375, 0.16937522688644024, 0.37130049782083574, 0.42357258265846853, 0.3870374960542853, 0.24820582316227102, 0.23530801612179653, 0.3584887816926664, 0.36734188193288664, 0.17653108317801247, 0.1964956842596013, 0.1836475993784087, 0.18495738996523037, 0.24586155923687025, 0.27693749237542553, 0.20370073932255406, 0.253628633329137, 0.25162312797481, 0.24915356173826742, 0.18908140116789263, 0.23600829921999278, 0.20039040767899519, 0.22569092223396892, 0.21631098572639118, 0.26726761532180776, 0.20414630480806395, 0.20924342851172018, 0.19674011970863192, 0.218022540789637, 0.2209597550055128, 0.2156385181406476, 0.2137460236046681, 0.2056949521915833, 0.21783909484907904, 0.24029178866694823, 0.1904573429560361, 0.1986015144932083, 0.14717847217131153, 0.17049785025611475, 0.7638388363064523, 0.19671375646910716, 0.1599212108522814, 0.1410916906652443, 0.7316878065014978, 0.8176934722651196, 0.8048844926800451, 0.20722136433591865, 0.7308121805831348, 0.6970799677372925, 0.20719773539982977, 0.16184154755918756, 0.12924274903671795, 0.6864453440820715, 0.8160616253215512, 0.1926902507781879, 0.19970256261519392, 0.18765177601090288, 0.2202618563554074, 0.18715710505106342, 0.18119873908397466, 0.21726079364344852, 0.19176011003280768, 0.18627046922240154, 0.142751646190433, 0.09900744763782243, 0.09698761706694126, 0.11074035593506648, 0.08570713287934228, 0.1259114093426691, 0.09507918851742925, 0.08870963064824267, 0.07919190437634338]}, "mutation_prompt": null}
{"id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.5  # Adaptive DE factor\n        self.CR = 0.9  # Crossover rate\n        self.elitism_rate = 0.1  # Elitism rate\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Adaptive Differential Evolution inspired local search\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive adjustment\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            # Elitism: Retain the best\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Enhanced hybrid multi-island PSO with adaptive differential evolution and elitism to improve exploration-exploitation balance and convergence rate.", "configspace": "", "generation": 67, "fitness": 0.3065153783752536, "feedback": "The algorithm HybridEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f96d1201-f0cb-4116-ab68-db735a33d42a", "metadata": {"aucs": [0.7438600366245711, 0.7064525682751424, 0.7538317593864988, 0.18959223207973108, 0.7429911866603132, 0.1897228403002591, 0.7507471952383207, 0.7603812349563183, 0.7507531672303389, 9.999999999998899e-05, 0.46232003988415904, 0.385197640349385, 0.46668556290676233, 0.4299478161936715, 0.34809006423034894, 0.4141425749766209, 0.17893220758675765, 0.047670272595686236, 0.10961500370848021, 0.08009530081327942, 0.10657989239185484, 0.09050537169832673, 0.09783616768539027, 0.14402429807677652, 0.1205080600135654, 0.11330069197501325, 0.09348018179744721, 0.10856956654456806, 0.09969056402692111, 0.10936852809433983, 0.1047211640411495, 0.09261016003622247, 0.10924278745085159, 0.10242283661549789, 0.11724991511944083, 0.05957979089006438, 0.9892101407509785, 0.9883054508324912, 0.9831699693183287, 0.9884952449799214, 0.9328305025963488, 0.9740441985019916, 0.9830545329187254, 0.9915846435657341, 0.9906123461400195, 0.6634882527080352, 0.47296814097667306, 0.059434822229704865, 0.6383861480986628, 0.39462797619583945, 0.4501760245570514, 0.12657224428806024, 0.5390189333029758, 0.08925623535423333, 0.2256108501276204, 0.37822767083041586, 0.21747558767174546, 0.3451132951510968, 0.2076409408373291, 0.8143919047633092, 0.7297197477148986, 0.17475794315161952, 0.737948758770534, 0.44222239893761006, 0.3558311991113715, 0.12557175454857317, 0.14101381291768045, 0.3013789310267707, 0.12357019230216315, 9.999999999998899e-05, 0.29887109070258555, 0.35793443751862997, 0.44608115301096474, 0.4724427496307593, 0.45732767235066396, 0.429463487638151, 0.548996975486233, 0.4304073873372841, 0.2800750867266004, 0.4339805188186119, 0.357374437447178, 0.18143960990085672, 0.05801957649320755, 0.2973274509449533, 0.15796152968324695, 0.03927253352787574, 0.21351153242393417, 0.007328044020184832, 9.999999999998899e-05, 0.2677939962069886, 0.025769806965169617, 0.19185099058280652, 0.15443417794340164, 0.1915642078497296, 0.03862384447499667, 0.11918496526892408, 0.36941427331264876, 0.42222365239553583, 0.3583835032497932, 0.0709004884551574, 0.03869235360244494, 0.040881062445005, 0.07326192185020786, 0.15914817163512684, 0.06277491678871194, 0.0659242964347464, 9.999999999998899e-05, 0.056881442490929635, 0.2739353130833725, 0.20543330712649754, 0.15835192958246247, 0.1410505974648233, 0.11592528834997207, 0.2804227624992973, 9.999999999998899e-05, 0.20822374455083648, 0.07559170827791184, 0.6414870035910102, 0.5858865794225927, 0.5853317550821568, 0.6205823942805316, 0.5808775727523571, 0.5826197592057752, 0.552611995767498, 0.5443718403811582, 0.6112651976163702, 0.11766911917196066, 0.07432912261403779, 0.14455963416566997, 0.16935769451658234, 0.04419522494010797, 0.07887053252987752, 0.10786416857472136, 0.07337130296869343, 0.07579920581815591, 0.15470476600922667, 0.22768893974539628, 0.20790583211316782, 0.40021400612502434, 0.2629329573015533, 0.161525358284614, 0.19196019654255392, 0.17202536031458548, 0.23085178909275905, 0.32078803051396243, 0.31779748382955963, 0.3214156767696399, 0.3448939651374523, 0.35042617552217725, 0.3855327658554848, 0.37008688172557136, 0.2946873831936425, 0.2819199020857168, 0.20341671454461308, 0.18486865764038551, 0.23624432414323315, 0.3502076537948845, 0.3661223567731584, 0.40040194297108866, 0.23461389926092024, 0.25811271069038644, 0.39405327889041364, 0.25818856708682336, 0.2187253314674823, 0.23805005888605724, 0.2691696437517854, 0.268967697785939, 0.21271435067856614, 0.22688599323271952, 0.22468261776506815, 0.2052724573814848, 0.20170683680135248, 0.18907184366162, 0.22115111820480693, 0.181094858308414, 0.18721890329564883, 0.18382534041720966, 0.1863895357201516, 0.1887632959036356, 0.17834114274869695, 0.18029296115833804, 0.14727267171778802, 0.19744913255771268, 0.8385311308258134, 0.16897495902752857, 0.16224257605937087, 0.8670400165950415, 0.7841957144626193, 0.8796841325357007, 0.8293621410415113, 0.210303789613405, 0.7629417637448608, 0.8747616654011698, 0.20740123649685938, 0.15127915443120654, 0.09447001466151983, 0.8584860728900745, 0.2077018560420455, 0.2019448031321952, 0.2084333969479808, 0.20476411193282862, 0.2470341743229033, 0.20854859017942595, 0.1853310828261162, 0.20651976515577442, 0.2031265187402359, 0.1784199811039756, 0.14566244020795238, 0.09088934885863564, 0.10145098666690244, 0.09025360613743683, 0.08667740252273981, 0.10816990843197616, 0.0773752952271598, 0.09362177683678508, 0.098651373011296]}, "mutation_prompt": null}
{"id": "a3b94fd6-b871-4925-b005-4f17e9847668", "solution": "import numpy as np\n\nclass ImprovedHybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.5\n        self.CR = 0.9\n        self.elitism_rate = 0.1\n\n    def opposition_based_learning(self, positions):\n        return -positions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Self-adaptive Differential Evolution local search\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    self.F = 0.5 + 0.3 * np.random.rand()\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            # Elitism: Retain the best\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n            # Opposition-based learning\n            opposition_positions = self.opposition_based_learning(self.positions)\n            for idx in range(self.population_size):\n                if self.func_evals >= self.budget: break\n                opposition_fitness = func(opposition_positions[idx])\n                self.func_evals += 1\n                if opposition_fitness < self.personal_best_values[idx]:\n                    self.personal_best_values[idx] = opposition_fitness\n                    self.personal_best_positions[idx] = opposition_positions[idx]\n\n        return self.global_best", "name": "ImprovedHybridEnhancedPSO", "description": "HybridEnhancedPSO with self-adaptive parameters and opposition-based learning to enhance exploration and convergence.", "configspace": "", "generation": 68, "fitness": 0.2525473039476107, "feedback": "The algorithm ImprovedHybridEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "metadata": {"aucs": [0.5426091984263393, 0.5521629543931587, 0.6453691488469133, 0.5038342654384017, 0.6650087597629379, 0.1889583231593196, 0.614029306102733, 0.558782580480465, 0.5691092150314327, 9.999999999998899e-05, 0.11181933200229088, 0.29717049534183926, 0.09919889056640563, 0.08827215651993137, 0.10510129750129837, 0.21924327561655788, 0.09265341616960265, 0.03138761402278256, 0.12780710727657696, 0.08368439271236205, 0.13057240381736412, 0.08567597020818374, 0.14585123256838883, 0.09992773793975085, 0.11571075296708766, 0.09875907865844435, 0.13822196863752179, 0.07331969060809662, 0.0840536273449961, 0.10130370091733054, 0.0892048637755628, 0.09662814612061155, 0.11727736501045694, 0.09662936771045083, 0.10057582192719361, 0.08927994710092768, 0.9855777420593322, 0.9881233743335187, 0.9761138792682105, 0.982997505351696, 0.9158561961274151, 0.9652735198571106, 0.975942820090655, 0.9881473293307199, 0.9873169443628361, 0.44483769625536196, 0.32407773555455965, 0.05847694450821239, 0.3981914480577202, 0.34990345142783397, 0.14372845739179863, 0.08238651149080911, 0.05117784122781888, 0.08893739803024259, 0.2178815641954941, 0.6347431414977324, 0.35286434848361214, 0.21058670515031008, 0.26421995513551955, 0.15560990515744944, 0.20855539757167085, 0.334280149690214, 0.6868884631712475, 0.24038511099590643, 0.25302577744646093, 0.11289335228072161, 0.11030004367845436, 0.2525880132432621, 0.31255676305024505, 9.999999999998899e-05, 0.11302313166970923, 0.3041677699436889, 0.12082086982444684, 0.1772855537836171, 0.3223021082410976, 0.3029065867546734, 0.23033986919234561, 0.30789672715417593, 0.2012864118766674, 0.256849627002692, 0.3863601861442718, 0.05420026133322031, 0.04321267309925392, 0.11255512189605055, 0.030944425972694423, 0.03254536404571429, 0.03011548875709036, 0.13169975225809427, 0.05683767857810795, 0.0011405498383021406, 0.06259755556254021, 0.15869248058034646, 0.11887199390207026, 0.11023009024033614, 0.14084095182193468, 0.08656690972679149, 0.23167490278495906, 0.10573897639543683, 0.18187921077065416, 0.09043655348899571, 0.027717844643069145, 0.027886726795479433, 0.04710715253322928, 0.06080326057552976, 0.12840351859777654, 0.0501623933371278, 9.999999999998899e-05, 0.0668268750744141, 0.15629566439858533, 0.11476982742787245, 0.09530736251505878, 0.12877720038531393, 0.17228146437954506, 0.2123536303639011, 9.999999999998899e-05, 0.1805764723794251, 0.06373013454837306, 0.4359738375730129, 0.4647804561679225, 0.48733779510811615, 0.4896976364601615, 0.4922713677719801, 0.4945777300077573, 0.49814886917214374, 0.49513543707233687, 0.48532273162418693, 0.1284279991502546, 0.0743860061646936, 0.13583711359224304, 0.10831534219063177, 0.08802999341014273, 0.07708253172419532, 0.09168065179642704, 0.10026456599769829, 0.06098856962832033, 0.22653129138441808, 0.23044100394541356, 0.17758616623384427, 0.2812939619674767, 0.19487822271065758, 0.21654459871106524, 0.13980603776129152, 0.24383870981590405, 0.17320874306793999, 0.3808551227890463, 0.22973880633622423, 0.3519797272362759, 0.2575277670952423, 0.35613104006364116, 0.35068071130559186, 0.24803720054895018, 0.372998750927805, 0.297435628658561, 0.239361025259078, 0.16511912139843643, 0.26196941032051535, 0.19227021612564255, 0.2801980766737383, 0.25448182505292893, 0.22462564537802565, 0.2631384382246281, 0.35705040701391344, 0.22763169917911164, 0.2681955799109028, 0.2279336622460093, 0.24752882088920292, 0.2522509295499572, 0.21745072077356442, 0.23366452277235816, 0.2206131729615617, 0.22648736893489763, 0.23670930770828125, 0.18671634662042014, 0.1929822731277372, 0.21492875025591163, 0.18289189362076919, 0.1886440367653056, 0.20033786362215467, 0.17112890672978587, 0.22063352253032176, 0.18706938942370255, 0.16678373345879738, 0.1651511575921697, 0.17122534758508268, 0.16758377094276988, 0.16102124360320014, 0.7473071837573639, 0.1676612395157614, 0.7558154460249311, 0.6503643057378192, 0.20394907150341035, 0.7138651261489125, 0.7346438180193989, 0.20703730870309556, 0.16621246134910417, 0.7163509724910815, 0.7202859075634316, 0.19742617218221659, 0.19372052135400109, 0.20835903919661491, 0.21187071276396074, 0.19818576771992735, 0.18481028771651808, 0.1882032710924656, 0.21147754671589036, 0.1878361883291233, 0.1962075174637441, 0.07957923835264358, 0.11843991719462088, 0.08690771725688706, 0.08528412127047436, 0.08092383231855493, 0.08474331147718417, 0.09180132946563335, 0.10542299369331543, 0.09291681413081565]}, "mutation_prompt": null}
{"id": "bde0917b-fc2c-4ad7-8adc-9d825e1fd9d0", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.5\n        self.CR = 0.9\n        self.elitism_rate = 0.1\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    self.F = 0.5 + 0.3 * np.random.rand()\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n            # Stochastic ranking to enhance diversity\n            ranks = np.argsort(self.personal_best_values)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:  # Introducing stochastic ranking\n                    swap_idx = np.random.randint(0, self.population_size)\n                    self.positions[i], self.positions[swap_idx] = self.positions[swap_idx], self.positions[i]\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Enhanced hybrid PSO with adaptive DE and stochastic ranking for improved convergence and diversity.", "configspace": "", "generation": 69, "fitness": 0.26011387202256514, "feedback": "The algorithm HybridEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "metadata": {"aucs": [0.6769610533153615, 0.6270883536263392, 0.655153852774736, 0.6032972366842878, 0.6896689888907588, 0.6876570398668052, 0.6866938792908066, 0.6978199734571386, 0.5639019364746001, 0.22715661932263775, 0.20000600279490055, 9.999999999998899e-05, 0.0703081767855449, 9.999999999998899e-05, 0.03972117715515722, 0.21055328255301253, 0.01632518349274592, 0.15437710013438155, 0.103088357693226, 0.10791421414101876, 0.13835488306311328, 0.13473356393520097, 0.12680939467966457, 0.11023402553361161, 0.1154924144939028, 0.12070703783563552, 0.0986683933939757, 0.1030217488506402, 0.0820348746473617, 0.10707344175893452, 0.12784543968441664, 0.09404325923535894, 0.08635958734934268, 0.07996999360734847, 0.07219985725254752, 0.0941704654576686, 0.9833032736518443, 0.9885013178256807, 0.9791732992572562, 0.9898674477315182, 0.09938713547856148, 0.9703653748481801, 0.9802350858485037, 0.9879397562777151, 0.9905236634595068, 0.38117161104007347, 0.4071336803056834, 0.059209807744844856, 0.29589073875547744, 0.1460107885212779, 0.33825442242416603, 0.08212543646599002, 0.23200187274068507, 0.4339854813437807, 0.16712677762075634, 0.21413509094925698, 0.5674890695989512, 0.2605409492768236, 0.7489892007547236, 0.18744316474195943, 0.22237946808232645, 0.7880646328723759, 0.7797247591637074, 0.27891669899806726, 0.1173290214430841, 0.10863740279248091, 0.10063928820754242, 0.12980605302448844, 0.19488684592748717, 0.21019310025974858, 0.302557909226814, 0.34778965644074833, 0.31357462723084983, 0.27505051244600986, 0.17264622980888822, 0.19493150170058304, 0.27511040172290546, 0.22813355275907743, 0.22974134842609362, 0.21871125793955903, 0.2903526388054686, 0.09256146690903255, 0.0016548305255140727, 9.999999999998899e-05, 0.0978240018733415, 0.049338218926866295, 0.01954694086912201, 0.18754917886039035, 9.999999999998899e-05, 0.023348559298703497, 0.06327830667940393, 0.07042277599205704, 0.07352927959839539, 0.09265038296195505, 0.01683573163570451, 0.07910949178316462, 0.04927644917866714, 0.0335521913541692, 0.18435038188047848, 0.027848444470277678, 0.1059338112399586, 0.15060182182088944, 0.05996979806202163, 0.10821458773805626, 0.05662764946091481, 0.04031408295292127, 0.12118784833338192, 0.054168008747083385, 0.23174258493161604, 0.1775916353298702, 0.13128152862151932, 0.22043849357748746, 0.16712481910575683, 0.14815597307923944, 0.046982811770554855, 9.999999999998899e-05, 0.09242557988429412, 0.5011661407201573, 0.5103531438180495, 0.4846224266601803, 0.5618575772928025, 0.5106317305326677, 0.4927149347644926, 0.4134009189475779, 0.5548271706158687, 0.48279478806623133, 0.10132144809527521, 0.09992939237876286, 0.14748796030461397, 0.14221765134288922, 0.09949140555127856, 0.0957181151947476, 0.13239306066923617, 0.07797603533318032, 0.14250360807417783, 0.2341626807855408, 0.23811141294547133, 0.18293623878023824, 0.17946540774652042, 0.2380852989091834, 0.3164443143286769, 0.24600100483741838, 0.17179322824434873, 0.24110337055522846, 0.26033466343853384, 0.27098455096410623, 0.3057859626827064, 0.38791245798365304, 0.3679785516884102, 0.2932762598412103, 0.3165733832065982, 0.22615878382951338, 0.3608807190540906, 0.24948906275769878, 0.20281652758367685, 0.2818263748830957, 0.1844474301370599, 0.24561566306925875, 0.26229380162380744, 0.28547991162278596, 0.23263170766312768, 0.3123811428102786, 0.2695640864477252, 0.1858642193583393, 0.23642792136711077, 0.24032909643227995, 0.19704150475597715, 0.22066176126841752, 0.19625022643238466, 0.1837294052144791, 0.199378116969112, 0.2121065624391093, 0.20954070568358585, 0.18563589469925468, 0.34654311705271523, 0.19469541207170027, 0.2171530158360171, 0.18989343025896577, 0.18460023159009464, 0.17682428814783147, 0.2056974644560896, 0.16526146981738532, 0.16468784887580645, 0.6407143526955299, 0.16904613983262695, 0.16092393807405037, 0.7402633078364709, 0.6602419448300607, 0.8045528250772933, 0.5965096260066849, 0.20879212561093097, 0.573568258308547, 0.678025694352521, 0.20915920587594772, 0.15143919925894656, 0.09346478755774967, 0.7868974202577803, 0.21193578172881444, 0.18521567724224963, 0.1990966335875991, 0.1826249783274153, 0.17767194994864477, 0.18028023478303734, 0.2299298019665862, 0.1745628943038826, 0.1778008352962246, 0.1912350908186271, 0.07821299037471219, 0.09752684654087551, 0.07729183642325332, 0.07006829486133559, 0.07538814616902001, 0.07492659894489495, 0.06890891743585703, 0.07681081767313158, 0.09791617473744918]}, "mutation_prompt": null}
{"id": "f05ad5e9-870f-42b6-9e97-7914caf42c32", "solution": "import numpy as np\n\nclass HybridEnhancedPSO2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for diversity\n        self.island_size = 5  # Adjusted island size\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.inertia_weight = 0.9  # Initial inertia weight for dynamic adjustment\n        self.c1 = 2.05  # Increased cognitive component\n        self.c2 = 2.05  # Increased social component\n        self.F = 0.8  # Adjusted DE factor\n        self.CR = 0.7  # Reduced crossover rate\n        self.elitism_rate = 0.2  # Increased elitism rate\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1, r2 = np.random.rand(2)\n                self.inertia_weight = 0.4 + 0.5 * (self.budget - self.func_evals) / self.budget\n                self.velocities[island_start:island_end] = (\n                    self.inertia_weight * self.velocities[island_start:island_end] +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions)\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Adaptive Differential Evolution inspired local search with modified parameters\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            # Elitism: Retain the best, adjusted according to new elitism rate\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "HybridEnhancedPSO2", "description": "HybridEnhancedPSO2: Enhanced exploration and exploitation via dynamic island management, adaptive inertia and local search tuning.", "configspace": "", "generation": 70, "fitness": 0.18692374661434194, "feedback": "The algorithm HybridEnhancedPSO2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "metadata": {"aucs": [0.40676344332848635, 0.4677240921774122, 0.40857975961535853, 0.4060545153388059, 0.4795177815929562, 0.383734105143829, 0.36611838113780415, 0.3708865268995062, 0.3609870119235066, 0.02252225447604339, 0.014378283082069121, 0.02028989929838587, 0.07361205820095151, 0.09112498290710924, 0.01611408373064005, 0.019942882085434377, 0.010827248701127057, 9.999999999998899e-05, 0.10023977262578487, 0.09033995753548008, 0.08690124858002635, 0.056956361282273105, 0.10907256505512797, 0.04489819453576982, 0.09439490931173844, 0.10942299358087892, 0.07701583487046593, 0.08095703897402218, 0.08475906005598155, 0.06939196449205842, 0.08249578141689273, 0.0826484197148658, 0.07907239333335492, 0.10562825090900185, 0.07675307711217005, 0.08353973171565376, 0.9911009400497511, 0.9883811046097215, 0.9779365485127354, 0.992228250274753, 0.9885474922551419, 0.9892688290581465, 0.9860096123050207, 0.9850915098509299, 0.9911445235521782, 0.21357133790495186, 0.20081081812967272, 0.056109773449430356, 0.1428274721328575, 0.21649991652571876, 0.12685990395756508, 0.0827544850320362, 0.1918018753440517, 0.23383919770758266, 0.25190672407781145, 0.4687766101762427, 0.43881098570628674, 0.2986067633781536, 0.18650277808008153, 0.37447341986233684, 0.12430091702844892, 0.1613029686931552, 0.15291574583105016, 0.10846493485179676, 0.11962795695360728, 0.12850177887274716, 0.09727240963873951, 0.11910755707273124, 0.09094779661976482, 0.09203169467385397, 0.10506854712207347, 0.10099911318897903, 0.10803761418960645, 0.13649536098546344, 0.044308179769317224, 0.09398256930378701, 0.10691830398183488, 0.059320523913218515, 0.11869644460856854, 0.11606336708015463, 0.12188035660157182, 0.03676929061104306, 0.015463220285654833, 9.999999999998899e-05, 9.999999999998899e-05, 0.007025327561256067, 0.00332040676098988, 0.01810880459681108, 0.02734712238508563, 9.999999999998899e-05, 0.06855662268917773, 0.09547901579637075, 0.036602998699715505, 0.028535286276978655, 0.08753352204408926, 9.999999999998899e-05, 0.0835866142266799, 0.08981614830555684, 0.021741661448561045, 0.013402118641260174, 9.999999999998899e-05, 9.999999999998899e-05, 0.02332948592839179, 0.07189033157410007, 0.012105914175891797, 0.014360138725851956, 0.019806227322794467, 0.016699333048161513, 0.02985734106913973, 0.06545187055095825, 0.014912366552900513, 0.04162728135651994, 0.10426803154482966, 0.07462092568190182, 0.043295630444060595, 0.03549607788832998, 0.06474558034276345, 0.3408639145045034, 0.3748250418410949, 0.31166275458102355, 0.37010428578065657, 0.37637237044753225, 0.3614631410937934, 0.37040941470463384, 0.3686971930541826, 0.34340271221649477, 0.08540619198666732, 0.055496161480314, 0.07842957859637756, 0.07399501270415398, 0.10384116846764524, 0.10539433300264411, 0.0941925974508877, 0.09610516469190933, 0.08514106962155132, 0.13416167200832207, 0.146804368167617, 0.16548169002658464, 0.1665957397763035, 0.15749325465853148, 0.18058929338204632, 0.14932260131359976, 0.19512111357893058, 0.13943497656601633, 0.22064843522031707, 0.30246020904890825, 0.23545887536203414, 0.2545850452725106, 0.18961931166517654, 0.28724173198394676, 0.27981384643337925, 0.26346796953447715, 0.23667776854751554, 0.1993622416941362, 0.1868341417251157, 0.18543608077524953, 0.17472769571269275, 0.16517643206528498, 0.17492220807409298, 0.18889910331632875, 0.2094883073894387, 0.1760083706247504, 0.1649728688181984, 0.18972878879732147, 0.16316731041617427, 0.1870604186055156, 0.19887720569259593, 0.19901250065421527, 0.19266696471918465, 0.18022512994120865, 0.19194425045151875, 0.18073340396783966, 0.18093004517562117, 0.16194189438513862, 0.16031355003697934, 0.1939988463893606, 0.1647520705461264, 0.1755908431803278, 0.16680300554018446, 0.1868639865167312, 0.151226412770895, 0.5122995822750522, 0.1656990638831488, 0.4505142413155935, 0.155256774860145, 0.15313827697735505, 0.18136583868350475, 0.15406965931187244, 0.16855955405660406, 0.12352301238986763, 0.16812303723503064, 0.4178919657912771, 0.3151808063011824, 0.17774894040461764, 0.13489462527138962, 0.1891793564974824, 0.20280192975892686, 0.2979140804889152, 0.1800751694671917, 0.16872588845182257, 0.18260332936342316, 0.18630010106642936, 0.19131280486040225, 0.18720291172254833, 0.18279472433255972, 0.2040586802583868, 0.18043580710685914, 0.05906663224046427, 0.07326405797854729, 0.06856549652283372, 0.07012853712680045, 0.06972461860800994, 0.07799983782677133, 0.0612803492767654, 0.06952548446164186, 0.061635431579508126]}, "mutation_prompt": null}
{"id": "0b2bae01-983c-44e6-af86-8b54800d57a0", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.5  # Adaptive DE factor\n        self.CR = 0.9  # Crossover rate\n        self.elitism_rate = 0.1  # Elitism rate\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Adaptive Differential Evolution inspired local search\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive adjustment\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            # Elitism: Retain the best\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Enhanced hybrid multi-island PSO with adaptive differential evolution and elitism to improve exploration-exploitation balance and convergence rate.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "metadata": {"aucs": [0.7438600366245711, 0.7064525682751424, 0.7538317593864988, 0.18959223207973108, 0.7429911866603132, 0.1897228403002591, 0.7507471952383207, 0.7603812349563183, 0.7507531672303389, 9.999999999998899e-05, 0.46232003988415904, 0.385197640349385, 0.46668556290676233, 0.4299478161936715, 0.34809006423034894, 0.4141425749766209, 0.17893220758675765, 0.047670272595686236, 0.10961500370848021, 0.08009530081327942, 0.10657989239185484, 0.09050537169832673, 0.09783616768539027, 0.14402429807677652, 0.1205080600135654, 0.11330069197501325, 0.09348018179744721, 0.10856956654456806, 0.09969056402692111, 0.10936852809433983, 0.1047211640411495, 0.09261016003622247, 0.10924278745085159, 0.10242283661549789, 0.11724991511944083, 0.05957979089006438, 0.9892101407509785, 0.9883054508324912, 0.9831699693183287, 0.9884952449799214, 0.9328305025963488, 0.9740441985019916, 0.9830545329187254, 0.9915846435657341, 0.9906123461400195, 0.6634882527080352, 0.47296814097667306, 0.059434822229704865, 0.6383861480986628, 0.39462797619583945, 0.4501760245570514, 0.12657224428806024, 0.5390189333029758, 0.08925623535423333, 0.2256108501276204, 0.37822767083041586, 0.21747558767174546, 0.3451132951510968, 0.2076409408373291, 0.8143919047633092, 0.7297197477148986, 0.17475794315161952, 0.737948758770534, 0.44222239893761006, 0.3558311991113715, 0.12557175454857317, 0.14101381291768045, 0.3013789310267707, 0.12357019230216315, 9.999999999998899e-05, 0.29887109070258555, 0.35793443751862997, 0.44608115301096474, 0.4724427496307593, 0.45732767235066396, 0.429463487638151, 0.548996975486233, 0.4304073873372841, 0.2800750867266004, 0.4339805188186119, 0.357374437447178, 0.18143960990085672, 0.05801957649320755, 0.2973274509449533, 0.15796152968324695, 0.03927253352787574, 0.21351153242393417, 0.007328044020184832, 9.999999999998899e-05, 0.2677939962069886, 0.025769806965169617, 0.19185099058280652, 0.15443417794340164, 0.1915642078497296, 0.03862384447499667, 0.11918496526892408, 0.36941427331264876, 0.42222365239553583, 0.3583835032497932, 0.0709004884551574, 0.03869235360244494, 0.040881062445005, 0.07326192185020786, 0.15914817163512684, 0.06277491678871194, 0.0659242964347464, 9.999999999998899e-05, 0.056881442490929635, 0.2739353130833725, 0.20543330712649754, 0.15835192958246247, 0.1410505974648233, 0.11592528834997207, 0.2804227624992973, 9.999999999998899e-05, 0.20822374455083648, 0.07559170827791184, 0.6414870035910102, 0.5858865794225927, 0.5853317550821568, 0.6205823942805316, 0.5808775727523571, 0.5826197592057752, 0.552611995767498, 0.5443718403811582, 0.6112651976163702, 0.11766911917196066, 0.07432912261403779, 0.14455963416566997, 0.16935769451658234, 0.04419522494010797, 0.07887053252987752, 0.10786416857472136, 0.07337130296869343, 0.07579920581815591, 0.15470476600922667, 0.22768893974539628, 0.20790583211316782, 0.40021400612502434, 0.2629329573015533, 0.161525358284614, 0.19196019654255392, 0.17202536031458548, 0.23085178909275905, 0.32078803051396243, 0.31779748382955963, 0.3214156767696399, 0.3448939651374523, 0.35042617552217725, 0.3855327658554848, 0.37008688172557136, 0.2946873831936425, 0.2819199020857168, 0.20341671454461308, 0.18486865764038551, 0.23624432414323315, 0.3502076537948845, 0.3661223567731584, 0.40040194297108866, 0.23461389926092024, 0.25811271069038644, 0.39405327889041364, 0.25818856708682336, 0.2187253314674823, 0.23805005888605724, 0.2691696437517854, 0.268967697785939, 0.21271435067856614, 0.22688599323271952, 0.22468261776506815, 0.2052724573814848, 0.20170683680135248, 0.18907184366162, 0.22115111820480693, 0.181094858308414, 0.18721890329564883, 0.18382534041720966, 0.1863895357201516, 0.1887632959036356, 0.17834114274869695, 0.18029296115833804, 0.14727267171778802, 0.19744913255771268, 0.8385311308258134, 0.16897495902752857, 0.16224257605937087, 0.8670400165950415, 0.7841957144626193, 0.8796841325357007, 0.8293621410415113, 0.210303789613405, 0.7629417637448608, 0.8747616654011698, 0.20740123649685938, 0.15127915443120654, 0.09447001466151983, 0.8584860728900745, 0.2077018560420455, 0.2019448031321952, 0.2084333969479808, 0.20476411193282862, 0.2470341743229033, 0.20854859017942595, 0.1853310828261162, 0.20651976515577442, 0.2031265187402359, 0.1784199811039756, 0.14566244020795238, 0.09088934885863564, 0.10145098666690244, 0.09025360613743683, 0.08667740252273981, 0.10816990843197616, 0.0773752952271598, 0.09362177683678508, 0.098651373011296]}, "mutation_prompt": null}
{"id": "8d329ead-9538-4378-a260-68a726db60ee", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                # Fitness-based adaptive PSO parameters\n                mean_fitness = np.mean(self.personal_best_values[island_start:island_end])\n                self.c1 = 1.49445 * (1 + 0.5 * (mean_fitness / (1 + self.global_best_value)))\n                self.c2 = 1.49445 * (1 + 0.5 * (1 - mean_fitness / (1 + self.global_best_value)))\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                self.velocities[island_start:island_end] = (\n                    0.729 * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Refined Adaptive Differential Evolution inspired local search\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    F_adapt = 0.5 + 0.5 * np.random.rand()  # More adaptive adjustment\n                    mutant_vector = self.positions[a] + F_adapt * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < 0.9, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            # Island migration strategy\n            if self.func_evals % (self.budget // 5) == 0:\n                migrants = self.positions[:self.island_size]\n                np.random.shuffle(migrants)\n                self.positions[:self.island_size] = migrants\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Implements island migration, fitness-based adaptive PSO parameters, and a refined DE strategy for improved convergence and diversity.", "configspace": "", "generation": 72, "fitness": 0.20451625219758507, "feedback": "The algorithm HybridEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.24.", "error": "", "parent_id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "metadata": {"aucs": [0.6904529999867866, 0.5715551475518152, 0.719933306481011, 0.7160410960080081, 0.6796966963991289, 0.515235032058643, 0.4436581354274022, 0.4755862525561101, 0.6311383775019271, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11010693797210225, 0.163294167962848, 0.1203621493028979, 0.11552221151375508, 0.13595609897060368, 0.12306745206371084, 0.114101752842649, 0.14713062491109563, 0.12009939209449061, 0.11133643950385141, 0.11779371672158356, 0.10440142393695606, 0.1345209810428094, 0.11420320022498143, 0.10337048843093022, 0.1135631618637295, 0.11127288891181675, 0.1120708960232738, 0.9863051081767407, 0.9792435233361826, 0.9633032859945765, 0.9920581643571579, 0.9794209913414665, 0.9858385289523273, 0.985143695418508, 0.9793730803617127, 0.9864274886801498, 0.32669336477324207, 0.054175546234719096, 0.05475372201932227, 0.23459950667108298, 0.24308193512159038, 0.27272161069658163, 0.030192125058037367, 0.04682259376670794, 0.21896096218445782, 0.39966203605164297, 0.44314997077140417, 0.32780625792082196, 0.2581412806801431, 0.6686554936922378, 0.18987303762743601, 0.3114713660163003, 0.24550234421923955, 0.20988063116746347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12030411720409173, 9.999999999998899e-05, 9.999999999998899e-05, 0.0682600515976508, 0.04837523843002911, 0.009453899441354219, 0.017289432667076055, 9.999999999998899e-05, 0.07211771458371019, 9.999999999998899e-05, 0.047762718026858275, 0.027392557450749866, 0.04837154929238241, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018291277869334377, 0.02469106796586462, 0.025026968018806106, 0.02498388496522097, 0.028457423672892945, 0.02710488901381647, 0.016772035578589195, 0.01156895085404508, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06709897719169566, 0.11417972700281354, 0.21309549494887614, 0.034624993489823286, 0.024349680566206233, 0.020293384367048195, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.4442940017425234, 0.45011458391593673, 0.4609490462516309, 0.44396635562755205, 0.4990859260980358, 0.4717069460754505, 0.4772702119346247, 0.46391537312047015, 0.44921271839263255, 0.13726090241967992, 0.08476157200133039, 0.0788732423766787, 0.1336075707898755, 0.11549332913457788, 0.11780031918749123, 0.04238404701110299, 0.03897926541567287, 0.03262830305900499, 0.18459810934497745, 0.1955420467647203, 0.18150721789440505, 0.35941949104691595, 0.24246921488706352, 0.17260243712075407, 0.16101030464325683, 0.14217157661123547, 0.17868180021395075, 0.3100103190986915, 0.2918827429122822, 0.32806556001449594, 0.3131393717463393, 0.28929816558295784, 0.3068953491678975, 0.34351302443553555, 0.38296040570490464, 0.3665043333005811, 0.16270624934366207, 0.08042756349596125, 0.21657556796176436, 0.1961873022801841, 0.21344399170109707, 0.20483287905125513, 0.28584467642828026, 0.2452988828021343, 0.21230752352246274, 0.22361441718969144, 0.16297925933311141, 0.18515437993005057, 0.19931614928821173, 0.21410977739777703, 0.19919499079894043, 0.20065229785672545, 0.18672805109996182, 0.19102323583253145, 9.999999999998899e-05, 0.1552608924141372, 9.999999999998899e-05, 0.14810960280605068, 0.18416416861190632, 0.18577331923473217, 0.1170406880008914, 0.01961575179587327, 9.999999999998899e-05, 0.20935997636761072, 0.14132307380215337, 0.7501582915430439, 0.17053120046958958, 0.1654913175558509, 0.16834422261326631, 0.14104752682699107, 0.6226607447806559, 0.6929149202256779, 0.547171230210813, 0.20625523290147274, 0.40024621201157884, 0.16504477990465127, 0.34592353392853636, 0.15282509663404287, 0.13295393292500468, 0.1933622983364679, 0.19336695014674787, 0.19372864458999606, 0.20618563531979428, 0.19502639813790767, 0.18357987751204308, 0.20154284955655033, 0.21928931150670827, 0.21724413142086108, 0.21001293472212934, 0.1983781153378572, 0.08788821408966652, 0.08161584824857948, 0.08976750160067692, 0.08057969642192842, 0.08081698696840689, 0.08487115898582365, 0.08742109244633589, 0.0893172703142463, 0.0834327493369783]}, "mutation_prompt": null}
{"id": "38bcb9bc-ebc8-4f5c-9ca0-66da9b998985", "solution": "import numpy as np\n\nclass HybridEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5  # Adjusted island size for better exploration\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.constriction_factor = 0.729\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.F = 0.5\n        self.CR = 0.9\n        self.elitism_rate = 0.1\n\n    def __call__(self, func):\n        memory_elite = np.copy(self.positions[0])  # Memory for best elite\n        memory_elite_value = float('inf')\n        \n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, 1)  # Vectorized\n                r2 = np.random.rand(self.island_size, 1)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    self.F = 0.5 + 0.4 * np.random.rand()  # Enhanced adaptivity\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n                if self.global_best_value < memory_elite_value:  # Update memory\n                    memory_elite_value = self.global_best_value\n                    memory_elite = np.copy(self.global_best)\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n            self.positions[elite_count - 1] = memory_elite  # Ensure memory elite is retained\n\n        return self.global_best", "name": "HybridEnhancedPSO", "description": "Enhanced hybrid PSO with targeted adaptive mutation and memory-based elitism to improve convergence on diverse optimization landscapes.", "configspace": "", "generation": 73, "fitness": 0.2922264597649374, "feedback": "The algorithm HybridEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "metadata": {"aucs": [0.744231201042305, 0.7351965021738622, 0.7698901165578128, 0.7785890348427755, 0.7210611132064302, 0.7692266207350582, 0.7522819914531613, 0.669200522439985, 0.6549665775754341, 0.34958219868055906, 0.15895910896534682, 0.16315075658653988, 0.3043945614498237, 0.3257284780194779, 0.4885722884948591, 0.2006649302078789, 0.23548497742331664, 0.1812711251668413, 0.09569403143003852, 0.13751859934051136, 0.14027287736395233, 0.1262059150106013, 0.12705522342209374, 0.166280046401166, 0.14485439681919143, 0.09693561688750219, 0.04780930481484247, 0.10557331250033863, 0.17042291531458054, 0.09867325808241856, 0.13258844104223977, 0.06044419250155586, 0.09737599573244571, 0.14248965649712686, 0.09994919316835116, 0.10601318169301444, 0.9867641027635983, 0.992992129939548, 0.9669694048355135, 0.9888775377880133, 0.9709152275343025, 0.9511684758658749, 0.9641064055409313, 0.9796900875077765, 0.984627439482403, 0.4131698285862342, 0.42185706257061384, 0.05887177437286395, 0.41105961617804543, 0.5364121552861392, 0.14926891401866793, 0.53889615899821, 0.050271338035135726, 0.513148588345445, 0.8171535622648138, 0.228018598722043, 0.671199387856606, 0.2760569761812657, 0.2135075579523038, 0.20497923713856503, 0.8259403594592962, 0.8161515156195467, 0.35443341070775214, 0.20161759545669455, 0.11744680386111217, 0.3405114422815825, 0.25399602553003164, 0.2550257087477824, 0.4211665997670756, 0.43969267800541256, 0.1482901187828749, 0.3105428175972863, 0.3404524050687685, 0.5441345650302322, 0.12004714597522048, 0.2535473394222122, 0.1557706340448245, 0.38301789095412964, 0.12919111849597886, 0.43168946995222757, 0.2410211571907408, 0.04853273941678671, 0.0374936052954834, 0.11864313500829826, 0.1440366975697558, 0.13728146551806875, 0.22485576046968359, 0.06036798101371699, 0.062404942275991915, 0.07591517388008229, 0.18692971818375193, 0.12392823689535848, 0.21937105838822157, 0.08144092904692002, 0.18378691977978756, 0.09560972988089866, 0.3980558458457003, 0.21527755385584846, 0.04661462401273819, 0.04912940106149766, 0.042258422833806986, 0.00869131976418025, 0.11262243359977164, 0.16471606316862142, 0.05851175498718564, 0.07496001933383845, 0.09418574614911046, 0.08789255088034786, 0.18004014591437678, 0.1928142790424654, 0.009909283994478546, 0.1541723146636994, 0.18978559332889777, 0.17547992257445455, 0.1705155861942429, 0.08525119908880374, 0.07441274739886905, 0.6197361885249935, 0.5018570921148086, 0.6695906067369473, 0.541450698180532, 0.5360923303429455, 0.5456106975673272, 0.5380594109999816, 0.5684035803731664, 0.5341489494786338, 0.11874649295269224, 0.08301602312136092, 0.08856937382965502, 0.1767755784457593, 0.09788070235251578, 0.0980455912468644, 0.1389032466595025, 0.10971979547339528, 0.11195348898579072, 0.15758696551575135, 0.2929383617686755, 0.19583225902912738, 0.2606715650458754, 0.15360113278942322, 0.18704804409772946, 0.4634905815642306, 0.14904917300169218, 0.2818490446028469, 0.23560439409151301, 0.25225094999336695, 0.3404495801003632, 0.36424030263556606, 0.2743816482833725, 0.17191188566284077, 0.3141757758957642, 0.3147067604227989, 0.3571578384239159, 0.3443220028190571, 0.23270103770264527, 0.2644373684763718, 0.2255207426275947, 0.32436698554795595, 0.2754064886635115, 0.2686203779078695, 0.3025170822688855, 0.2256103252695657, 0.24728815183614528, 0.17756541155060224, 0.24320176783200487, 0.20605009773647187, 0.18976199018492534, 0.24096181064271172, 0.2172414973589435, 0.1915004377396603, 0.2467505170005465, 0.18494449741894092, 0.20348479141247544, 0.20868597170941694, 0.17159658889233964, 0.1740600703726115, 0.17616878354462495, 0.20823487415575903, 0.19550359044901422, 0.20714397648868266, 0.17954145111785036, 0.14815179702872994, 0.16412602951597233, 0.8042407777210503, 0.197426837573618, 0.16085637523022522, 0.14169455774821305, 0.12954767648152976, 0.878354977719728, 0.7821522529600918, 0.21059980324183603, 0.7582121191894733, 0.2046804664692834, 0.11184992476222688, 0.7239393929319662, 0.16733655251150104, 0.6403778564746465, 0.19458056699742543, 0.21188860427040623, 0.2271420202548391, 0.18096847191629417, 0.18256493503905125, 0.21994017176017888, 0.19262211438917243, 0.18728241245558963, 0.18238673012132323, 0.19016523763735982, 0.13715308700069673, 0.09020824823755924, 0.08840471528397142, 0.07693201292585361, 0.08831853494765984, 0.08646882707762638, 0.12558491319048992, 0.09603369003904594, 0.10185628600805285]}, "mutation_prompt": null}
{"id": "1af1ac32-c5a2-4e4c-9a60-36e8b3d77d50", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5  # Adjusted island size for better diversity\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.49618  # Adjusted for better balance\n        self.c2 = 1.49618  # Adjusted for better balance\n        self.F = 0.5\n        self.CR = 0.9\n        self.elitism_rate = 0.15  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n                    \n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n                    \n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand()\n                r2 = np.random.rand()\n                velocity_constriction = 0.5 + np.random.rand() * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    self.F = 0.6 + 0.2 * np.random.rand()  # Adjusted adaptation factor\n                    mutant_vector = self.positions[a] + self.F * (self.positions[b] - self.positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive island size and self-adaptive velocity control for improved convergence and exploration-exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.3206354974265678, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "77ff2d26-32c9-43ca-a71e-0095c5ac8160", "metadata": {"aucs": [0.8608634111845784, 0.8971040721955624, 0.8797774475436276, 0.8828167697230948, 0.1895428147962389, 0.8782710508782081, 0.8740868361394001, 0.8810742324912373, 0.8867195039689105, 0.6322347482310888, 0.4748944402293025, 0.6884411957159335, 0.7315410539803282, 0.27867522757676766, 0.7459759839595645, 0.5550163714980361, 0.6757589168872516, 0.12022083256715665, 0.14318243460975755, 0.159540548748909, 0.1022652562766867, 0.1167463669702844, 0.05568079152899208, 0.08219114173978892, 0.0750614002083535, 0.09761093679848765, 0.11058264412427488, 0.0848562415802393, 0.04604764275629736, 0.12552744070710853, 0.08349062637296989, 0.030838397330188116, 0.09412909907246725, 0.1338032415775311, 0.05654892210283646, 0.09351852231078117, 0.9767922023528287, 0.9888360966633903, 0.9875118692294698, 0.9811701450926156, 0.9809002586585907, 0.939972668089293, 0.9766617455974751, 0.9699135525072312, 0.9870426366523971, 0.7537175763535431, 0.739561928410459, 0.807395781757504, 0.7466047876869676, 0.6120153166687601, 0.15339997077874545, 0.794626610195591, 0.7488492145037121, 0.30516591994406495, 0.3697907219161912, 0.17138548345215188, 0.17039997612185342, 0.2825475640267765, 0.375665521212335, 0.19233859856293167, 0.24779559039129906, 0.17522043657903597, 0.9155048710935992, 0.7044522619947244, 0.34253338227162555, 0.222749708574849, 0.13023073440790067, 0.23134199411130152, 0.13285791122236645, 0.24708949587662388, 0.2601981723159804, 0.19744260654787493, 0.2185021890450719, 0.24750143451928808, 0.6911836602935941, 0.21039336669314812, 0.30217562093410466, 0.12064017882337008, 0.16903619946965698, 0.13228237561191292, 0.22935178044111915, 0.13738623888249424, 9.999999999998899e-05, 9.999999999998899e-05, 0.2524956378286439, 0.09322372017292546, 0.0028056489070026336, 0.05956591761134755, 0.025729350923490935, 0.0730983154443311, 0.09723758791672843, 0.09953744311630763, 0.1399617527850392, 0.17628906194700045, 0.1786655172796212, 0.11445621694024599, 0.19857841755672023, 0.07666075296794372, 0.13183912605929615, 0.026600872822730492, 0.2673680819561507, 0.29661870845047367, 0.09389246008532026, 0.1254351450704395, 0.07855938854821887, 0.07046378199060876, 0.10205112434327457, 0.1437933878632517, 0.3908671973792043, 0.2792000271071069, 0.1060723226971837, 0.10684628167219856, 0.43161085858220893, 0.09740708554956912, 0.26638889149189404, 0.13812984422787378, 0.19430407251146808, 0.7884411713660203, 0.7112566250292335, 0.5978353044090474, 0.6879724354707406, 0.6320924871639036, 0.6840560647307525, 0.679951520389831, 0.6228293054459739, 0.5776440262619937, 0.14236266889143212, 0.11602689923250686, 0.15928699656137646, 0.14213773618238024, 0.09647443509538767, 0.08336647874245662, 0.15843532295438822, 0.09305319036420623, 0.13775286425591404, 0.20261705303705857, 0.12946455600313544, 0.23785432458857048, 0.16827178834492207, 0.22906325984892484, 0.1897264515260103, 0.15661107352336945, 0.5053834207119557, 0.19528391725317418, 0.22320438530511866, 0.16431815905296754, 0.3534324360874683, 0.243058725124499, 0.2911300323471716, 0.2929700637349494, 0.2155635103367557, 0.39103156665208016, 0.25101091091471794, 0.2218925428781776, 0.23122102919958942, 0.21759561452097032, 0.3276321118991362, 0.32338984458876663, 0.3129776689311845, 0.2400741149613126, 0.2545518423145159, 0.1690801246782928, 0.25787497271010384, 0.1956698768518661, 0.25200793000710386, 0.26073519683565705, 0.24299502537028161, 0.21939738282280452, 0.26246311429258606, 0.24669218301282458, 0.2721521205889328, 0.1824076435825568, 0.17940321020210392, 0.22664981531216244, 0.17332724599948723, 0.19885506453973123, 0.22969131379288432, 0.18102897827159936, 0.21062983415747827, 0.18134771159546104, 0.18790662072297548, 0.1850388601135201, 0.16718244963245066, 0.933409940681072, 0.19977913256280222, 0.2006522637715653, 0.142290380954325, 0.9009477910254264, 0.21050242858882762, 0.8740388828477739, 0.21173157340536686, 0.8473205819491149, 0.8861976292464409, 0.13543425118234442, 0.15140584582105676, 0.16774501634653438, 0.8450980274883667, 0.2101913144697185, 0.22742395074463284, 0.2380038815599581, 0.20754504029337206, 0.17696672408309844, 0.23067453571642205, 0.20721177573087035, 0.19840626726778998, 0.2682235089974748, 0.2281623429612658, 0.09769130242609114, 0.08365563375623919, 0.08960003962065899, 0.1052370137701788, 0.09820971829262803, 0.11606422207766298, 0.1717335336598097, 0.1097715254373105, 0.08437183535164128]}, "mutation_prompt": null}
{"id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 75, "fitness": 0.33982937557201887, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "1af1ac32-c5a2-4e4c-9a60-36e8b3d77d50", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "e04d6184-ea69-4c0f-81fe-675879c4f1ff", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  \n        self.c2 = 1.5  \n        self.F = 0.7  \n        self.CR = 0.8  \n        self.elitism_rate = 0.2  \n        self.chaos_parameter = 0.5  # Added chaos parameter\n\n    def chaotic_map(self, x):\n        return 0.9 * x + 0.1 * x * (1 - x)  # Logistic map for chaotic behavior\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  \n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))  # Use global best for stronger pull\n                )\n\n                self.positions[island_start:island_end] += self.chaotic_map(self.velocities[island_start:island_end])  # Apply chaotic map\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with self-adaptive mechanisms and chaotic local search for diversified exploration and intensified convergence.", "configspace": "", "generation": 76, "fitness": 0.3063084225468887, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8938937189068394, 0.8745407554124993, 0.871687571656622, 0.8676414168948265, 0.8799964944584944, 0.8910713043014904, 0.8754772135129342, 0.888329837395962, 0.8725330688455298, 0.5057988989549873, 0.04070844841315102, 0.4422859671167967, 0.7105240227389079, 0.5508598398965038, 0.6776014802627779, 0.7096461289021452, 0.7230051690973501, 0.6662835577848598, 0.1433476590582855, 0.11058731276017697, 0.12101041266143908, 0.14213356840405045, 0.12029663066829488, 0.1321111121523898, 0.12972342635460332, 0.09621246529305261, 0.071663296924104, 0.11588475090148931, 0.11482663427712814, 0.11038421100003193, 0.09901582773800688, 0.07059412019767064, 0.08490367849567537, 0.08730723089257231, 0.04917255069951465, 0.10738031338228371, 0.9814042204419662, 0.9766995653939398, 0.9750569494776684, 0.9821439265107594, 0.9687315932376401, 0.9301157258278409, 0.9795452409481638, 0.9836017263453468, 0.9914444143631744, 0.8252075404652808, 0.8097201409449069, 0.7994604132464197, 0.7232023563031074, 0.7571337495011599, 0.1515390101518067, 0.7199085006709589, 0.7364857688003104, 0.7927140028530044, 0.22878183818200382, 0.36509539137646196, 0.221479972781089, 0.2804153651705268, 0.2108603193958689, 0.27719592989069375, 0.3619388615299367, 0.8964537218273333, 0.2447443500551595, 0.1796312958928058, 0.20074919301620553, 0.2566772693286199, 0.24108384426074758, 0.13048771823901484, 0.13315397131544238, 0.19919780028647904, 0.2194177583026058, 0.19765261935776046, 0.24778927081886437, 0.20951321911278897, 0.21353714317671346, 0.18869959584683071, 0.19604661715545413, 0.22274854799257493, 0.22294888503833632, 0.2747222615091023, 0.13617922127062843, 0.07920180339337402, 0.08196235534531793, 9.999999999998899e-05, 0.016674690707251694, 0.07071146194423306, 0.001613573805936741, 0.00969216332305567, 0.0002574817528441242, 0.00794407548553877, 0.12048831934655335, 0.09077955635669654, 0.061875285000427716, 0.04582512434603214, 0.017561244797189457, 0.014771484003736957, 0.09348541723036818, 0.058529296885103554, 0.043996308218121505, 0.05010570803911518, 0.26009543559069004, 0.11486420379156337, 0.09008531724270885, 0.1256339914847736, 0.0764818339204989, 0.07189229251304641, 0.2280942695618552, 0.07131447251335044, 0.3786331448228568, 0.09628248872101963, 0.11821972370409917, 0.0998666252585757, 0.09414511126018221, 0.07487596832185806, 0.08678494858370123, 0.08268782994317503, 0.08212152853728782, 0.5530567184135176, 0.5503960496756373, 0.6199731774311683, 0.5922539705667662, 0.5847204863310941, 0.5731251050404391, 0.5941583371392791, 0.5873680030255485, 0.6011578069895358, 0.14073202663566586, 0.10806572694681693, 0.12426433677847415, 0.1067364331271774, 0.07795528882574854, 0.14236408505151887, 0.13260754634472738, 0.1315496667959677, 0.06648452449325448, 0.4058317968362568, 0.2542358847424022, 0.23085346716028643, 0.19772885308142107, 0.22967625037493067, 0.26753365141994156, 0.23491379878477503, 0.19115315023579516, 0.15248808644922918, 0.18034805768690998, 0.16670916362402566, 0.3715035888732857, 0.3188008988170591, 0.38729372776955584, 0.30116663933440246, 0.340274149596566, 0.4503688264159138, 0.33758741055325836, 0.18267955514834433, 0.21393393538022587, 0.16732590720061802, 0.2702221191582703, 0.3162016502249628, 0.3044690258782433, 0.16262568845463776, 0.22379286092040906, 0.3346615426688595, 0.28204228673043663, 0.2847038146051817, 0.2384633339622364, 0.25728012867209005, 0.19462298718422588, 0.2242115949050283, 0.27749092626345095, 0.2149213996641709, 0.21430051726319377, 0.19649296335171273, 0.22838922739395173, 0.21060142658598136, 0.2120573065391239, 0.1968612690290623, 0.222632846970369, 0.19377527717900178, 0.21675549097925395, 0.18844826488820976, 0.18784277993471832, 0.1679883728433208, 0.16600497147245385, 0.940382575323078, 0.20005856243166598, 0.16686030770569837, 0.14241582058561653, 0.9013048912311559, 0.17251132174980033, 0.8551666979334834, 0.20745481527152354, 0.16754128582659256, 0.22358202447090436, 0.7936014466495391, 0.15538277203118356, 0.48572906799643034, 0.12977780902171454, 0.2028689827659631, 0.24349020665957521, 0.19678100759560124, 0.19566409063122348, 0.2277738913496269, 0.21555795033782077, 0.18137186786719617, 0.20393400805931217, 0.21500741620260488, 0.20704817021857036, 0.08307711067414603, 0.098065476633168, 0.10409099208278982, 0.06865375938515428, 0.1109440865237008, 0.09904059147723854, 0.07022098637049856, 0.07619388834997776, 0.05641776611621885]}, "mutation_prompt": null}
{"id": "964c7ee9-1235-4663-b8ff-dce790ba61ec", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "64943c4f-1516-474a-9fa4-62fef3dbd213", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "57b0d5c6-7e56-4057-b475-c273b3b9a86b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "8ac4d60e-8965-4f8d-ac62-a76a90333bad", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "4af1d1a0-b8bb-46f3-83c0-2d06644804d7", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "38598e54-2a31-43ac-b0fe-f62daaf68bef", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.7\n        self.CR = 0.8\n        self.elitism_rate = 0.2\n\n    def __call__(self, func):\n        chaos_map = np.sin(np.linspace(0, np.pi, self.population_size))\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                adaptive_c1 = self.c1 + 0.1 * chaos_map[island_idx]\n                adaptive_c2 = self.c2 + 0.1 * chaos_map[island_idx]\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    adaptive_c1 * np.random.rand(self.island_size, self.dim) * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    adaptive_c2 * np.random.rand(self.island_size, self.dim) * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                if self.func_evals < self.budget * 0.5:\n                    if np.random.rand() < 0.1:  # Occasional island restructuring\n                        np.random.shuffle(self.positions)\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive island restructuring and improved exploration via chaotic sequences for dynamic parameter control.", "configspace": "", "generation": 82, "fitness": 0.28679233911083707, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.9251231152809071, 0.9214241570545055, 0.9251412375831627, 0.9016752392597801, 0.900049594293203, 0.9157056301573427, 0.9141980402263243, 0.9215688794306004, 0.909311279540217, 0.5145240156083234, 0.47407172080621107, 0.2585454574902163, 0.5599294274665567, 0.8296038663331111, 0.8206938182175693, 0.3931492440087403, 0.7672275023282303, 0.4218323785924385, 0.15785388333140693, 0.14509295349346574, 0.13251810586017798, 0.1042312278515044, 0.11554006338739475, 0.14306327539885588, 0.08445306662394236, 0.14565804374198377, 0.13222986513080304, 0.08188190242518234, 0.08433927068550562, 0.0952231465033283, 0.14068015764222708, 0.06566142197468527, 0.13228283218633952, 0.08955774724805632, 0.10459939909233418, 0.07142251226270457, 0.9804411011697307, 0.9910269751603753, 0.9713188009341457, 0.9921435745786206, 0.9816998285878191, 0.9829731083909601, 0.954666364044144, 0.980532922493043, 0.9901682039710697, 0.7831130910602592, 0.7445780170447586, 0.0864517814522826, 0.6021126385376117, 0.15294640699423112, 0.4838885656190567, 0.7321522677037894, 0.15176066930221477, 0.6665608195668057, 0.24474311360392664, 0.24162219170555177, 0.22733987952186863, 0.3349759192263234, 0.2155422375179733, 0.2089668966186925, 0.14046894702299684, 0.23624922324645292, 0.18218784076912986, 0.2558724494311767, 0.39920098741017995, 0.22702319788477332, 0.13135501979915776, 0.10806881554716352, 0.12989707554026486, 9.999999999998899e-05, 0.14015200510448378, 0.16702256004328897, 0.22619627081931215, 0.178882609640185, 0.11842545287433281, 0.14754195865525965, 0.20814001349989075, 0.15273063107845497, 0.2161126107182657, 0.13294270157601118, 0.13149942352935118, 9.999999999998899e-05, 0.018448295214596122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01615791507314046, 0.07028370590321809, 9.999999999998899e-05, 9.999999999998899e-05, 0.08734709421637765, 0.08700280943862804, 0.07450278297326063, 0.039394947461530716, 0.00915058144907599, 0.030441108804658334, 0.0500327547512599, 0.0372414201354635, 0.0411695361212121, 0.08673720589053624, 0.05225160512411364, 0.2872287448661087, 0.2507741512126047, 0.12481233253534063, 0.08284488888078301, 0.08065439288740328, 0.1680026789590513, 0.11812952512041552, 0.09674257888205251, 0.1727320856248027, 0.39002795858258177, 0.06462777923214869, 0.1401475455113661, 0.06016454540530025, 0.07109160815647753, 9.999999999998899e-05, 0.08528483849347701, 0.5571712055805401, 0.5720642499478419, 0.5472532701771664, 0.5266600807538394, 0.5347275423054575, 0.5286200806239867, 0.5803451158018242, 0.545342973559666, 0.5949054976699614, 0.08755288396562555, 0.08679051839168261, 0.09520760323873545, 0.06991561744865593, 0.142102058037481, 0.11868888578757308, 0.09436206096094446, 0.11328363718759227, 0.14352759453925157, 0.3728815538453799, 0.19988964163248213, 0.2577494960658975, 0.25165119492944854, 0.15220288540643012, 0.19277856463279008, 0.49680219545363835, 0.34783289558064345, 0.19743440910754906, 0.263935464200615, 0.48142176913905343, 0.4960574879014463, 0.2579975644747977, 0.403886755670708, 0.3064974270851196, 0.31956155035563016, 0.2761954795949013, 0.2683297313138965, 0.22447584542059285, 0.20131289414644615, 0.3790704984771337, 0.3121645566226966, 0.18515100335753643, 0.17334175949080055, 0.28803569869954315, 0.3094710470279515, 0.21721732057074872, 0.21091649336768148, 0.20028560620137437, 0.2178309291154651, 0.21361731532802763, 0.21312218494203827, 0.21356766403053984, 0.24657771393369177, 0.2174338535223589, 0.20155900862226195, 0.2120090772386385, 0.19859474032784052, 0.18041821045823558, 0.20101253660127105, 0.18004316428920752, 0.2034785827901402, 0.2263883011489638, 0.23702165664817, 0.20061847585597192, 0.2135635214417707, 0.18799551733078534, 0.16579158624356383, 0.1364901165587762, 0.2008721000366167, 0.1626093950492402, 0.9352190140324812, 0.1421109410450847, 0.9154570431085025, 0.43730458086660706, 0.15711642943068926, 0.07351109953048052, 0.16757799829487807, 0.8270878293857818, 0.15258847833938072, 0.09498048050205721, 0.10467237932274931, 0.20471924635811978, 0.19112184009982613, 0.1841397040358569, 0.1931088392846435, 0.18717633783026122, 0.18461587032038362, 0.18377729769716644, 0.18787160302332473, 0.1810492853678839, 0.20258552360404525, 0.1029000732014016, 0.08035467721613221, 0.13302670654074866, 0.10062037508914057, 0.09050391924925205, 0.10250998732647676, 0.11740023433956781, 0.08981191518703979, 0.08255415662680188]}, "mutation_prompt": null}
{"id": "804a18e8-fb8c-44b0-ad87-2e270918a484", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "7719fc46-749c-46be-a15e-5f32ebfbf075", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "ff9f7a25-fbd2-4da9-a5e0-40d1732b5f9a", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Chaotic initialization for positions\n        self.positions = -5.0 + 10.0 * np.sin(np.linspace(0, np.pi, self.population_size * self.dim)).reshape(self.population_size, self.dim)\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        # Temporal adaptive parameters\n        self.initial_c1 = 1.5\n        self.final_c1 = 0.5\n        self.initial_c2 = 1.5\n        self.final_c2 = 2.5\n        self.F = 0.7\n        self.CR = 0.9\n        self.elitism_rate = 0.3  # Increased elitism rate\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                # Adaptation of c1 and c2 over time\n                c1 = self.initial_c1 - (self.initial_c1 - self.final_c1) * (self.func_evals / self.budget)\n                c2 = self.initial_c2 + (self.final_c2 - self.initial_c2) * (self.func_evals / self.budget)\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                self.velocities[island_start:island_end] = (\n                    0.5 * (island_velocities +\n                    c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with strategies including temporal adaptive strategies, chaotic initialization, and enhanced elitism to improve convergence speed and accuracy.", "configspace": "", "generation": 85, "fitness": 0.28363480710348593, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.916018784013499, 0.9143236876140928, 0.9130821857910603, 0.9173528421323988, 0.9119034376213156, 0.912006985696657, 0.911930373462029, 0.9203853167489866, 0.9038954706352658, 0.19248980644681046, 0.1962036748596011, 0.414432809314342, 0.8075363426206968, 0.0959145216798386, 0.31068989493889565, 0.15054860242911072, 0.350256393832199, 0.4929889419764061, 0.10128428589884586, 0.11773518154340634, 0.1255837969720638, 0.06571285478309641, 0.10012625366747507, 0.13112426696681345, 0.14605460384994584, 0.11608053459299683, 0.14359264140368777, 0.09488114753662336, 0.11253593031761788, 0.08290610382792651, 0.11492700427760194, 0.06997397013830142, 0.06397292211869299, 0.06641976136120431, 0.08538973986062448, 0.09461295870136566, 0.9698878891326532, 0.9882293306274398, 0.976844617049024, 0.9770752485602185, 0.9698479209128075, 0.834272174070769, 0.9809290608516056, 0.9846534815745146, 0.9805755574711726, 0.33845599740616306, 0.6326003428747171, 0.2209059345687565, 0.7682085701102414, 0.7851661663401795, 0.77685962353117, 0.11719322775125851, 0.05439536560237612, 0.3657377988771042, 0.382645338335838, 0.2295618737961228, 0.3623604645600462, 0.9346746253256188, 0.19284388677975606, 0.10605914465270527, 0.23674855846995646, 0.31345414353188883, 0.1858408384178386, 0.35279258863777985, 0.1524674698612254, 0.1957605658014211, 0.16834244258092024, 0.12988138201609634, 0.13847938675034077, 0.13347088608540925, 0.16241174323211527, 0.241830790273051, 0.22496139599389575, 0.2107415462025386, 0.16119828087720545, 0.15266869399046012, 0.19173083233462207, 0.17469196632183737, 0.13313389010394017, 0.16818600261101635, 0.20006711792453602, 9.999999999998899e-05, 0.10435647139217075, 0.04582930000701524, 0.0575690749158817, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12529363254682924, 0.07635085284609999, 0.08183323362859862, 0.07587346178333321, 0.08545884154834782, 0.03211554413921547, 0.01579783152307479, 0.009667306801991238, 0.011367782773974433, 0.0917235516167686, 0.14716099332569132, 0.22142919104560754, 0.09789473593890274, 0.16860387620103578, 0.362151093542617, 0.1063756960614699, 0.11826541468296459, 0.20473153499204266, 0.23113476250847242, 0.53061995461391, 0.046551012856576146, 0.0388315264313247, 0.10565632824903548, 0.13323870307290453, 0.17980379545904834, 0.06497274452893997, 0.04969546397516733, 0.544512814744492, 0.5025649431884404, 0.5294845976468138, 0.5715240661305792, 0.49654532358701164, 0.6031053747065307, 0.5450150639932436, 0.5144861665401976, 0.6196722977931723, 0.09932399923425783, 0.04645030357902502, 0.10055027445934606, 0.09727507649765843, 0.09255615567690711, 0.134595172095331, 0.11017681782204636, 0.08961351529923034, 0.14605818188950925, 0.20773823710191885, 0.17633343540915647, 0.2196098987944829, 0.23264912466147203, 0.10952053676982687, 0.184665157319149, 0.19736185129135264, 0.22660951707696775, 0.1760880551377042, 0.20314666984807095, 0.3284316914345037, 0.2902825470549324, 0.4367909003550079, 0.47015591797012735, 0.22040146774100167, 0.23034044235500817, 0.18580619834394407, 0.32213814118695305, 0.17035211631518943, 0.1337427008955694, 0.23953457879407325, 0.2995258984592627, 0.21270955536400793, 0.3027200107126006, 0.18312022793999383, 0.17947980425879173, 0.1841402335427188, 0.2554734314739677, 0.2274166365414182, 0.27100321190055787, 0.23601940660553422, 0.27946312609450374, 0.22677986780406623, 0.21697519785732133, 0.25341350021171116, 0.24686833566204092, 0.2044860883726456, 0.18527750926892927, 0.17059108202569517, 0.18270194198488132, 0.18957502605187793, 0.20543194099486572, 0.18063358206635438, 0.19347726066195903, 0.19842866066586706, 0.1877912895574264, 0.18777488469607428, 0.9165527465054486, 0.15376619187044138, 0.9405698443123081, 0.1541820362784816, 0.18660307588824476, 0.17617790207750372, 0.2112108745848641, 0.49503742461518907, 0.27354531119826675, 0.5515476272399004, 0.5764264586412012, 0.15493431991996331, 0.09486299060003622, 0.8405731754481758, 0.16829085329786453, 0.3978734758919539, 0.25156212956449653, 0.1937097841967519, 0.21259178313603877, 0.22032715162238437, 0.2151471057137968, 0.19023466620260854, 0.2483546792488719, 0.24625425685381097, 0.20737223607219535, 0.09970018848734563, 0.12861189687855856, 0.08423605544227919, 0.07253393227075344, 0.09134304411274641, 0.08909571399469518, 0.1003623357728386, 0.1080562491125222, 0.10231187036428491]}, "mutation_prompt": null}
{"id": "38ffcff8-ff78-4b9d-84fd-7bd59613cf60", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.7\n        self.CR = 0.8\n        self.elitism_rate = 0.2\n        self.restart_threshold = 0.1  # New parameter for diversity check\n        self.restarts = 0\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            diversity = np.mean(np.std(self.positions, axis=0))  # Calculate diversity\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n                \n            if diversity < self.restart_threshold:  # Check for diversity and restart if necessary\n                self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n                self.restarts += 1\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with stochastic restarts and diversity preservation to improve global search effectiveness in black-box optimization.", "configspace": "", "generation": 86, "fitness": 0.24138450192134628, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.5039677995503986, 0.4770184675809439, 0.48178535461845573, 0.45594298455906745, 0.4812715980728385, 0.4723113458826125, 0.4511093902811938, 0.4946560800491536, 0.4866363689907933, 0.2099059175581428, 0.24828289658255176, 9.999999999998899e-05, 0.06289233253671245, 0.21758226334671904, 0.12921002724523822, 0.15822763403479567, 0.044930928486188404, 0.29984578756664815, 0.1406004728038306, 0.11147348247306799, 0.11251268346358245, 0.1290501085906257, 0.14736284374147068, 0.13139520138065308, 0.12009721996503353, 0.14899326549172676, 0.17652955084863153, 0.12714380367110845, 0.1236716747519433, 0.0896121403783553, 0.09852166672710283, 0.132383187984486, 0.13062614784268967, 0.11803636311023624, 0.12833073390858063, 0.11477817348335118, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.31904717843013763, 0.31448118369916445, 0.3202299067791068, 0.34228250802557236, 0.3271446947178781, 0.29849785755307034, 0.321113836986308, 0.2983487724376418, 0.30613145059507174, 0.7836530044777545, 0.2263524983366233, 0.4525793938276872, 0.280357454691049, 0.19120603829940253, 0.3640459817760907, 0.35698001932385315, 0.2329051137367243, 0.21973680633892045, 0.14441403067352798, 0.15292546671619256, 0.19121633695010865, 0.126310314623442, 0.17586762982649706, 0.16695856646200136, 0.16115204035490638, 0.1489440451284021, 0.18558090831278795, 0.1419031903190744, 0.1804481126166695, 0.17948557134808818, 0.24276327530269304, 0.12833642434194192, 0.18722578085837138, 0.1596114464264512, 0.17894477601553516, 0.17118022079027562, 0.09655756713161356, 0.022373750926111824, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009532900921216614, 0.025452182039025995, 0.05989478245789637, 0.12464451706473123, 0.03068242257748499, 0.08639526905790029, 0.06578827650361563, 0.06047621666337255, 0.03606706372345836, 0.061800891793504675, 0.07256830571063333, 0.06745167800498708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10978585969295851, 0.0771245229085562, 0.10082871205323041, 0.12470217855469634, 0.08704504968048676, 0.1366056761152491, 0.13145092262282165, 0.049257884609470004, 0.07991908157692373, 0.4243175401122917, 0.43920490329753625, 0.4494026071578845, 0.436783028083381, 0.4390591285623352, 0.4269487208792181, 0.4513664377391696, 0.41720342432074864, 0.445770554563356, 0.0718481526625061, 0.17207256758950606, 0.08085472402580396, 0.15144093235067468, 0.10314015302801127, 0.08317604731460038, 0.12678595216264654, 0.14825849176099148, 0.10370213771667292, 0.28659769297107873, 0.23553576666166587, 0.21718522401510265, 0.19903356457234223, 0.35495763590021556, 0.315096086924329, 0.23354611591195962, 0.1951730161563313, 0.19805899255103476, 0.24635041773496802, 0.31108547733478475, 0.27647565673896635, 0.31837552805842473, 0.3133131382016481, 0.3138994131266645, 0.30046097665942073, 0.3252861922224044, 0.32617392346027485, 0.19115617827536058, 0.2162776171917442, 0.2447695721161426, 0.21623661443601672, 0.2603467169257476, 0.21069162546503273, 0.22174117896622214, 0.26767679382782195, 0.21506056162768772, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2508505842064056, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007041172515751, 0.20162047102812342, 0.21815576097349687, 0.24968186578899298, 0.19996023954006636, 0.2239573918915081, 0.2013573991226093, 0.18507583858990395, 0.19653950316388524, 0.17236800092928428, 0.6992276743397672, 0.1872803026013371, 0.7388748488351211, 0.19870452399264016, 0.16960236158304998, 0.4825945441245363, 0.6076280284456068, 0.16938797691978613, 0.5237458009438066, 0.20821247675578747, 0.5644990202261817, 0.222772789454577, 0.1543203141963957, 0.6068268768162297, 0.18160709550481002, 0.21288124455371127, 0.16793922330067856, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.10493962088291287, 0.11194257499863813, 0.08725143338777219, 0.08925882564923793, 0.08841290653494949, 0.08134896995451002, 0.09006471901430468, 0.0912607287609708]}, "mutation_prompt": null}
{"id": "472f9b46-bf4b-4951-95ac-ac1b2a7de3d6", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "d327b769-4456-45a7-be28-219400e44918", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "5e6076dd-8c84-46f3-a131-b98759436a90", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.7\n        self.CR = 0.8\n        self.elitism_rate = 0.2\n        self.local_search_rate = 0.1  # New parameter for local search\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            if np.random.rand() < self.local_search_rate:  # Perform local search with certain probability\n                candidate_idx = np.random.choice(self.population_size)\n                candidate_position = self.positions[candidate_idx]\n                candidate_neighbors = candidate_position + np.random.uniform(-0.1, 0.1, self.dim)\n                candidate_neighbors = np.clip(candidate_neighbors, -5.0, 5.0)\n                neighbor_fitness = func(candidate_neighbors)\n                self.func_evals += 1\n                if neighbor_fitness < self.personal_best_values[candidate_idx]:\n                    self.personal_best_values[candidate_idx] = neighbor_fitness\n                    self.personal_best_positions[candidate_idx] = candidate_neighbors\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with local search and adaptive island cooperation for improved convergence in black-box optimization.", "configspace": "", "generation": 89, "fitness": 0.32838031447033655, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.888736823208608, 0.8967592233648862, 0.8951586817395298, 0.8998266088493125, 0.8972388719334597, 0.9068760806099632, 0.8935159773675562, 0.8913836573314808, 0.901081836479049, 0.7764315684309192, 0.7233419620465079, 0.7541092119250872, 0.7728949483317062, 0.7669025330977539, 0.7957537820029434, 0.7392586363667499, 0.7743479590411341, 0.7844859862673029, 0.11159555042551905, 0.14045516878349862, 0.15618990468394112, 0.1442779364691743, 0.17839814127481646, 0.15769420536468992, 0.1359444684414589, 0.14400145349970916, 0.15704656120731086, 0.09993307597593071, 0.12755436031395018, 0.049241050306637724, 0.11513996941838833, 0.13797235763004012, 0.09241870026359389, 0.13243152232896394, 0.15321708193334693, 0.1020032853551538, 0.9849253473847236, 0.9758322985382508, 0.9575722232552522, 0.9828829711990007, 0.9753868617644212, 0.2965718887905797, 0.982871133227801, 0.9791759782320464, 0.9855860599272902, 0.8119140244694706, 0.666081858563143, 0.7764692210394886, 0.8142063642573082, 0.7761119912460396, 0.7863186875243551, 0.8001777293026751, 0.6448325354666279, 0.7603814376280387, 0.39752172849053546, 0.6313310930730672, 0.24185442457229434, 0.21378110381238646, 0.2783800605948794, 0.3808409781232819, 0.1758635542618836, 0.23350731072262487, 0.2260549744370529, 0.1769175964489148, 0.13026704764419117, 0.19034042306611487, 0.20300104358184168, 0.1990447854325178, 0.13346028012103306, 0.20577541863052207, 0.1939713048730164, 0.20538822240405596, 0.23879598485122944, 0.11773396156818616, 0.21553704511430816, 0.22368408088639502, 0.24051509177714114, 0.22094512311971004, 0.26898647433980727, 0.13134668723817844, 0.21029183410144237, 0.15624706520724574, 9.999999999998899e-05, 9.999999999998899e-05, 0.03149796298989482, 0.03473115584849662, 0.10164527438928583, 9.999999999998899e-05, 0.09358277429116568, 9.999999999998899e-05, 0.06867856984816556, 0.07287722863678114, 0.11068488091210016, 0.09553066157702161, 0.06030425373396753, 0.040722208703772744, 0.07039016879893334, 0.06582789443911718, 0.09200251850582575, 0.12142265366834948, 0.09221247717244785, 0.14908863350166068, 0.11683210491154383, 0.1952561266200542, 0.1909250378270977, 0.07465667590253344, 0.2507444572691999, 0.12888908240860897, 0.07512481307524888, 0.10237956177212981, 0.13307632987266316, 0.05623378298137427, 0.08520827888439275, 0.10219178468956613, 0.14466986519555503, 0.06054403905618255, 0.08976260038988515, 0.5806950748494764, 0.5763052194004681, 0.5288275732900583, 0.5953815616771555, 0.5873520239889038, 0.5828092028665043, 0.5536979299790163, 0.6124476589307062, 0.5648788280499009, 0.14240146671255027, 0.10054164160928725, 0.08125360312760199, 0.11971189828589102, 0.15052660992618472, 0.15302101966163206, 0.17691254044666205, 0.1779245067136077, 0.1530136668117542, 0.7760202237922689, 0.24262468859264297, 0.16757564131466118, 0.20484946595958942, 0.24423763088837946, 0.254956586415225, 0.20283368943148705, 0.1722926038412277, 0.2773079586502002, 0.3417275594285366, 0.20183293916199962, 0.3594944076649734, 0.44843425545042614, 0.678169745776024, 0.3016959634127595, 0.7260461625363469, 0.5799386187697586, 0.533582635146326, 0.24227566988408644, 0.27758710596486125, 0.28041864535329475, 0.32927530176700737, 0.3267363229436526, 0.31317146586479283, 0.34588553064353056, 0.3185074459529257, 0.2935010315115347, 0.18786126758723531, 0.2378714612140026, 0.2456402074131102, 0.22509487635102754, 0.2018647417494398, 0.21334366356198786, 0.22452731597866238, 0.2351829808532231, 0.2281589277103412, 0.21044618537220283, 0.18758741119601696, 0.1958675643547736, 0.17348901082454504, 0.19012796199919568, 0.19817660972091589, 0.20157496106787187, 0.2098350988983072, 0.1835029269838463, 0.1710201072383536, 0.8994600381300247, 0.1668940298604834, 0.9388934528835076, 0.19936984770745525, 0.14136239294086428, 0.1426237792429107, 0.17398129463010592, 0.17600903602882956, 0.4392878596657529, 0.15460708724862926, 0.87053776335378, 0.16858125049469508, 0.2112656436260465, 0.9001319140447064, 0.7751312053545236, 0.21288022283743724, 0.16827472867257343, 0.18820854175649793, 0.19493427145164277, 0.21675915515934163, 0.19038519975305235, 0.19225358466716735, 0.19823591856820244, 0.17665289575888476, 0.17051474550711643, 0.1847976676248576, 0.0867993779792463, 0.09183654923546491, 0.1433676272158847, 0.10213086619607659, 0.0869687631109839, 0.0995654201224585, 0.08017149680288416, 0.09290163090462267, 0.09412175428157754]}, "mutation_prompt": null}
{"id": "1d06e456-4677-47b8-ba95-3070f53a2dea", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.8  # Adjusted for better exploration\n        self.c2 = 1.3  # Adjusted for better exploitation\n        self.F = 0.8  # Adjusted mutation factor\n        self.CR = 0.9  # Adjusted crossover rate\n        self.elitism_rate = 0.3  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                full_neighborhood = np.random.choice(self.population_size, self.island_size * 2, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[full_neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.4 + np.random.rand(self.island_size, self.dim) * 0.3  # More dynamic constriction\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[full_neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with multi-phase adaptive neighborhood search and dynamic constriction factors for improved convergence in black-box optimization.", "configspace": "", "generation": 90, "fitness": 0.3298573882181219, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.9132572811740597, 0.9042119223324856, 0.908944930842298, 0.904598286128793, 0.9026239972898953, 0.9021568048956606, 0.9045400734439204, 0.9172987833460862, 0.921070403090784, 0.765036072410587, 0.7974392671488247, 0.815376201781067, 0.7973843164310553, 0.7999793296719446, 0.8078291474572379, 0.07763745900944763, 0.8146801653531381, 0.8146690042943766, 0.1435705579541191, 0.15737758073998143, 0.1238528877650702, 0.15646298664357272, 0.11618736002322239, 0.11017648383911749, 0.11670815982246674, 0.08940000600180464, 0.15753484192292744, 0.1109071478930358, 0.0741576353540333, 0.11600205622772264, 0.1147177919620479, 0.10622091611469497, 0.08154380233667635, 0.09862023572481649, 0.1326157652722002, 0.11480380739363771, 0.9851463387168629, 0.9804901033319556, 0.9633110048047255, 0.9861397023107867, 0.9701034664007869, 0.9661086959354382, 0.9789378194553341, 0.9708703003208973, 0.9853539583393098, 0.8371266722340027, 0.8094333793198193, 0.8218912049622017, 0.7384016502311906, 0.8182300593525237, 0.8138841213813518, 0.8042251830398406, 0.7543609756292446, 0.8182467428926075, 0.17134227664234203, 0.22894152623035402, 0.8843974993507787, 0.2134444922807358, 0.37836295267915976, 0.37503128585304346, 0.17748729371430416, 0.17474144391461832, 0.17567790536915584, 0.12947667737386404, 0.18911730583292807, 0.19076947411923362, 0.18160356954567702, 0.1349242235120851, 0.13444959980944937, 0.198146919943469, 0.19446427722481474, 0.3287237824253224, 0.2150405059380066, 0.2855261479124329, 0.18648636393637585, 0.19276377431542568, 0.5259064833642881, 0.23174106838661246, 0.23828126860957, 0.2220465585996937, 0.19479528553394487, 9.999999999998899e-05, 0.2007212348500751, 0.05293975657252137, 0.005261456037583434, 9.999999999998899e-05, 0.19542424198113473, 0.0506976002820102, 9.999999999998899e-05, 0.0035935359927987687, 0.1420473284927073, 0.07847216110712618, 0.11456720188255365, 0.07432371141173222, 0.01415286209254174, 0.11381479610977463, 0.10117446830096266, 0.11372261529727179, 0.07075957305853187, 0.21351388022522866, 0.06072897069375527, 0.20250638642831875, 0.08780516482989897, 0.15481215531644088, 0.13320588613159512, 0.09356881363350134, 0.27066919586071503, 0.270846515613163, 0.11253674971087657, 0.11774871041032786, 0.10179956772669407, 0.11109829178536912, 0.22497838323729002, 0.21072346670933972, 0.18637293635814245, 0.08423700010730084, 0.08473161328322965, 0.5272562302842332, 0.5639999773477947, 0.5836573429014792, 0.6014113898923067, 0.5846049012272418, 0.55820935209749, 0.5763921925307902, 0.6465161514421065, 0.5765873627317928, 0.1142839818174507, 0.08405996016340855, 0.09228511630846514, 0.17907670664094966, 0.10370266388666116, 0.15220119584914626, 0.14477308423968027, 0.07150652888683129, 0.18922636906000656, 0.1669213032379403, 0.22585688626268985, 0.20334746799848757, 0.1481107812801885, 0.20178875410885555, 0.22930186223397442, 0.166831860381483, 0.22323226106400484, 0.19082934865485945, 0.49982687657686864, 0.3413937927346481, 0.38085418381861513, 0.37274867447670657, 0.5075309247803267, 0.356651007779645, 0.3967242383824737, 0.7426059577148104, 0.27038923092843625, 0.18981114381750042, 0.20548552599311742, 0.24233988268601137, 0.44178921191594234, 0.2958186579742037, 0.3734568743573087, 0.24598824186553758, 0.3830830745730799, 0.2017133495982304, 0.22813802583685094, 0.20667470603342986, 0.21296280384763433, 0.2533770944631233, 0.209234638448083, 0.24177941882958476, 0.25115040565275293, 0.2710939721274246, 0.1918838814177556, 0.17912434610884032, 0.2505366993452989, 0.19831534254878647, 0.1830781517893486, 0.1837675712796797, 0.2254052067467267, 0.19145801023023923, 0.19093762431319494, 0.1945216782347997, 0.18727488571530315, 0.9315812324898892, 0.1656367970809226, 0.9283859895100622, 0.16179503552800178, 0.14855331837545904, 0.14259510304109502, 0.1761416334215492, 0.17234771925804926, 0.6561153313725561, 0.21181109844112678, 0.20935533818820096, 0.3300049078840157, 0.08216014262238347, 0.1671043617228033, 0.7056345563441804, 0.21417358518730711, 0.9175378150296217, 0.1871181078793276, 0.19803379311964964, 0.1904152752324315, 0.21181716588232025, 0.2157605241884083, 0.22567303199595268, 0.20499815652898856, 0.21866492862392517, 0.21192030656830452, 0.08600310092628549, 0.09950825079970183, 0.0720258358591116, 0.11482945607256823, 0.1003025294972989, 0.11037132114110337, 0.0808691103625453, 0.0936767315356436, 0.10197687623100571]}, "mutation_prompt": null}
{"id": "ed531a72-6289-4730-9475-40456d15e33e", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40  # Increased population for diversity\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9  # Added inertia weight for velocity\n        self.F = 0.7\n        self.CR = 0.8\n        self.elitism_rate = 0.2\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                self.velocities[island_start:island_end] = (\n                    self.w * island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions)  # Global influence for enhanced convergence\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR,\n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]),\n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n            self.w -= 0.4 / (self.budget // (self.population_size * self.num_islands))  # Adaptive inertia weight reduction\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with self-adaptive inertia weight and multi-swarm strategy for improved convergence and diversity maintenance in black-box optimization.", "configspace": "", "generation": 91, "fitness": 0.2583429598282635, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.7196377245854066, 0.7074566216960381, 0.6821402629229847, 0.7215087571037613, 0.699245821248276, 0.7550617711378098, 0.7312745504531469, 0.7059115217454932, 0.7148771564044953, 0.507218883784047, 0.5256525593821368, 0.030184482374967403, 0.5414741484960381, 0.5185623129375928, 0.5279370461738523, 0.5288458948709736, 0.5018744385083116, 0.5047984941711856, 0.11998940568711292, 0.11425057806319727, 0.14440316631176953, 0.06912174634181101, 0.1325927889172437, 0.06439435533041393, 0.5037739530491236, 0.1466439371190731, 0.15157548253977515, 0.10258294364215814, 0.10599908124267332, 0.09645791742793863, 0.11011959994680254, 0.09445604173946298, 0.0920698209681794, 0.14047431962959667, 0.14886521373068695, 0.1481906054896377, 0.9831944532713216, 0.9844163251295379, 0.9582053225411038, 0.9740752631311014, 0.9805647521023901, 0.9716460116796548, 0.9865456764214345, 0.9811992540879799, 0.974828368228624, 0.43881945689269974, 0.546371155894161, 0.05560656324493707, 0.13881971740872634, 0.5163170886332366, 0.502161289997803, 0.08654730910002795, 0.4265054444775458, 0.08604564944807847, 0.20409329970751555, 0.6990815157984428, 0.2159832036779351, 0.2390797417952122, 0.1846653318224437, 0.18713327361396925, 0.21420366073672847, 0.668983644817692, 0.21585192883272708, 0.1530791370218385, 0.15864994314575287, 0.11612236569148915, 0.08995153650020615, 0.24365436427370357, 0.16755259508913845, 0.15993529752705304, 0.1301150124435706, 0.13645383266495537, 0.17354458664454653, 0.17646866417481266, 0.04576950454402562, 0.16341948521127014, 0.08839131397344169, 0.14370093461889843, 0.11729435380879127, 0.194766554439878, 0.17154415025302683, 9.999999999998899e-05, 9.999999999998899e-05, 0.07008365412944528, 9.999999999998899e-05, 0.002255003843879111, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002350117212965186, 0.04256510225042187, 0.04690185578046546, 0.07266814878597683, 0.016119096297174673, 0.005992230842446045, 0.044364143280740564, 0.13156251786259288, 0.04988897233037082, 0.04472090839733678, 0.04605398940006489, 0.03851124043441245, 0.02678218725116499, 0.07640329932428136, 0.05765186545246015, 0.14728968009677124, 0.06982156854243826, 0.07520194382055356, 0.08142700703717742, 0.14567001145256797, 0.039749112942022435, 0.08873246210141172, 0.14122674561170812, 0.0896155852372138, 0.0363658551816628, 9.999999999998899e-05, 0.045418902245019876, 0.15161566928217196, 0.46264510018493, 0.48011394651743977, 0.49071779625232226, 0.4438642940423646, 0.4944185470382262, 0.5064878428710773, 0.5013673079948058, 0.4383482984088132, 0.45654781505514097, 0.08595310657130162, 0.07099533535668912, 0.07123869553489826, 0.1307450184748592, 0.10554092857638953, 0.09970607209262305, 0.08996553012761266, 0.12248887358090377, 0.1059171687174072, 0.23560643453944818, 0.16912461291770742, 0.2906584288502939, 0.29721196494454516, 0.14093717203717115, 0.2006477670210508, 0.2022234722490529, 0.2783151644453483, 0.183251769786004, 0.25507807015996165, 0.34455588583733265, 0.34635652760225955, 0.39335430646408176, 0.24422591835065488, 0.34779558455197224, 0.3191176755852583, 0.4746093581354547, 0.4601675262969025, 0.23034725523855326, 0.19983639627144711, 0.21783611100971045, 0.21351536907904556, 0.23289799412081058, 0.14010959382831156, 0.30593308827370347, 0.189248692841552, 0.24502723813462324, 0.2072088416066865, 0.18852646076813973, 0.17645005466007802, 0.22966891132214928, 0.27820178056196965, 0.19521836229777, 0.20206317671037455, 0.2514547573152457, 0.20446851529093024, 0.1841251129584638, 0.22590816840665284, 0.21186337841143055, 0.20922531093963204, 0.20743114638906046, 0.20245805635121583, 0.2078566188058747, 0.18720566989851306, 0.22835207871137253, 0.12861839952711018, 0.17838398962034174, 0.16062601049898184, 0.15007532857388173, 0.12833016633733663, 0.7526977580239634, 0.16664707193983963, 0.18798541649852318, 0.1826696348409148, 0.1265841189082395, 0.18893426941140334, 0.5883013834965994, 0.41914643598067036, 0.19132122195012446, 0.49896214349345336, 0.1554665253906784, 0.39857324423180174, 0.49548025467125556, 0.20264808161310188, 0.17826770637304723, 0.17758102141273047, 0.1933277018591265, 0.1910413296797725, 0.23611087382245233, 0.20219839518302496, 0.1969447806818322, 0.18793112132550627, 0.08583751925638938, 0.09131449232228583, 0.08315792401282562, 0.09048089187159003, 0.08756534176435182, 0.09031148135236433, 0.07509803898879885, 0.0885144301772447, 0.08351674431820588]}, "mutation_prompt": null}
{"id": "af3176ef-eeeb-4f70-8ea3-15e370f0323a", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "7d305d71-ccd5-47f0-a9b2-09f4f9caddc6", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "2218b433-816a-4176-8167-6e2d73541eff", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.2  # Adaptive learning rate\n        self.c2 = 1.7  # Adaptive learning rate\n        self.F = 0.6  # Slightly tuned mutation factor\n        self.CR = 0.9  # Increased crossover rate\n        self.elitism_rate = 0.2  # Retaining rate for elite solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.6 + np.random.rand(self.island_size, self.dim) * 0.3  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (self.velocities[island_start:island_end] +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - self.positions[island_start:island_end]) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - self.positions[island_start:island_end]))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                # Intermittent stochastic velocity reset\n                if np.random.rand() < 0.05:\n                    self.velocities[island_start:island_end] = np.random.uniform(-0.5, 0.5, (self.island_size, self.dim))\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR,\n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]),\n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with improved adaptive learning rates and intermittent stochastic velocity resets for enhanced exploration.", "configspace": "", "generation": 94, "fitness": 0.25065581142379245, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.5421760306288568, 0.629657204023386, 0.6181948911880225, 0.5610689513800985, 0.5973120676051784, 0.6445310780119047, 0.5270021911845653, 0.5814796799839453, 0.6115544363044076, 0.09894173661547301, 0.04550445492302313, 0.1517669751930194, 0.04149565108692277, 0.06507409585044555, 0.04478914376536558, 0.11394980087135442, 0.05242449463887333, 0.2056871497268855, 0.15621035555292806, 0.13508466202016567, 0.0697113895897774, 0.13421889363141926, 0.10903949441625005, 0.13067260918450208, 0.14566148244576238, 0.07422116646436994, 0.13533076663817012, 0.13013830463836296, 0.1199464123369115, 0.09267700821763958, 0.11165403881555591, 0.14926411422184682, 0.09873154255786798, 0.10426934757702366, 0.10309785893605827, 0.10474069373183514, 0.9811653425320707, 0.9885658614255134, 0.9739624170451552, 0.9876762808702267, 0.9864173614753178, 0.9666983154951196, 0.9809299879221157, 0.98364110277466, 0.9841980955240333, 0.34353914085420645, 0.35436369938140033, 0.3761567314043207, 0.32859964741539593, 0.33558737021884233, 0.4049490289376828, 0.3306809720190873, 0.3167634489294848, 0.36862591018324076, 0.21912551369613886, 0.604834767177555, 0.7502310243886415, 0.21422170524071094, 0.41728860798964706, 0.2193264660726768, 0.3331800629816164, 0.3137450590783736, 0.7547204964406611, 0.15498287324796134, 0.16656347574985342, 0.1714503556875907, 0.1253580090847798, 0.1675327050758305, 0.12615050230807523, 0.1567511909333018, 0.1780669702450175, 0.18250513960256276, 0.17318218272078734, 0.20944680228312995, 0.24013891633539464, 0.2033058774266443, 0.1803422277214628, 0.33199430057441603, 0.23494458772767868, 0.10216995400543183, 0.18709625793516038, 9.999999999998899e-05, 9.999999999998899e-05, 0.014127214515652686, 0.04981919954189251, 9.999999999998899e-05, 9.999999999998899e-05, 0.054201271680408336, 9.999999999998899e-05, 0.0016531845473517492, 0.15028254707962896, 0.10295427680332359, 0.0563534967858319, 0.03830086817015488, 0.004776513636050583, 0.05093686112341145, 0.09343935505375356, 0.06491122701947039, 0.04734838189702517, 0.017128630660435906, 0.03401442063056004, 0.11091753398090554, 0.0222310414368867, 0.06861697277503664, 0.11467783367709783, 0.02355710427925639, 0.046777694070053055, 0.06883241040141552, 0.08618603703411631, 0.13050454794625144, 0.12276077158788845, 0.09377983221181385, 0.11697630121072056, 0.1322395773432783, 0.12049147235001623, 0.1622162557085508, 0.07802875361577788, 0.4311352804221237, 0.4821050469809761, 0.45099617977249584, 0.4632984214521465, 0.4757473030218702, 0.4653948669291583, 0.444874015320177, 0.48305745402194145, 0.5003934733028241, 0.1357765832692941, 0.10959833537787622, 0.11093273594025, 0.1180050461233384, 0.10115710051654914, 0.12590222797233275, 0.11520265709974609, 0.11980499793154809, 0.12127251815056783, 0.17175242907900878, 0.23416779476123384, 0.2933472235545814, 0.1584066228349308, 0.2919352350109574, 0.30370171643401267, 0.290364305762176, 0.21806536227120887, 0.1753001868676709, 0.3268029907382064, 0.3462655075220419, 0.3590581361674212, 0.3066948450413297, 0.3287370982133214, 0.3400441962198648, 0.33123127962454024, 0.36969379832466376, 0.37419047155506147, 0.183952749930963, 0.17653413105116778, 0.28217471686849827, 0.17600468095940447, 0.2786819594642176, 0.26296431114960617, 0.2632823182171973, 0.23990647130397358, 0.2775003912758922, 0.21947862288909992, 0.18789588338723584, 0.21250141073938789, 0.23493851133259158, 0.20017467877294992, 0.21416612382658817, 0.23161184490649878, 0.1898611460383749, 0.1961289319763222, 0.20563577953502854, 0.20357621244579893, 0.18379131449709607, 0.18623923746108173, 0.38364671248795434, 0.19790471118832642, 0.21158337583130382, 0.1957704101141733, 0.23568312228438681, 0.7234431789235385, 0.1705421262400192, 0.18650240536866847, 0.8171742096748648, 0.1977519610421803, 0.16154028794534603, 0.720675523006131, 0.15302567005132806, 0.1703170843419044, 0.39293998061027524, 0.16793784926656574, 0.20912051969687184, 0.16676172540368117, 0.16524044028582974, 0.15110184383310954, 0.16669290319647845, 0.605143448843767, 0.2124871629712135, 0.1811258029381524, 0.1845772530598766, 0.18555514966883213, 0.18917816112908126, 0.18498071324375764, 0.18356605939026915, 0.18109254726463964, 0.18275138584020756, 0.1834882545307026, 0.08631995281287397, 0.07798225819540472, 0.11429996572167311, 0.08715997546725374, 0.08985116433457985, 0.08490085439376238, 0.08779596049256211, 0.10001038493304404, 0.08461939102699512]}, "mutation_prompt": null}
{"id": "aef7ce4e-2457-4b98-927f-86bcbca6d36f", "solution": "import numpy as np\n\nclass AdaptiveQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 2.0  # Increased cognitive component for diverse search\n        self.c2 = 2.0  # Increased social component\n        self.F = 0.6  # Reduced mutation factor for stability\n        self.CR = 0.9  # Increased crossover rate for more exploration\n        self.elitism_rate = 0.1  # Decreased elitism to promote diversity\n        self.q_factor = 0.5  # Quantum-inspired factor for position update\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                adaptive_learning_rate = 0.3 + np.random.rand(self.island_size, self.dim) * 0.7\n                self.velocities[island_start:island_end] = (\n                    adaptive_learning_rate * (self.velocities[island_start:island_end] +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] = island_positions + self.q_factor * np.sin(self.velocities[island_start:island_end])\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "AdaptiveQuantumPSO", "description": "AdaptiveQuantumPSO integrates quantum-inspired dynamics and adaptive learning rates for enhanced convergence in black-box optimization.", "configspace": "", "generation": 95, "fitness": 0.11393465987168026, "feedback": "The algorithm AdaptiveQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.09.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.5359962314513012, 0.14776201088218244, 0.476540376611271, 0.1587705578930967, 0.1901976788240386, 0.19326812218548584, 0.18432042403832616, 0.169172828614359, 0.32029042654394324, 0.08746709057456425, 0.06027554676886682, 0.09270609699983179, 0.3553551915432521, 9.999999999998899e-05, 0.2830439249104435, 0.00563847451603583, 0.060360412266836305, 0.05368733254452451, 0.22963419317689815, 0.05222334569700726, 0.05387602055466523, 0.10171113769450602, 0.0797126717278468, 0.08528558981214684, 0.09972323213255152, 0.10360348996575741, 0.03583095446923146, 0.09007682373913561, 0.060133351619958586, 0.06891018626380041, 0.09180375514871053, 0.038535179636129624, 0.0793025068384795, 0.06640816263014149, 0.0667735537775146, 0.048748950443752936, 0.06727625550691607, 0.04546550879544553, 0.07598439094873644, 0.08380367001356714, 0.08620124304150956, 0.057967265057830675, 0.08973173049019001, 0.07534865325870665, 0.06190976336666432, 0.11172580703143287, 0.12279254689787089, 0.0006909897060569659, 0.12402598740472204, 0.026289608259604802, 0.11147164867283532, 0.005899318162951195, 0.0310984869442702, 0.13052387373378405, 0.18612373719453512, 0.08994777211688942, 0.15841907022105228, 0.1612780136011348, 0.04553381112660304, 0.21730387130955187, 0.09646589067279543, 0.13287985409215541, 0.11019172066025751, 0.07812763210040596, 0.0518214438523652, 0.0005079559524652222, 9.999999999998899e-05, 0.017711749385935227, 0.07421066722308811, 0.015257737423952311, 0.1674032222413827, 9.999999999998899e-05, 0.10296096222898721, 0.013779669235434056, 9.999999999998899e-05, 0.15747540715633934, 0.03422130441841731, 0.10943465171535349, 0.107027630149644, 0.034667005013895635, 0.08803229442392801, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09349730451231042, 0.09129125278229278, 0.1630786432502762, 0.0429477511876839, 0.0519873006692958, 0.11570257427996022, 0.07640252139766834, 0.05489752972473394, 0.060351728195912946, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029421384492900327, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017413862119105894, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005006010371277236, 9.999999999998899e-05, 0.039316472059462315, 0.20677204713106567, 0.28939903326702165, 0.1680489492152396, 0.1900309172445156, 0.15474550376635943, 0.147539619718135, 0.3883049296514933, 0.2582069882480914, 0.29974438759593647, 0.04785965065658859, 0.03366316388572299, 0.036326820194312326, 0.04839707747732469, 0.057320441945966194, 0.03289298400448537, 0.023738115830389317, 0.0337582950560773, 0.07551429604450166, 0.214924082400611, 0.16984105808484673, 0.1524328970807577, 0.14990806690630598, 0.14704289209050225, 0.1742728054025331, 0.20889223232509224, 0.15686191582223963, 0.1373886677334467, 0.16146645877119226, 0.15553088378261615, 0.19367980832738396, 0.16205563441288362, 0.1709368094502448, 0.17160988374482844, 0.15993857516687726, 0.16995356184251287, 0.20321112029129473, 0.13115524949962964, 0.09778764154231578, 0.09445959631262413, 0.1285521298240394, 0.10012755798115669, 0.1540926155789175, 0.11516480809593233, 0.10724978888315306, 0.11942187923952874, 0.19811697534864292, 0.17915924930847127, 0.19300994533753368, 0.18286240505854556, 0.1460792577099237, 0.1647096142946557, 0.23621432169445467, 0.17513287570542613, 0.17184904700952086, 0.17189232670236365, 0.1546860359611545, 0.1726070970620347, 0.16976150992173566, 0.18128916019920394, 0.17563328894812114, 0.17113984392659498, 0.11056562323184205, 0.17641601257242967, 0.11289984204178583, 0.1309731135346216, 0.12075449840066355, 0.29082791913624173, 0.15258719891333472, 0.11755350345230342, 0.2818269768420816, 0.33355219861521956, 0.1671890587969116, 0.30901867912254377, 0.20818289267905876, 0.1347621139742956, 0.15247920064594722, 0.18092561457096767, 0.13044197919374456, 0.2267164714104145, 0.16012996222492892, 0.12340036686808509, 0.1969862418700229, 0.20948787081348996, 0.18541279442446978, 0.195108061884543, 0.17894130973564082, 0.19563760374449446, 0.20054978976233884, 0.19147698726438134, 0.18724347099019945, 0.06889411540548751, 0.0822371479364683, 0.049517916097490344, 0.051913546423186574, 0.06109008932634519, 0.09133149829543585, 0.07661203747141243, 0.046853238180710965, 0.07135404840879256]}, "mutation_prompt": null}
{"id": "2c4cb144-a752-4c1a-b49a-a9c9ca97377f", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "1dc8f758-e7ac-4ede-9bed-94b60fd89ff9", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
{"id": "8fb4c9cb-7917-4b2a-9856-3f36272a718c", "solution": "import numpy as np\n\nclass AdaptiveMultiIslandPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 4\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F = 0.8  # Slightly increased mutation factor\n        self.CR = 0.9  # Increased crossover rate\n        self.elitism_rate = 0.3  # More elitism for preserving top solutions\n        self.constriction_factor = 0.7  # Introduced constriction factor\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                self.velocities[island_start:island_end] = (\n                    self.constriction_factor * (self.velocities[island_start:island_end] +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.global_best - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "AdaptiveMultiIslandPSO", "description": "Adaptive Multi-Island PSO with Self-Regulating Dynamics for Enhanced Convergence and Diversity in Black-Box Optimization.", "configspace": "", "generation": 98, "fitness": 0.2776844220256681, "feedback": "The algorithm AdaptiveMultiIslandPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8268908871469263, 0.7573166244893246, 0.7568666033546706, 0.8064136771582691, 0.7668055047927342, 0.8213180291339608, 0.8414378890637388, 0.7835045705218818, 0.7715133579178259, 0.5270439150226058, 0.5426866432736576, 0.06585591967404092, 0.5414065978143857, 0.6013755925062639, 0.340314963425117, 0.047529979305931946, 0.5390652181070745, 0.053104317155388325, 0.1398310173886359, 0.15603558970285702, 0.13239475326101113, 0.13687314871442946, 0.06834457206024125, 0.14701393756242165, 0.12158119077812424, 0.1192258761045738, 0.12532107154800687, 0.12778322435330047, 0.06559593482277926, 0.09112018586960768, 0.11035585668434655, 0.08320500675908571, 0.10692516372474259, 0.13958221453010555, 0.0995445050857694, 0.12038367211669576, 0.9790357756362313, 0.9840233619755706, 0.9875012824747017, 0.9883604650773584, 0.981028953189225, 0.9842190243389928, 0.9790820760105794, 0.9879214420165545, 0.9860036239596123, 0.6518143275289336, 0.5415254435368804, 0.05998022114833623, 0.6100043681190445, 0.5998845364415439, 0.6095084121040433, 0.601537767605677, 0.0517483548593185, 0.6095763386369158, 0.17016328895245314, 0.858120263007014, 0.3737912029802135, 0.2756093172319689, 0.265734326860393, 0.18851514787443335, 0.2309380524749115, 0.22995766663760564, 0.17203305091355015, 0.2278289453881347, 0.1272004077215645, 0.21697630132607315, 0.12883306579670684, 0.12577357851288962, 0.09744087094509502, 0.21232181981312093, 0.22280159308866965, 0.2597386496178782, 0.21588139971910025, 0.128043564299808, 0.22874655324375415, 0.2545388524481499, 0.2518091794797256, 0.22068135171512238, 0.12001316117639127, 0.23692990486696808, 0.09771028433795914, 0.011211805488789084, 0.07813856052466184, 0.0625427616749139, 0.07081926192547383, 0.024904879862162277, 9.999999999998899e-05, 0.01864093209151141, 9.999999999998899e-05, 9.999999999998899e-05, 0.07014083908944557, 0.10050262717038627, 0.07879383886872404, 0.05960646896718136, 0.03764572404982558, 0.014335354872899164, 0.03379016729442097, 0.03741979616987734, 0.04315564167990038, 0.20564274072150224, 0.047469791383297544, 0.056571275969006796, 0.12971708885333377, 0.06736829949120127, 0.06522078371827977, 0.1530202433004726, 0.10691757946951097, 0.09180463317370102, 0.20191874513477737, 0.010757953677200338, 0.1597512943083229, 0.17835770181629962, 0.03754752299600672, 0.0642595253324233, 0.045712993505315325, 0.29342157784047296, 0.07728460352764754, 0.5333694217336452, 0.5387305106540987, 0.5736581487887228, 0.5075896775496773, 0.5267006440559613, 0.47191178109209964, 0.5414330688142694, 0.5252206936310835, 0.5548266942370172, 0.1264115827746708, 0.07014237867308515, 0.13514859900722986, 0.08033547202070479, 0.1332235876394663, 0.15317658165532588, 0.12199217830285691, 0.11709545027081891, 0.09526093553876291, 0.21757972821914684, 0.186835720976136, 0.23213185721713847, 0.20359201022733864, 0.20673009536661302, 0.16090285917343883, 0.25486992639350525, 0.3116991954017765, 0.13059405678578462, 0.4238851960498674, 0.3807857447601696, 0.5344226368845946, 0.33544756696364364, 0.3148828024745379, 0.3813857814247871, 0.2854570877860406, 0.262184896570098, 0.2107468981542926, 0.2961541799379843, 0.22219608746693242, 0.3261981299309892, 0.2025187903222584, 0.2016486380016318, 0.2986442672670546, 0.39222035718869486, 0.21452091574643117, 0.26894001020227265, 0.21767228217910317, 0.20987545356467585, 0.2346609460042307, 0.19772670060005837, 0.25206687363770874, 0.2659132135602942, 0.19587762202737613, 0.2139339595705142, 0.23330478803320343, 0.20361941831107966, 0.1883121581813959, 0.20579340071220953, 0.21527457124517246, 0.1941286194210894, 0.21639139310457967, 0.18440855627586183, 0.21131699735327802, 0.19158632241281648, 0.208101436309706, 0.1681318519550845, 0.19551060211928195, 0.8326801375513513, 0.19830264571505885, 0.16826247352371904, 0.14168246398044482, 0.17114201633709303, 0.8718125298972266, 0.7583569897832072, 0.2135103398768431, 0.20819868296727118, 0.11160035900747156, 0.6888646954289254, 0.15466585641984043, 0.10287584424418361, 0.2086834327900372, 0.19672418418023174, 0.21468221948308852, 0.2016243609490196, 0.1901723564321104, 0.1875421977830093, 0.20844960711389093, 0.1935747449911268, 0.24622755765930737, 0.23368341453578345, 0.22188044052208122, 0.1029056300781458, 0.07957155326310128, 0.10597602759651015, 0.09643604128758576, 0.07741803477636966, 0.07933183377649078, 0.09064571024185775, 0.1067977010314709, 0.1013952644404329]}, "mutation_prompt": null}
{"id": "8d2f4563-b114-4955-8a3a-7e0bcc3ff502", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.island_size = 5\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_value = float('inf')\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.population_size, float('inf'))\n        self.func_evals = 0\n        self.c1 = 1.5  # Adjusted for better balance\n        self.c2 = 1.5  # Adjusted for better balance\n        self.F = 0.7  # Slightly increased mutation factor\n        self.CR = 0.8  # Adjusted crossover rate\n        self.elitism_rate = 0.2  # Increased elitism for retaining better solutions\n\n    def __call__(self, func):\n        while self.func_evals < self.budget:\n            for island_idx in range(self.num_islands):\n                island_start = island_idx * self.island_size\n                island_end = island_start + self.island_size\n                island_positions = self.positions[island_start:island_end]\n                island_velocities = self.velocities[island_start:island_end]\n                island_best_idx = np.argmin(self.personal_best_values[island_start:island_end])\n                island_best_position = island_positions[island_best_idx]\n                \n                neighborhood = np.random.choice(self.population_size, self.island_size, replace=False)\n                neighborhood_best_idx = np.argmin(self.personal_best_values[neighborhood])\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    fitness = func(self.positions[idx])\n                    self.func_evals += 1\n\n                    if fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = fitness\n                        self.personal_best_positions[idx] = self.positions[idx]\n\n                    if fitness < self.global_best_value:\n                        self.global_best_value = fitness\n                        self.global_best = self.positions[idx]\n\n                r1 = np.random.rand(self.island_size, self.dim)\n                r2 = np.random.rand(self.island_size, self.dim)\n                velocity_constriction = 0.5 + np.random.rand(self.island_size, self.dim) * 0.2  # Self-adaptive velocity control\n                self.velocities[island_start:island_end] = (\n                    velocity_constriction * (island_velocities +\n                    self.c1 * r1 * (self.personal_best_positions[island_start:island_end] - island_positions) +\n                    self.c2 * r2 * (self.personal_best_positions[neighborhood[neighborhood_best_idx]] - island_positions))\n                )\n                self.positions[island_start:island_end] += self.velocities[island_start:island_end]\n                self.positions[island_start:island_end] = np.clip(self.positions[island_start:island_end], -5.0, 5.0)\n\n                for i in range(self.island_size):\n                    idx = island_start + i\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, \n                                            self.positions[a] + self.F * (self.positions[b] - self.positions[c]), \n                                            self.positions[idx])\n                    trial_vector = np.clip(trial_vector, -5.0, 5.0)\n                    trial_fitness = func(trial_vector)\n                    self.func_evals += 1\n                    if trial_fitness < self.personal_best_values[idx]:\n                        self.personal_best_values[idx] = trial_fitness\n                        self.personal_best_positions[idx] = trial_vector\n\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.personal_best_values)[:elite_count]\n            self.positions[:elite_count] = self.personal_best_positions[elite_indices]\n\n        return self.global_best", "name": "EnhancedHybridPSO", "description": "EnhancedHybridPSO with adaptive neighborhood search and dynamic parameter tuning for robust exploration and exploitation in black-box optimization.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "25af877a-71ee-48a6-bae4-aad494e85dd6", "metadata": {"aucs": [0.8962428848036793, 0.891319876230272, 0.8945349997904566, 0.901476524328026, 0.8887461468097168, 0.8879992197372839, 0.8853739287092429, 0.8952962705955175, 0.9002545278561335, 0.7673854198289262, 0.7431898104556098, 0.555522456190638, 0.7271351548065729, 0.7662848908222673, 0.7880503000023595, 0.7736539980519572, 0.05564420028181616, 0.7835727174213332, 0.14215824090139195, 0.11317980547384354, 0.11325341218213802, 0.11198829741986205, 0.15262191897852284, 0.13212597484111888, 0.12178431479626617, 0.15192461164761284, 0.18408625230519382, 0.1294797128204671, 0.1264644118381244, 0.08886714900738846, 0.09955069960965479, 0.1223418197226458, 0.12960121222446652, 0.10965625262186185, 0.14042272929283395, 0.1169665191908501, 0.9846852779698323, 0.9747477182717902, 0.9695101723024504, 0.9786378411591102, 0.970529770951611, 0.9733632633365422, 0.9748093751886017, 0.975034391244572, 0.9756111159716824, 0.814657144476697, 0.7006158945601111, 0.7664731289110988, 0.764104232246114, 0.7627707020929219, 0.7655122803439611, 0.8044934231008364, 0.7961686402762227, 0.7763989622275839, 0.900091946613672, 0.2265458080496574, 0.7799056805202031, 0.28169945793914963, 0.19120603829940253, 0.9022476898401475, 0.60804257439457, 0.2329051137367243, 0.17916492872718337, 0.1825748689819121, 0.191422293019899, 0.21687442060230488, 0.12745767864789903, 0.21583175059702286, 0.20430045861579038, 0.18252588809002723, 0.17313863374625327, 0.2042298298124967, 0.23918686631089647, 0.22688801581458928, 0.22658614282961775, 0.5820932123900714, 0.13291167027770912, 0.24155019469998662, 0.21474766999567363, 0.22934715710757025, 0.2022781853154173, 0.16397498182319015, 0.04674558881352009, 9.999999999998899e-05, 0.0004390311801347746, 9.999999999998899e-05, 9.999999999998899e-05, 0.028548924274286236, 0.04586246523947046, 0.061395686524498116, 0.12481868684130326, 0.03304315092351884, 0.0864536595103047, 0.06230092129567932, 0.06047621666337255, 0.026348233777128582, 0.06237103308534986, 0.07281949339907401, 0.06889213117600135, 0.13526653401711897, 0.08753565631255611, 0.11308477944032258, 0.08198767849480593, 0.1818651156929454, 0.15685189698803348, 0.08315161893959555, 0.32286723604499323, 0.14116122717811652, 0.14225614891018012, 0.0882279060413248, 0.16391119876974658, 0.1814454230376188, 0.09411935373619873, 0.2400525309623197, 0.18801149886136714, 0.05500602791165454, 0.08880221084095752, 0.5328797008543998, 0.5731459706145062, 0.5709673040665894, 0.5760218947829251, 0.6378536920546733, 0.5278071386732692, 0.5829644696547386, 0.5667650712369807, 0.5910809298313082, 0.07154119521091873, 0.17496137439456239, 0.08077846383354592, 0.15279256901116223, 0.10337237916840625, 0.083706307792909, 0.12832541312258106, 0.15327963249503884, 0.1039625959633913, 0.5424439927112255, 0.2924117296555444, 0.22347021670083655, 0.22472810185427172, 0.40414692216721215, 0.3081252239532728, 0.2944685819190368, 0.22983267280976627, 0.20235240614668482, 0.2739122738621592, 0.4776329006380513, 0.29101928411224287, 0.730981237289338, 0.36178674303575475, 0.4770150812996712, 0.5536281023586062, 0.5741770654309389, 0.7686856398998547, 0.19237748659786624, 0.2580407807885232, 0.323676494738828, 0.23870540483878766, 0.35917162670298375, 0.27859408166840294, 0.23331000457291606, 0.36589672698557985, 0.2361105271089894, 0.2204420075290311, 0.18193216552499247, 0.2159347347583599, 0.2515887577147521, 0.21125082368387915, 0.21987178781040628, 0.25498374821551983, 0.2201983587571532, 0.20633398390008384, 0.2007211192246806, 0.18257881391435515, 0.1997878141231868, 0.25224576366915785, 0.18656090465452668, 0.225943883587147, 0.19066644316868497, 0.18520345787846226, 0.18727912142778846, 0.17244022276461857, 0.9223124126502391, 0.187342232509231, 0.9344084486875762, 0.19882291128873109, 0.16963041489312858, 0.16771426864624794, 0.841843482418389, 0.1694304372628449, 0.7462064689494506, 0.20850878015719532, 0.8783502722086142, 0.1678032748363807, 0.15481331396759357, 0.847096596339599, 0.0944065183299182, 0.21304891051300023, 0.16803259897911482, 0.1885256850314211, 0.2105397702824, 0.19800293295015858, 0.20487030878090073, 0.18582239982979232, 0.18783537500421066, 0.2023709508371221, 0.1869556546034733, 0.20808616404403402, 0.08254995439986701, 0.11724334161481786, 0.12428005762018579, 0.08725143338777219, 0.08911725173353702, 0.089590634477829, 0.08134896995451002, 0.0973024604936934, 0.0943806930467217]}, "mutation_prompt": null}
