{"id": "082f2816-2e89-45f2-9f1c-db05446a2411", "solution": "import numpy as np\n\nclass BatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness():\n            return self.loudness * self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n\n                self.loudness = update_loudness()\n\n        return best_solution", "name": "BatAlgorithmOptimizer", "description": "A novel metaheuristic algorithm based on the Bat Algorithm, where virtual bats fly towards the best solutions in the search space while adjusting their frequency and loudness to explore and exploit the search space efficiently.", "configspace": "", "generation": 0, "fitness": 0.030699839184818094, "feedback": "The algorithm BatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_id": null, "metadata": {"aucs": [0.07172115044992011, 0.06423415049946268, 0.0822881188591662, 0.019485674469137848, 0.05257887047805776, 0.025191216022295126, 0.051309371152801986, 0.051535794705865556, 0.06701824832800662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.0, 0.0, 0.0011187632349987098, 0.0, 0.018150078853237717, 0.0, 0.0, 0.0, 0.0, 0.0, 0.019501673109847295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.045084250649534585, 0.03357090568988674, 0.0427820504861669, 0.03899241521606378, 0.04678013722708951, 0.030484491850546358, 0.033180535359004004, 0.048891644393723954, 0.025752273873738685, 0.0, 0.0, 0.0, 0.0, 0.00021551809509001707, 0.0, 0.0, 0.01119445381188322, 0.0, 0.1001868586914183, 0.03765971698870685, 0.006388112346703556, 0.004462664352364976, 0.0, 0.0, 0.026181922062049168, 0.0, 0.009809447265860194, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07830854760949701, 0.10693789276682164, 0.14829537673711235, 0.09416865854239498, 0.08041876921715974, 0.09571399605654973, 0.12396929853484018, 0.09707379230406277, 0.12096781838999704, 0.0, 0.0, 0.0, 0.006002370323321182, 0.0, 0.01750168379108641, 0.0, 0.0, 0.02666833626569931, 0.07028246122685633, 0.06726366127807482, 0.05459392587769929, 0.09846289938816155, 0.06572254448697346, 0.05633684591928945, 0.05488481188470995, 0.04846289571906348, 0.07717165476235766, 0.09597227240618145, 0.09616018134012416, 0.10350813781504986, 0.10838250165484586, 0.08290739212077247, 0.08317157286626975, 0.11411347464502597, 0.10004631021926014, 0.07775611701398755, 0.03322226033550901, 0.03075358899712477, 0.034551307077603455, 0.04455513106718245, 0.015390172400233326, 0.03704448605922828, 0.05639263182623655, 0.038433917477429747, 0.011774946489725324, 0.09154377975027184, 0.06023522738925291, 0.11080991306893939, 0.10280083939129603, 0.06737852077118656, 0.0816703972194458, 0.12237199858757541, 0.06484693399681651, 0.12610897469223914, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04375744941512982, 0.05604888032687072, 0.05616689752555071, 0.06709542404813529, 0.1207035396655618, 0.06165711078819791, 0.06079227088297268, 0.05652137775177002, 0.053579659675793145, 0.038145025866380466, 0.03957798628310849, 0.016303151453704978, 0.01850796326103321, 0.02150250198996473, 0.0454156150021221, 0.01886693703538278, 0.015736471619919423, 0.04133833534605058, 0.10087028022501054, 0.12008703439342805, 0.1475449842687161, 0.10726544462840115, 0.11393539758803017, 0.12456358843521431, 0.10047330010600874, 0.10853850474266824, 0.14680476350940785, 0.0, 0.012105424203345372, 0.03129662407793532, 0.0, 0.0057755656362813435, 0.008161729106915816, 0.003688085859674395, 0.0, 0.006903948184889486]}, "mutation_prompt": null}
{"id": "da785623-cd54-456c-b5f4-8ffb548e0126", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness():\n            return self.loudness * self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            self.population_size = int(self.population_size * (1 - _ / self.budget)) + 1  # Dynamic population size adaptation\n\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n\n                self.loudness = update_loudness()\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhancing the exploration capability by introducing a dynamic population size adapting to the optimization progress.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "082f2816-2e89-45f2-9f1c-db05446a2411", "metadata": {}, "mutation_prompt": null}
{"id": "8fa30e20-4359-4d0f-899c-2644886c41fa", "solution": "import numpy as np\n\nclass ImprovedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n        return best_solution", "name": "ImprovedBatAlgorithmOptimizer", "description": "Improve the Bat Algorithm by incorporating dynamic loudness adaptation based on fitness improvement.", "configspace": "", "generation": 2, "fitness": 0.03079676869890099, "feedback": "The algorithm ImprovedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_id": "082f2816-2e89-45f2-9f1c-db05446a2411", "metadata": {"aucs": [0.07181397830146763, 0.06432772651221763, 0.08237988959495246, 0.019583725566517884, 0.05267361210777377, 0.025288696900545027, 0.05140423906395497, 0.05163064099738546, 0.06711154613058024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012186513362246743, 9.999999999998899e-05, 0.018248263482334326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.03775594762470191, 0.006487473152022916, 0.004562218041036625, 9.999999999998899e-05, 9.999999999998899e-05, 0.026279303607937843, 9.999999999998899e-05, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07840071328182474, 0.1070271971752389, 0.14838054695461433, 0.09425923977458062, 0.08051072568095674, 0.09580441870675127, 0.1240568991094797, 0.09716408355800721, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006101769545772684, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.07037543064596374, 0.06735693451091307, 0.05468846648487902, 0.09855305120349966, 0.06581597144687368, 0.05643121168494414, 0.05497932156064522, 0.04855804829477728, 0.07726393575557644, 0.09606267484187503, 0.0962505644704219, 0.10359778603806002, 0.10847166301008526, 0.08299910073640826, 0.08326325451723493, 0.11420206329748472, 0.1001363042967901, 0.07784834048331069, 0.033318937593247444, 0.030850512655025697, 0.03464785118471059, 0.044650675553987496, 0.0154886331024634, 0.037140780888393565, 0.05648699256316181, 0.038530072755655564, 0.011873768353786729, 0.0916346253723066, 0.06032920214938475, 0.11089882950468877, 0.10289055837941885, 0.06747178230817008, 0.08176222879441697, 0.12245976138762271, 0.06494044806858634, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04385307240429104, 0.056143274529988574, 0.05626128006000852, 0.06718871428537254, 0.1207914665021157, 0.061750941843425444, 0.06088618922663591, 0.056615725614002965, 0.053674301379695866, 0.03824121102611444, 0.03967402848431323, 0.016401521055428026, 0.018606112313171663, 0.021600351495484005, 0.045511073114331335, 0.018965050090669178, 0.0158348977852244, 0.04143420019681854, 0.10096019244302157, 0.12017502569002791, 0.14763022729669195, 0.10735471808377628, 0.11402400224796383, 0.12465113207635137, 0.10056325222828677, 0.10862764757569365, 0.14689007985489466, 9.999999999998899e-05, 0.012204213037243616, 0.031393493129599714, 9.999999999998899e-05, 0.0058749879062220955, 0.00826091239954263, 0.00378771705097114, 9.999999999998899e-05, 0.007003257745281877]}, "mutation_prompt": null}
{"id": "8161f991-bf3b-4e89-998e-472d11d68bbd", "solution": "import numpy as np\n\nclass ImprovedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n        return best_solution", "name": "ImprovedBatAlgorithmOptimizer", "description": "Improve the Bat Algorithm by incorporating differential evolution strategy to enhance population diversity and exploration capabilities.", "configspace": "", "generation": 3, "fitness": 0.2437699392331943, "feedback": "The algorithm ImprovedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "8fa30e20-4359-4d0f-899c-2644886c41fa", "metadata": {"aucs": [0.2807975602518662, 0.6999862893696718, 0.5343681472074319, 0.8265059260628348, 0.8543679974790828, 0.6195099782712881, 0.8312251868508257, 0.467457476602264, 0.3798132525200234, 0.681587180619663, 0.6797681489378298, 9.999999999998899e-05, 0.2259623252272437, 0.5437276771550352, 0.265147594050717, 0.29229218662850576, 9.999999999998899e-05, 0.06047573138186402, 0.16389704039133846, 0.15390393269895153, 0.14930140684813253, 0.17180729518438187, 0.4675073021250493, 0.1654116661352909, 0.16500502376146486, 0.5743287322779695, 0.439847304242325, 0.14590989079976024, 0.12147116722376505, 0.09591840780463223, 0.11015796966133695, 0.09664678387607184, 0.12093735198760569, 0.13947954068662927, 0.15574233869441323, 0.014259076363923873, 0.9530301790557457, 0.9560376288611212, 0.9388028375176999, 0.9502967135904021, 0.9590203919617898, 0.9646122260125545, 0.9647475249107296, 0.18802798253402297, 0.374576629089277, 0.16492271519277402, 0.20713853394221737, 0.10361987438786924, 0.08284603842779836, 0.22362967838571324, 0.2305320136529705, 0.2964091632421929, 0.06392096565030336, 0.11536820755937827, 0.35670620509102746, 0.1282024693642554, 0.3224045003957323, 0.691728062841187, 0.11488542335800433, 0.3459022233917832, 0.12655537197991817, 0.3618436189407567, 0.3651624103247184, 0.18076786786777832, 0.23388365789328336, 0.2538835280842131, 0.23549144450012305, 0.19168715906851053, 0.39501167010462945, 0.3722408582204658, 0.19414997313032267, 0.2574049653731263, 0.12172735652343958, 0.12253494774106422, 0.1914414383682037, 0.12411449377308714, 0.1604673090886728, 0.1288614501391414, 0.1231541080672981, 0.1689689956352367, 0.12669293053082398, 0.0685905886665722, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012971202848046648, 9.999999999998899e-05, 0.023501367721492916, 0.18129588375008443, 0.14289379455889684, 0.08076005746840853, 0.047031654996862016, 0.059602126328286986, 0.09926070021738564, 0.1731698532590633, 0.13805887078682533, 0.11766514641136361, 0.10646759179956367, 0.13570296000124904, 0.06184715577804378, 0.03956544695358699, 0.09677631567384137, 0.0628964578692508, 0.10369716830807119, 0.059589434925881535, 0.08004229455456646, 0.09797357099731652, 0.06652755001937016, 0.0447686664067547, 9.999999999998899e-05, 0.23844480997754536, 0.2526410578750027, 0.1147617735689217, 0.08138075638177866, 0.012777459479683562, 0.4363638219378829, 0.582480131816371, 0.46689727275866777, 0.4567105196637531, 0.4600801492994079, 0.26797728231472406, 0.43445325227027987, 0.5207655085982175, 0.2679257146459767, 0.10998079636569369, 0.14950917424196009, 0.09976813032517262, 0.11684587699543592, 0.08080033963673083, 0.12349870870518931, 0.12830097814883412, 0.09960114854568092, 0.0876375350256774, 0.12075109309051402, 0.1474352105790382, 0.11464757582709062, 0.162706553230761, 0.1406237011427922, 0.12654693459236555, 0.13577309031956097, 0.12077920599026615, 0.18449431907088187, 0.3121259228795138, 0.37431890610402363, 0.18190439916818368, 0.3510702688484497, 0.5057532153864702, 0.21319499975561873, 0.39599359009262114, 0.4716310365516402, 0.44026621936434873, 0.35132596774471836, 0.20347758984286113, 0.3011782558997739, 0.31035885430035837, 0.23559003038476345, 0.22658174578142598, 0.34009862027092674, 0.2579284264314421, 0.22155899845834093, 0.19634032639763332, 0.1876298030433735, 0.20218272881918986, 0.19539341246787734, 0.1695803543391059, 0.20833024825921476, 0.2173209093768793, 0.1977440132622561, 0.18042907226806526, 0.25733308003585786, 0.20273895897964544, 0.21341433809080312, 0.2119869353493925, 0.20563969815211147, 0.1863567670734908, 0.20176264275691136, 0.21456431927396347, 0.1985297002840838, 0.18393343391234662, 0.16226570536869678, 0.4713619761008845, 0.6112656426027745, 0.16033160108323685, 0.1674732029170053, 0.46685800569427327, 0.16180463508141985, 0.16833136594911335, 0.11954371668208696, 0.12086620049870367, 0.6503447934432727, 0.19245022350237861, 0.5291347590352189, 0.6611498599972306, 0.1889120301585413, 0.1494843687269517, 0.11368994325799109, 0.17672236574000322, 0.18153454411544911, 0.18574048320648084, 0.18514588233565177, 0.17290921136853754, 0.16538690588752747, 0.18985805578194037, 0.19197504521768682, 0.15762150562987698, 0.06967161325353388, 0.056275683455807135, 0.08015284410968615, 0.07528802370826448, 0.06668281212339355, 0.08863159644323548, 0.07087625514251505, 0.08252846772287936, 0.0752894663100826]}, "mutation_prompt": null}
{"id": "9005ba25-74f5-4990-b450-3e01baeba528", "solution": "import numpy as np\n\nclass DynamicCrossoverBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "DynamicCrossoverBatAlgorithmOptimizer", "description": "Improve the Bat Algorithm by introducing a dynamic strategy to adjust crossover rate during the optimization process based on the population diversity.", "configspace": "", "generation": 4, "fitness": 0.2568385435386021, "feedback": "The algorithm DynamicCrossoverBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "8161f991-bf3b-4e89-998e-472d11d68bbd", "metadata": {"aucs": [0.8449788083965046, 0.8001428491232031, 0.44040059487647965, 0.8160831821031107, 0.8201375240856648, 0.8342852278009334, 0.7755074633859598, 0.8010882124036514, 0.8282430321246442, 0.10995107004401905, 0.6832311016979891, 9.999999999998899e-05, 0.7056224188514345, 0.698141006437488, 0.7413309252150464, 0.7172342394048246, 0.708710275541486, 9.999999999998899e-05, 0.11921948105929192, 0.1485786840361134, 0.12459165660570992, 0.16887646256900046, 0.11985343327058706, 0.5385769280523938, 0.41031726234911403, 0.14684428970807728, 0.23506842486031965, 0.11482857153630754, 0.07637382394460546, 0.1697939173336852, 0.15264719069677934, 0.06537898598311243, 0.1312945795740167, 0.11179965194430774, 0.26164871015148283, 0.047148753879025396, 0.9516451647834872, 0.9533992102413941, 0.9622776254231129, 0.14541565683192692, 0.9528905100817575, 0.9522357525471334, 0.964763853967857, 0.9489541184471451, 0.9264699767108207, 0.20741058188524597, 0.11670133606567723, 0.19307816347521656, 0.0944342898802012, 0.12710172825093158, 0.08212893773785201, 0.16146937425414676, 0.08562577445379826, 0.1920862725084178, 0.2182632892468358, 0.16273358014553363, 0.16239934677667733, 0.6242063178990408, 0.20009771646583852, 0.7631829402987443, 0.6523321468778891, 0.6135451595098124, 0.33226218151402176, 0.1972338461391171, 0.13072277275762423, 0.1574142232089636, 0.12076837354653269, 0.12388984449567919, 0.22774545438989702, 0.13874697733542674, 0.14155782542505313, 0.18082363114292854, 0.11326267898883413, 0.15465971593448702, 0.1412662173483148, 0.17842635454167177, 0.12399838880515712, 0.12899428925300438, 0.132614908413897, 0.13194716624441027, 0.1377819710181104, 0.022391291499892607, 0.01821527690395175, 0.025877989545262103, 0.06181193192354606, 0.023217427818913672, 9.999999999998899e-05, 0.06897728862034014, 0.049817899274696154, 0.0059744311412052165, 0.0837972411721517, 0.09981409404579566, 0.13382518699127155, 0.09720398921819817, 0.013035234602440271, 0.06924541498231174, 0.09207880691206483, 0.13539000060851725, 0.08684966982953679, 0.07267421260788143, 0.07065793570979129, 0.03238997319133419, 0.0726943024226584, 0.05618491814430959, 0.028660922977111092, 0.05634511246036, 0.1514960331728311, 0.04489648115820166, 0.189316614763112, 0.13110047361093624, 0.13017081413461729, 0.20924555414857005, 0.14636565592807693, 0.20396334462433496, 0.07001935777466439, 0.07638645414479361, 0.00438090548893344, 0.5892594691508546, 0.4977720523609277, 0.5149394782723404, 0.5678394063755778, 0.4788155929280602, 0.4372986607113212, 0.5651557372841324, 0.4689723431077233, 0.43192297969566196, 0.07804841820068487, 0.09523172163089288, 0.09128634015103176, 0.10019550517679598, 0.10118290632166549, 0.0963038819620613, 0.08586807836131172, 0.09335626505798722, 0.09484136765692908, 0.15199410047938766, 0.1258134596857513, 0.14247293082798518, 0.12248396481249002, 0.11758698373354581, 0.14103342940269725, 0.11018903109313882, 0.15957727203842165, 0.11608037481545341, 0.3967636811613544, 0.3451559477082826, 0.33569968837777575, 0.2788124802753571, 0.39069362105395156, 0.309452975621367, 0.4430684148117642, 0.3222499185068045, 0.41503606431969176, 0.3064599472718098, 0.21358777542925345, 0.20155517858363925, 0.30477175572047155, 0.2870214609334518, 0.18332879280489223, 0.25781485013426364, 0.2700825555126186, 0.25861584687221395, 0.19410406754356768, 0.19671538064617666, 0.19259257017531395, 0.20426991946512918, 0.20996672999986554, 0.174147265739097, 0.17654516522273112, 0.18528897846554926, 0.21838504729208308, 0.1898840262249868, 0.20250009692012538, 0.2335308638095125, 0.2315633553522145, 0.2161537936923409, 0.20085928408389042, 0.18663950426898968, 0.2053005596021552, 0.39826740733886556, 0.5240710613472019, 0.17258742049767584, 0.1791059610351622, 0.5184317516117689, 0.16504232475901737, 0.38891117709407863, 0.14996047495761577, 0.2918895351934909, 0.15499132861418652, 0.14303949369567093, 0.1971248078537463, 0.1970637741399277, 0.3300248359926302, 0.2005586408327088, 0.46433173625240187, 0.16122287275594882, 0.159716186701237, 0.218567957792839, 0.17815969506375529, 0.16133871886037754, 0.1858529631257435, 0.1681519037892094, 0.17484315447162357, 0.16207608905943327, 0.17748356825956746, 0.16500071000332428, 0.16061705743416532, 0.07869733973425341, 0.07732411863784128, 0.07820590440281827, 0.08334793797087436, 0.0829108173503651, 0.06506206652127255, 0.06184483798407614, 0.09267204958626263, 0.08282178285078423]}, "mutation_prompt": null}
{"id": "c296e4cf-5d2c-44f0-a101-779448328099", "solution": "import numpy as np\n\nclass EnhancedDynamicCrossoverBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, scaling_factor=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.scaling_factor = scaling_factor\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                scaling_factor = np.random.uniform(0.5, self.scaling_factor)\n                mutant = population[a] + scaling_factor * self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedDynamicCrossoverBatAlgorithmOptimizer", "description": "Enhance the differential evolution process by introducing a dynamic scaling factor based on the population fitness diversity.", "configspace": "", "generation": 5, "fitness": 0.14397849371443097, "feedback": "The algorithm EnhancedDynamicCrossoverBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.11.", "error": "", "parent_id": "9005ba25-74f5-4990-b450-3e01baeba528", "metadata": {"aucs": [0.25990517710120364, 0.2488314292044601, 0.6283707288945757, 0.26449269117625707, 0.26635499359862846, 0.09997539792594057, 0.25109775027708814, 0.5019568583795251, 0.17108167164015453, 0.08288064902295922, 0.003754248839895946, 9.999999999998899e-05, 0.22171194986944132, 9.999999999998899e-05, 0.04389028590258981, 9.999999999998899e-05, 0.21809910032981794, 9.999999999998899e-05, 0.18444109500391082, 0.09126600750948333, 0.15429727427150697, 0.1425580860261655, 0.13190200530554463, 0.1374582696211517, 0.0845716375108545, 0.11125698156632102, 0.1565827625538042, 0.10343685112248857, 0.038078478632023294, 0.11081452382087698, 0.08510335498858168, 0.10182397651673514, 0.0436389734270588, 0.13060071159410014, 0.06832641958804231, 0.07892455229875872, 0.10930254279827789, 0.10978634134347576, 0.06881839934222134, 0.10095010653692604, 0.16278049388175075, 0.06791564964259011, 0.11420246365469489, 0.11237316650988727, 0.10021469773793401, 0.05603290574060904, 0.01980747742502431, 0.0608546660035687, 0.10344404228267012, 0.11730024068994915, 0.1384666053217054, 0.13055206847882328, 0.15408360548959643, 0.015730138188290388, 0.20974989301127678, 0.09116617488351497, 0.1803183908091872, 0.7435796630991633, 0.16901774203829534, 0.1878284138066949, 0.10164853502101834, 0.2071707036178192, 0.23152713968175054, 0.10905285203821735, 0.08630671867932593, 0.03870793730822841, 0.045123041743844294, 0.0023976584788941713, 0.21823449938997241, 0.2182160680279509, 0.2679079961214573, 0.012463564753981915, 0.15380163597407992, 9.999999999998899e-05, 0.12175686262193375, 0.07428384666523213, 0.20863822112365138, 0.1278806075153045, 0.07148934363362747, 0.07390890742680645, 0.10274492639153143, 9.999999999998899e-05, 0.07047814538624042, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02367954088702484, 0.006713537978042194, 9.999999999998899e-05, 9.999999999998899e-05, 0.07007396968131019, 0.09970914953547272, 0.08825809011239072, 0.05500010959039969, 0.042972568195196126, 0.046980801342908496, 0.14793101099774464, 0.01432012174450048, 0.08918527146931088, 0.11062702413877068, 0.2798915569535593, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16319364512725898, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07180470876947498, 0.05567601434552816, 0.026334308128842743, 0.0810107431247703, 0.10076587332208142, 0.05183628802165874, 0.21018440985844156, 0.015157751640209938, 0.30775624568893567, 0.3761227511558858, 0.36157416014227683, 0.177068925883765, 0.38013183687538443, 0.24821244922109142, 0.3871999087511968, 0.3562140520433863, 0.2947432255056831, 0.08776113076167125, 0.04518700367380957, 0.10191823562528934, 0.12944382122748632, 0.08523003113983763, 0.10562766706313453, 0.06099170571024515, 0.09332428806218773, 0.07314820537175715, 0.1543379348255206, 0.13476092201955447, 0.25201595701502044, 0.14723052319658514, 0.12274674351014869, 0.21633902037788844, 0.24633641009345386, 0.14643639734641167, 0.2080247159742893, 0.23157896523228538, 0.1668795472659882, 0.2872219872891104, 0.41626292597226644, 0.2155217160694869, 0.3761462937894814, 0.16969507003145867, 0.1910261028604051, 0.17623058441531525, 0.12624639218766764, 0.18458002927822814, 0.16204787533631426, 0.2655828465252347, 0.2937722979022833, 0.14473935213320888, 0.1476825461619926, 0.2026341649254736, 0.09053464300007708, 0.17533866911365292, 0.1778505783144536, 0.19802821851768337, 0.18685951968902348, 0.20201095119073664, 0.1976742149011954, 0.21818937718730214, 0.17020729046150174, 0.20128741216582113, 0.22344195789365395, 0.1746427911731816, 0.2304327640967646, 0.185784276619246, 0.2148488271927227, 0.1879243071480572, 0.19587726129289362, 0.19601241929817292, 0.1952569727933462, 0.1571169724049547, 0.18220208313418185, 0.29679408916462136, 0.2201358208046571, 0.19029842466858538, 0.16086766192426072, 0.22247719240693675, 0.13817723884782973, 0.16493187755005978, 0.2938224747958559, 0.07294050642750738, 0.14170228258130668, 0.16379303867323747, 0.24937635417416593, 0.12079683889012871, 0.11046502489384924, 0.09365647241080954, 0.14795646187230593, 0.1745188014357716, 0.17671554800469935, 0.170076765179898, 0.1981475490786877, 0.17662080006999736, 0.16542282131628783, 0.17563844365620662, 0.16480411115005722, 0.17130682995410185, 0.08041247415617525, 0.10467454484854644, 0.06118701187927422, 0.07818964468468659, 0.08943491904917411, 0.10803343854605352, 0.09104664035964127, 0.07657697457807011, 0.09049460225508354]}, "mutation_prompt": null}
{"id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.2756369217631826, "feedback": "The algorithm EnhancedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "9005ba25-74f5-4990-b450-3e01baeba528", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "017188e0-03a4-4ae8-9201-a921d3aa0a29", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "330212fc-6e60-4930-935f-37293ddb069a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "99dccaf6-a000-4a57-b8b6-0c81f3c2936a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "cb89ddc6-a7d3-400b-9e00-189de94ce13b", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "bcf87518-8893-4da2-907b-044ba4c26c1d", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "51d647b6-437f-487f-b030-aa002ad64018", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "37ef34ae-6082-49ec-ad79-28b17aad6645", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "f7708792-61ad-40c0-b71f-fccd626eaf7c", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "25bdac5c-9451-4127-8a61-655656b9a340", "solution": "import numpy as np\n\nclass EnhancedDynamicMutationBatAlgorithmOptimizer(EnhancedBatAlgorithmOptimizer):\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        super().__init__(budget, dim, population_size, loudness, pulse_rate, alpha, gamma, differential_weight, crossover_rate, crossover_adjust_rate, mutation_scale)\n\n    def __call__(self, func):\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def dynamic_mutation(fitness):\n            diversity = np.std(fitness)\n            mutation_scale = self.mutation_scale / (1 + diversity)\n            return mutation_scale\n\n        population = self.init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = self.differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = self.update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = self.update_loudness(True)\n                    else:\n                        self.loudness = self.update_loudness(False)\n\n                mutation_scale = dynamic_mutation(fitness)\n                mutation = np.random.normal(0, mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedDynamicMutationBatAlgorithmOptimizer", "description": "Improve exploration by incorporating a dynamic mutation strategy based on fitness diversity.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedDynamicMutationBatAlgorithmOptimizer' object has no attribute 'init_population'\").", "error": "AttributeError(\"'EnhancedDynamicMutationBatAlgorithmOptimizer' object has no attribute 'init_population'\")", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {}, "mutation_prompt": null}
{"id": "85b190ed-9d91-416b-8173-8c45e84dfb7d", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "a1b15275-e892-4730-bfb6-4bfa7cef8c7c", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "fcaafc8e-54a2-46a8-9dbe-84a4aa14935e", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "4ffcb636-139f-467d-be6a-3860ac57bdcb", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "c2cf62a2-da58-4988-a776-02eaf98b8d20", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "03cc5009-2c40-401f-9c30-0b30b0176341", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "a30ee950-46d2-426c-a343-4e9f5ff54245", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "a6d725aa-29a2-40d9-b585-2bacff89dd72", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "240c4495-38c9-4430-930a-f0fd8397cb40", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1, diversity_threshold=0.3, mutation_scale_min=0.01, mutation_scale_max=0.2):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n        self.diversity_threshold = diversity_threshold\n        self.mutation_scale_min = mutation_scale_min\n        self.mutation_scale_max = mutation_scale_max\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def update_mutation_scale(fitness):\n            diversity = np.std(fitness)\n            if diversity < self.diversity_threshold:\n                self.mutation_scale = min(self.mutation_scale * 2, self.mutation_scale_max)\n            else:\n                self.mutation_scale = max(self.mutation_scale / 2, self.mutation_scale_min)\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    update_mutation_scale(fitness)\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating a dynamic mutation strategy based on the population's diversity to adaptively adjust mutation rates and improve exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.2756369217631826, "feedback": "The algorithm EnhancedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "758f7487-5af0-465f-b489-44ff98e76062", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "71ed6013-bfa7-40f3-af07-af667e0cd2c3", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "a5f04f8c-b2a4-4585-8e97-e69c01f563b8", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "f40a17a8-1aea-4163-acb5-6f761d4b8a0c", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "45f53591-7541-4448-bac2-62d24f12ecab", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "e0dee7b3-b86c-4fd9-9f11-14961c04664a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "84e82d0a-e9f0-4037-b0b9-57f164369773", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "345b0124-b074-45b4-b446-7a0ca5e0835a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "d0ffa769-6d47-469d-b53a-36e801adfec1", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "8791f2aa-f845-40d9-9638-d7fcc9c7e714", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "264efdf6-4f74-4de2-93bf-1654423f2245", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "1756f840-9765-4336-a718-94076700bf52", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "fbec9e33-f7f0-4f48-a546-f9d0d6235708", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "a9802542-daa0-4997-937b-5bcde6746854", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "97f1eb40-0b3c-4369-9074-6fe481644ee8", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "be95a9a2-aaec-40ba-9b69-e06bb2da29dc", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "88116c33-5154-45ec-bd6c-896a18dec7bb", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "0080a41c-4f7b-4955-a2a5-20d8d5094669", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "cbe2b08b-f208-4453-87f0-f7b1b0ead564", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "52c6f921-de63-4c57-92e2-47a7c5d1cd55", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "c4d8fe58-d874-49bf-90bd-ff250a66dc60", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "24c341b8-8cf6-4e77-8f87-4b0c5e0ccf06", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "84e454b4-d673-4872-ae22-81d630c884d5", "solution": "import numpy as np\n\nclass EnhancedChaoticBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def chaotic_flight():\n            chaos_param = 0.3\n            chaos_noise = np.random.standard_cauchy(self.dim)\n            step = chaos_param * chaos_noise\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += chaotic_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedChaoticBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by integrating a chaotic element to improve exploration capabilities.", "configspace": "", "generation": 47, "fitness": 0.2756369217631826, "feedback": "The algorithm EnhancedChaoticBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "30356ff9-003c-44cf-a936-827d5c62db7d", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "82e89148-4164-4f75-9d85-2232661c4fc2", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "460238bf-61e0-4a19-8f1b-33f33cab8d7d", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "410339af-7f99-4cb2-a8d6-bc84a1aab658", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "5b52251c-6835-4f95-a27a-de29d1506181", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "39ce371f-8f77-4e58-8c5c-7c590dbc45dd", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Dynamically adjusting mutation scale based on population diversity\n                if np.std(population) > 0.1:\n                    self.mutation_scale *= 1.1\n                else:\n                    self.mutation_scale /= 1.1\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Differential Evolution process by dynamically adjusting the mutation scale based on population diversity to improve exploration and convergence speed.", "configspace": "", "generation": 53, "fitness": 0.2756369217631826, "feedback": "The algorithm EnhancedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "95c529e1-3308-4bab-b28e-25b0b530ae13", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "f1626800-0f26-44b0-9bbb-26987a1e43d2", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "2ce44048-a576-487b-b041-eed53ca97b69", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "64d96fd2-f096-4dda-9ed9-b08c394f3629", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "2f23c8ef-6dfb-42b4-851e-324f986893ca", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "bad0c5c8-0c3e-4c9f-94a4-e2a395a64676", "solution": "import numpy as np\n\nclass DynamicMutationBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Dynamic adaptation of mutation scale based on population diversity\n                diversity = np.mean(np.std(population, axis=0))\n                self.mutation_scale = 1 / (1 + np.exp(-diversity))  # Sigmoid-based adaptation\n\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "DynamicMutationBatAlgorithmOptimizer", "description": "Refine the Bat Algorithm by introducing dynamic adaptation of mutation scale based on population diversity to enhance global exploration.", "configspace": "", "generation": 59, "fitness": 0.2756369217631826, "feedback": "The algorithm DynamicMutationBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "bf428384-8a9d-4e54-92be-2bcad8e81eb8", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "e699dc2d-9290-433e-b8b8-2336e0af75dd", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "9813b8f0-c00c-4f5d-8572-31cabc09e0ec", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "1ad415dc-dd16-4f0e-a137-f8781de92213", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "630136b3-ed00-4fac-ad3c-a32a98057cb7", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "77bb1b90-6aeb-48b0-a04c-3506263a1ef1", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "7cf216a0-c9bc-4d45-8e8f-fa437b5e30d0", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "96e6c20a-7a96-4c30-aa53-99c5f174ce4b", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def chaotic_map():\n            x = np.random.uniform(-5.0, 5.0, self.dim)\n            a = 1.1\n            b = 0.5\n            chaotic_step = np.zeros(self.dim)\n            for i in range(self.dim):\n                x[0] = np.sin(a * x[i]) - np.cos(b * x[i])\n                chaotic_step[i] = x[0]\n            return chaotic_step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += chaotic_map() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Improve the exploration capability by incorporating a chaotic map-based diversity enhancement strategy.", "configspace": "", "generation": 67, "fitness": 0.266363582141259, "feedback": "The algorithm EnhancedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8401984235557536, 0.6056124677213184, 0.6664565789626831, 0.1992679311517207, 0.831624754257895, 0.3372775059364006, 0.8323448780950384, 0.8506036710318815, 0.797766733218081, 0.7279212959258688, 0.6824088761774068, 0.26123650849003277, 0.35810286242870537, 0.7015377751979373, 0.46597178455469346, 0.2700066240571092, 0.326025220747705, 0.7360980768415291, 0.19170450566556596, 0.16044360653813328, 0.1695610906978603, 0.17178137585935327, 0.14233215134989952, 0.6098913951051448, 0.22176095904811854, 0.17258569352088415, 0.16057395582315404, 0.16823807794590595, 0.16991671080673043, 0.09471525312824958, 0.14675587175082205, 0.08194967460596092, 0.15961899436604832, 0.5564527433215068, 0.12027605863706958, 0.10098576445194773, 0.9516264155745213, 0.9310194775529878, 0.1523372310038389, 0.9439895550585897, 0.8921266304764582, 0.9225974851848, 0.9279586932902407, 0.8464267188590515, 0.9646204514776522, 0.12523500903266127, 0.1301470720063309, 0.3869480160230242, 0.38856372450826027, 0.27835716742239425, 0.14220264049994602, 0.1664474825537009, 0.2572586588084107, 0.16925214357345886, 0.7523377745718232, 0.5916966013184254, 0.28398728746014823, 0.5699673662835398, 0.7655100207266711, 0.3378386078572909, 0.22443633321699885, 0.17226542928279143, 0.22823417140591085, 0.3986919564217669, 0.12977343208293168, 0.15309487943654, 0.1390828148530845, 0.13094501029446037, 0.2243888621725697, 0.13851791507565736, 0.16423755556484398, 0.15010979137480518, 0.16127400036347206, 0.13851721173936438, 0.12321188025050611, 0.14501970183308843, 0.1210792762609666, 0.15839470403276978, 0.14635668122843382, 0.00510871193583784, 0.15166229876837445, 0.011675847803021111, 9.999999999998899e-05, 0.0636308120093223, 0.00998929843698737, 9.999999999998899e-05, 0.06153642420978467, 9.999999999998899e-05, 0.030447057743715256, 0.01711025926299914, 0.09596295577816583, 0.03261697165959154, 0.10571939830265598, 0.07374109005244078, 0.23315273601113773, 0.07759373614171095, 0.18249491311645383, 0.0768835866951133, 0.04546942622642525, 0.09496063265251631, 0.06686580297299094, 0.015888447654132665, 0.08821025827843865, 0.08698222421856283, 0.057492930172509116, 0.09768661822975067, 9.999999999998899e-05, 0.026466336238891053, 0.1423543963646443, 0.13461947369182758, 0.11658240488135818, 0.12474655675529356, 0.1973633163291122, 0.12448485640188733, 0.19518764276542433, 0.16903495699794258, 0.09768171252372193, 0.5366411737104902, 0.5433763345324631, 0.4595777503570182, 0.2018669302698699, 0.5621223914491033, 0.48871189845081975, 0.4831385154366641, 0.5058887950781069, 0.667217401031367, 0.09248085538292927, 0.11390259391708746, 0.09818703572122178, 0.11176822223236282, 0.09026819468951053, 0.08920179492125224, 0.10740448374304123, 0.08623748112515295, 0.08738149930229488, 0.121847292773266, 0.14069501662858552, 0.1587371661382998, 0.13366846989933934, 0.19450155965334248, 0.15302499482148946, 0.1369536546668655, 0.12468461818261944, 0.12120736248844188, 0.43357305116916245, 0.32496166767160295, 0.3393732797065765, 0.4127708123266526, 0.42663360839625075, 0.38027800496441233, 0.3774638808771885, 0.45274845409310926, 0.39074555511312514, 0.2552908028243145, 0.27885236213240017, 0.20218886566987793, 0.2535708985779024, 0.24791525734834574, 0.2581474169667738, 0.16377966874216743, 0.30271307213203613, 0.2709543194823574, 0.19279419319397773, 0.21616899641205656, 0.21003539052426767, 0.17797941064431744, 0.19725902175740184, 0.1842733049810833, 0.18553754954026946, 0.1702356411232282, 0.17269849554143968, 0.20166243488662605, 0.5006187528371069, 0.1941465577567837, 0.28435155188145433, 0.22410985885447277, 0.19811310602922572, 0.21434241834351464, 0.24036428581943958, 0.5516136561556889, 0.5893782532854275, 0.7125625872830389, 0.13905678216868889, 0.3746726783041773, 0.2881036349182614, 0.3350022604554489, 0.17015336459828012, 0.1544781112225483, 0.16536171472839, 0.28715669810481737, 0.5899113415074606, 0.25869589215242395, 0.3270072743087671, 0.15515820292721016, 0.20154269538980785, 0.10187166588638374, 0.13441050648516706, 0.3113199653850768, 0.1681376426978488, 0.16139988196743138, 0.20336320201386826, 0.1659226469423516, 0.1795908958156458, 0.19795917724230616, 0.16472631534134174, 0.17144704209440675, 0.1631283268691468, 0.0728687401775463, 0.06690570697168774, 0.07253527292567763, 0.07202607172055175, 0.0652516018774213, 0.0670910898812177, 0.06397713301610197, 0.0812394485613186, 0.07426704593302658]}, "mutation_prompt": null}
{"id": "1937d34f-d7a6-42a0-95bc-26fcba898d58", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "8428002c-2f16-4415-b33f-6486d2e86bc8", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "8c5eccd5-bf19-434d-8eef-ead7c6a803a1", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "8764bff9-cfd4-4df1-b385-1c38e1d02ba4", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "c726450f-fdac-498b-bc8b-73fbce694141", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "17f97044-c2b8-4db8-9c81-bd41ea5db899", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "67f8e903-93c4-4e2f-9d73-9765cc788638", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "c9937960-4260-4a11-9af9-46ea9f4bab5a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "64eece6e-2534-4113-9ad1-daa7cb3ecdfb", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1, levy_beta=1.5):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n        self.levy_beta = levy_beta\n\n    def __call__(self, func):\n        def update_step_size(step_size, fitness_improved):\n            if fitness_improved:\n                return step_size * self.gamma\n            else:\n                return step_size / self.gamma\n\n        def levy_flight():\n            sigma = (np.math.gamma(1 + self.levy_beta) * np.sin(np.pi * self.levy_beta / 2) / (\n                    np.math.gamma((1 + self.levy_beta) / 2) * self.levy_beta * 2 ** ((self.levy_beta - 1) / 2))) ** (1 / self.levy_beta\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / np.abs(v) ** (1 / self.levy_beta)\n            return step\n\n        population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n\n            for i in range(self.population_size):\n                step_size = levy_flight()\n                if np.random.rand() < self.pulse_rate:\n                    step_size = 0.0\n                else:\n                    step_size = update_step_size(step_size, func(new_population[i]) < func(population[i]))\n\n                new_population[i] += step_size\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating Levy flight with adaptive step size based on individual performance and adapt the crossover rate dynamically based on the population fitness variability.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 28, 13, '            u = np.random.randn(self.dim) * sigma\\n')).", "error": "SyntaxError('invalid syntax', ('<string>', 28, 13, '            u = np.random.randn(self.dim) * sigma\\n'))", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {}, "mutation_prompt": null}
{"id": "a0b59791-9a19-413b-844a-87342756f4f3", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "4ba7323d-85c3-47cc-8911-34e156e1fb0a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "c4607212-af78-400b-809b-7e2a5ae73c9a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "5801c9b6-28b3-4721-89ef-6108506b3c8a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "994a3926-5412-4ddf-bdbf-260b043bbde8", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "c8c8af74-ffb4-4841-bb2a-ca825f33c6e2", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "c524ef59-ce24-4479-98fc-2663cb57592f", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "6bab221a-1643-4569-95ca-8e3d4dc6702f", "solution": "import numpy as np\n\nclass DynamicBatAlgorithmOptimizer(EnhancedBatAlgorithmOptimizer):\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1, mutation_scale_adjust_rate=0.1):\n        super().__init__(budget, dim, population_size, loudness, pulse_rate, alpha, gamma, differential_weight, crossover_rate, crossover_adjust_rate, mutation_scale)\n        self.mutation_scale_adjust_rate = mutation_scale_adjust_rate\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                # Adaptive mutation rate adjustment based on individual performance\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                        self.mutation_scale *= 1 + self.mutation_scale_adjust_rate\n                    else:\n                        self.loudness = update_loudness(False)\n                        self.mutation_scale *= 1 - self.mutation_scale_adjust_rate\n\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "DynamicBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating dynamic adaptive mutation rates based on individual performance for improved exploration and exploitation.", "configspace": "", "generation": 84, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'differential_evolution' is not defined\").", "error": "NameError(\"name 'differential_evolution' is not defined\")", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {}, "mutation_prompt": null}
{"id": "25f33dec-08c2-4d75-a489-daa78f3c749a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "8dca8314-0c7b-4d83-8e09-23008347c606", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "7d948460-9d89-462b-b873-cbbeb0215047", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "3b7623b5-3f77-4e4e-8f51-ec33fe249355", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "8a7e4870-7e36-4036-9fc9-19d0f3cfdaf5", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "5f84fe0d-4d7e-43dc-813f-248f78096a74", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "02167254-b50a-47b4-9252-cf76abb1fc36", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "bedd039e-e289-4216-ae9f-0bba39ad0fb5", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "02407f66-7a72-42cd-bf83-fa3a86db9a3a", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "7357ed6e-fc3c-4191-a7cd-018afd5ffcaf", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "e4781b97-c4e5-4e5c-a5bc-ae45aa5af65b", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing novel dynamic mutation strategy based on population diversity\n                diversity = np.std(population, axis=0)\n                mutation = np.random.normal(0, self.mutation_scale * diversity, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < self.diversity_threshold:\n                    self.crossover_rate += self.crossover_adjust_rate\n                    self.mutation_scale += self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating a novel dynamic mutation strategy based on population diversity to improve exploration and exploitation trade-off.", "configspace": "", "generation": 95, "fitness": 0.26235633827230415, "feedback": "The algorithm EnhancedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.89198179305853, 0.845308097771298, 0.8231406240418433, 0.1902924695773207, 0.7530575363125906, 0.364193713160186, 0.6132760425722845, 0.18846160676141355, 0.4852143493696093, 0.419311095835625, 0.2772733504410839, 0.5571568168218715, 9.999999999998899e-05, 0.6883357454335441, 0.07351892136055416, 0.7151173875604331, 0.7230551973802204, 0.46744248954266354, 0.1403170932471245, 0.13885596775612719, 0.08973469404424117, 0.6322282735947262, 0.15984295466788112, 0.15970832091799547, 0.16402048701892058, 0.24254976701576358, 0.12025608004221122, 0.1459989482147479, 0.08640591994496749, 0.1403627756360465, 0.13407041270950615, 0.13033294240319682, 0.1547420106131171, 0.15884779409700045, 0.12092408970843627, 0.14809391817304263, 0.37783870061743696, 0.9577837899779675, 0.9556925739392328, 0.9494946370702845, 0.9453085920990167, 0.9612385232462667, 0.9560188597579055, 0.9220129755456952, 0.1267758129411506, 0.18317774644881446, 0.1608839731430628, 0.10504362421577462, 0.10884088542967674, 0.12216662991753202, 0.22932609700705364, 0.17246360586318987, 0.10776829101031848, 0.20575337422041884, 0.3026784442831816, 0.6518276015611724, 0.18140754758023248, 0.32335120858445976, 0.18616627485906623, 0.20578164793413434, 0.2258806077521871, 0.3427475811917827, 0.2242350135898712, 0.34142013750212563, 0.1278215890352773, 0.3780323935727904, 0.16451929630614126, 0.13578512424065325, 0.4517458167938606, 0.39282503001007685, 0.11982305818515493, 0.1343121254671843, 0.14468373018959246, 0.1697758794232861, 0.1547314258076098, 0.14657267081121195, 0.2636619948854694, 0.16139217959376495, 0.21858446136443765, 0.1260096980944292, 0.16782896334677921, 9.999999999998899e-05, 0.03653589436347193, 0.016282206537618915, 0.006309574422980746, 0.05896545755925475, 9.999999999998899e-05, 9.999999999998899e-05, 0.001419204270368346, 9.999999999998899e-05, 0.09622957228136386, 0.06948277475474929, 0.22177699837110698, 0.09376423881120122, 0.08497769557053758, 0.02796798281399493, 0.1293558902833578, 0.22601313770923326, 0.09230639451176359, 0.15155816828953006, 0.1869947878988265, 0.134117205236285, 0.06603176360668006, 0.12442318160730304, 0.020714961176819813, 0.04631877548766494, 0.1079190676786953, 0.0831336584202298, 0.12272193637360795, 0.21803476598012606, 0.19467320017938228, 0.06443529378817003, 0.2443262839864455, 0.23528794851870383, 0.29089006709409304, 0.2530872030652308, 0.0757639007431895, 0.44124152036005715, 0.47969232295461695, 0.42656870975438665, 0.13602521802445422, 0.5090181996545939, 0.5234601079300129, 0.5935485589145337, 0.5000069083858288, 0.46098116739630746, 0.0900692469607366, 0.0962310464183429, 0.13030780183698332, 0.08861622337915542, 0.1045987946365492, 0.11864690910861064, 0.12770498111834983, 0.09712906618790806, 0.10396386258816515, 0.11362256393504144, 0.11086222253149514, 0.21148029265941537, 0.12726125858118542, 0.13585126777935042, 0.19769135547971728, 0.13862354427492196, 0.12013383504786557, 0.1257981979816052, 0.26293247660657704, 0.4196894480521044, 0.3711511231283554, 0.44444997045588486, 0.3155094629006404, 0.39497633168149293, 0.1885501083774458, 0.40907048387258094, 0.39849556883943704, 0.31687253350036304, 0.22208224821834877, 0.21516759013272968, 0.17498340247707578, 0.24159826959062025, 0.34215920516410836, 0.29103576610363735, 0.14615506778190102, 0.20268231724665164, 0.2163814338554776, 0.19672450659511864, 0.17729223662321458, 0.18330629086672356, 0.18151860705700562, 0.19459273365073493, 0.182695727645231, 0.17019194717684205, 0.21311381933457285, 0.1981327553815635, 0.5321108238645288, 0.6999991276832163, 0.19871431386375404, 0.19381753116409117, 0.551365986070758, 0.21847763276671028, 0.20398134623836772, 0.2103246757282915, 0.17827327287637995, 0.1666561524619179, 0.7329690016621551, 0.8906550085769945, 0.18066163558603132, 0.8102395507074647, 0.747613854804271, 0.6865557409263029, 0.7967134167675125, 0.3450222334200661, 0.16738572645986172, 0.07256571083977015, 0.22421599326485586, 0.32879171440421284, 0.20466084013780028, 0.2993765067471713, 0.12517720178138547, 0.10918304232435316, 0.1800674710478446, 0.18040057827423783, 0.18061970963595964, 0.16937674100045064, 0.1685136628124827, 0.20106070122940578, 0.1948152033840017, 0.1795205637649797, 0.17580539761766123, 0.07232899423530981, 0.0777930054428525, 0.06547376575652253, 0.07756690355117057, 0.07761067506577313, 0.07186071021536067, 0.061041078420042916, 0.07886627912579569, 0.0831538962981484]}, "mutation_prompt": null}
{"id": "2ed6b3bb-9923-49bf-8125-1f7877187754", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "238d9def-fd3e-40d6-bd4a-fb863a6b7a3b", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n\n    def __call__(self, func):\n        def init_population():\n            return np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n\n        def update_frequency(f):\n            return f * self.alpha\n\n        def update_loudness(fitness_improved):\n            if fitness_improved:\n                return self.loudness * self.gamma\n            else:\n                return self.loudness / self.gamma\n\n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                    np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.randn(self.dim) * sigma\n            v = np.random.randn(self.dim)\n            step = u / abs(v) ** (1 / beta)\n            return step\n\n        def differential_evolution(population, fitness, func):\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                idxs = np.arange(self.population_size)\n                idxs = np.delete(idxs, i)\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = population[a] + self.differential_weight * (population[b] - population[c])\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                if func(trial) < fitness[i]:\n                    new_population[i] = trial\n            return new_population\n\n        population = init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = update_frequency(0.0)\n                    new_population[i] += levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = update_loudness(True)\n                    else:\n                        self.loudness = update_loudness(False)\n\n                # Introducing adaptive mutation based on individual performance\n                mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating adaptive mutation based on individual performance to improve exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.8307049372897204, 0.6096108964423208, 0.8490837390164565, 0.8204395183560638, 0.6618989537468363, 0.6718575589434925, 0.8208286141931411, 0.8440484638782029, 0.8521366483341488, 0.5404990580905051, 0.7096403722796396, 0.6878613186043501, 0.6617744046066099, 0.1892547550840804, 0.7154030947369596, 0.7057395960421062, 0.7535234695841413, 0.30697083939393455, 0.12354711074847369, 0.16313030093821412, 0.15356934777192477, 0.16060938495805, 0.1653815745400914, 0.09407070535353101, 0.17573559408517792, 0.178743176298236, 0.16139596812656787, 0.13560947699746617, 0.15111023924079758, 0.14529522071437462, 0.1760920483084758, 0.1154889993461895, 0.11137398046931579, 0.11247841035648287, 0.3721285563994504, 0.1892621696252521, 0.8894216175513139, 0.9554931530784543, 0.9587762306792449, 0.9299857045979286, 0.8914669382912431, 0.9537232142573789, 0.9504848522083683, 0.9573611052754788, 0.9513801046234023, 0.19432652833562714, 0.19209359954125105, 0.1488875132619374, 0.08199886102076503, 0.15935287851769442, 0.31897121732163847, 0.17822727908128477, 0.26169414267652824, 0.22311560681995046, 0.2308640335834824, 0.5023240601126915, 0.15776760420012614, 0.1735395340282525, 0.20761558483615772, 0.6718581433368163, 0.6600897347914187, 0.6191415887861043, 0.6972433017099025, 0.31925792167945233, 0.12886677356334042, 0.1263153149192352, 0.1467522175795264, 0.14437974089748462, 0.16584167692421248, 0.15964729737823202, 0.1837744620560101, 0.158051024664014, 0.18229519110825054, 0.13318329083277491, 0.19086065839448152, 0.1361275560320846, 0.13213729519989426, 0.17571263330040277, 0.23682662859481696, 0.1571682204708592, 0.16093269272307464, 0.006940270382188252, 0.0032288145443520877, 0.0018663805645281473, 0.0006419235315623384, 0.04345722444120914, 9.999999999998899e-05, 9.999999999998899e-05, 0.006239331690030103, 0.07778711878098621, 0.13221132334611008, 0.07773122245194641, 0.0984966920567214, 0.11025163064295507, 0.01463093657202641, 0.012990318890966024, 0.07500072649007983, 0.1173179516407965, 0.10739193338850805, 0.08665769833510806, 0.07076889879414905, 0.080251408225131, 0.009238068714624514, 0.08085988048881476, 0.020750453294454796, 0.010768655200954713, 0.05785264415599034, 0.012528390310087678, 0.13275979923675219, 0.17541849880864846, 0.2600198201048928, 0.26823112111340897, 0.2304746793019956, 0.22147269439227624, 0.012182737669553356, 0.12929186173487361, 0.12937103959158813, 0.45522514521409274, 0.5410059276497108, 0.46986804209331223, 0.164606837929121, 0.5508146909024636, 0.5471886769935895, 0.49177117667156434, 0.5421223092667913, 0.5046974191985749, 0.11969855433390453, 0.11269655508296494, 0.08761463841311712, 0.10986188275834885, 0.0918498213339235, 0.10257513135857155, 0.11650370276550981, 0.0792148090360133, 0.08569925344891438, 0.1403694230359731, 0.16910025222623304, 0.126774055116045, 0.12155746238213938, 0.09990867830766781, 0.12679578066680786, 0.11804781490136651, 0.12182985748084452, 0.12310934504504167, 0.36064998345626476, 0.38623117307742827, 0.36906379678053636, 0.2899681890655156, 0.2849995743470195, 0.350978376237992, 0.3782394246686246, 0.40056093174320617, 0.45381520308357004, 0.23168165430443655, 0.24567178640182474, 0.22850876554674948, 0.3144991118414868, 0.24358680861489612, 0.18963119686665764, 0.2522345713276193, 0.3401403744775323, 0.26605110909473406, 0.22541334302560634, 0.18459941453903406, 0.19320403841468137, 0.19635337536773856, 0.19602962043181893, 0.21535947980983006, 0.20109300508434402, 0.17863368199652052, 0.19560844761703888, 0.5056268612739601, 0.19816585207617343, 0.30656674851917576, 0.17583342803217095, 0.20480692585504012, 0.22499186639734092, 0.19655349556624246, 0.48307975573617545, 0.30269407032387785, 0.6008430754494944, 0.17729628131837238, 0.17499336363293316, 0.6616707189002338, 0.5940767031715788, 0.7646962406159895, 0.13740411830564103, 0.14880890792029144, 0.15721893074594595, 0.31093330846259015, 0.19401997758030898, 0.18731289794507677, 0.30532788274648015, 0.5787540921436809, 0.27156304134543785, 0.1935481202559628, 0.19859823732048398, 0.18973627754204403, 0.16030543101766925, 0.16536557268202012, 0.19756560173864623, 0.1708403018982141, 0.17163684329748452, 0.17287593398998746, 0.17465007315136227, 0.16359083485191073, 0.17333012708825535, 0.08658413476432492, 0.0760308787924916, 0.07687489019072569, 0.06744856893751183, 0.07533964471321708, 0.07602891844201054, 0.08366002954232266, 0.08755599193491548, 0.07254108316472263]}, "mutation_prompt": null}
{"id": "d03ceab0-6b23-4aef-b2da-6170d5fa4be7", "solution": "import numpy as np\n\nclass DynamicAdaptiveBatAlgorithmOptimizer(EnhancedBatAlgorithmOptimizer):\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1, global_mutation_scale=0.1):\n        super().__init__(budget, dim, population_size, loudness, pulse_rate, alpha, gamma, differential_weight, crossover_rate, crossover_adjust_rate, mutation_scale)\n        self.global_mutation_scale = global_mutation_scale\n\n    def __call__(self, func):\n        def update_global_mutation():\n            return np.random.normal(0, self.global_mutation_scale, self.dim)\n\n        population = self.init_population()\n        fitness = np.array([func(x) for x in population])\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        for _ in range(self.budget):\n            new_population = self.differential_evolution(population, fitness, func)\n            for i in range(self.population_size):\n                if np.random.rand() > self.pulse_rate:\n                    frequency = 0.0\n                else:\n                    frequency = self.update_frequency(0.0)\n                    new_population[i] += self.levy_flight() * frequency\n\n                if np.random.rand() < self.loudness and func(new_population[i]) < func(population[i]):\n                    population[i] = new_population[i]\n                    fitness[i] = func(population[i])\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n                        self.loudness = self.update_loudness(True)\n                    else:\n                        self.loudness = self.update_loudness(False)\n\n                # Introducing dynamic adaptive mutation\n                if np.random.rand() < 0.5:  # Global mutation\n                    mutation = update_global_mutation()\n                else:  # Individual mutation\n                    mutation = np.random.normal(0, self.mutation_scale, self.dim)\n                new_population[i] += mutation\n\n            if _ % int(0.2 * self.budget) == 0:\n                mean_fitness = np.mean(fitness)\n                std_fitness = np.std(fitness)\n                if std_fitness < 0.1:\n                    self.crossover_rate += self.crossover_adjust_rate\n                elif std_fitness > 0.5:\n                    self.crossover_rate -= self.crossover_adjust_rate\n                self.crossover_rate = np.clip(self.crossover_rate, 0, 1)\n\n        return best_solution", "name": "DynamicAdaptiveBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating dynamic adaptive mutation based on both global and individual performance to enhance exploration-exploitation balance.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'DynamicAdaptiveBatAlgorithmOptimizer' object has no attribute 'init_population'\").", "error": "AttributeError(\"'DynamicAdaptiveBatAlgorithmOptimizer' object has no attribute 'init_population'\")", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {}, "mutation_prompt": null}
{"id": "176fcd67-eb03-4ba6-b6ee-d38adad7d290", "solution": "import numpy as np\n\nclass EnhancedBatAlgorithmOptimizer:\n    def __init__(self, budget, dim, population_size=10, loudness=0.5, pulse_rate=0.5, alpha=0.9, gamma=0.9, differential_weight=0.5, crossover_rate=0.7, crossover_adjust_rate=0.1, mutation_scale=0.1, mutation_scale_adjust_rate=0.1):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size\n        self.loudness = loudness\n        self.pulse_rate = pulse_rate\n        self.alpha = alpha\n        self.gamma = gamma\n        self.differential_weight = differential_weight\n        self.crossover_rate = crossover_rate\n        self.crossover_adjust_rate = crossover_adjust_rate\n        self.mutation_scale = mutation_scale\n        self.mutation_scale_adjust_rate = mutation_scale_adjust_rate\n\n    def __call__(self, func):\n        def update_mutation_scale(fitness_improved):\n            if fitness_improved:\n                return self.mutation_scale * (1.0 + self.mutation_scale_adjust_rate)\n            else:\n                return self.mutation_scale / (1.0 + self.mutation_scale_adjust_rate)\n\n        # Rest of the code remains the same\n        # ...", "name": "EnhancedBatAlgorithmOptimizer", "description": "Enhance the Bat Algorithm by incorporating dynamic mutation rates based on fitness improvement to adaptively adjust exploration and exploitation during the optimization process.", "configspace": "", "generation": 99, "fitness": 0.0, "feedback": "The algorithm EnhancedBatAlgorithmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_id": "7b64125e-982d-432c-b0cc-a0b1963ac563", "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}, "mutation_prompt": null}
